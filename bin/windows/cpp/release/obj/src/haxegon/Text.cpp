// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxegon_Gfx
#include <haxegon/Gfx.h>
#endif
#ifndef INCLUDED_haxegon_Input
#include <haxegon/Input.h>
#endif
#ifndef INCLUDED_haxegon_Key
#include <haxegon/Key.h>
#endif
#ifndef INCLUDED_haxegon_S
#include <haxegon/S.h>
#endif
#ifndef INCLUDED_haxegon_Text
#include <haxegon/Text.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapTextField
#include <haxegon/bitmapFont/BitmapTextField.h>
#endif
#ifndef INCLUDED_haxegon_util_Fontclass
#include <haxegon/util/Fontclass.h>
#endif
#ifndef INCLUDED_haxegon_util_Fontfile
#include <haxegon/util/Fontfile.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Stage
#include <openfl/display/Stage.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif

namespace haxegon{

void Text_obj::__construct() { }

Dynamic Text_obj::__CreateEmpty() { return new Text_obj; }

hx::ObjectPtr< Text_obj > Text_obj::__new()
{
	hx::ObjectPtr< Text_obj > _hx_result = new Text_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Text_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Text_obj > _hx_result = new Text_obj();
	_hx_result->__construct();
	return _hx_result;
}

::Array< ::Dynamic> Text_obj::fontfile;

 ::haxe::ds::StringMap Text_obj::fontfileindex;

::Array< ::Dynamic> Text_obj::typeface;

 ::haxe::ds::StringMap Text_obj::typefaceindex;

 ::openfl::geom::Matrix Text_obj::fontmatrix;

Int Text_obj::currentindex;

::String Text_obj::currentfont;

Float Text_obj::currentsize;

 ::openfl::display::Stage Text_obj::gfxstage;

 ::openfl::display::BitmapData Text_obj::drawto;

Int Text_obj::LEFT;

Int Text_obj::RIGHT;

Int Text_obj::TOP;

Int Text_obj::BOTTOM;

Int Text_obj::CENTER;

Int Text_obj::textalign;

Float Text_obj::textrotate;

Float Text_obj::textrotatexpivot;

Float Text_obj::textrotateypivot;

Float Text_obj::textalphamult;

Float Text_obj::temprotate;

Float Text_obj::tempxscale;

Float Text_obj::tempyscale;

Float Text_obj::tempxpivot;

Float Text_obj::tempypivot;

Float Text_obj::tempalpha;

Float Text_obj::tempred;

Float Text_obj::tempgreen;

Float Text_obj::tempblue;

Bool Text_obj::changecolours;

 ::openfl::geom::ColorTransform Text_obj::alphact;

Int Text_obj::inputmaxlength;

::String Text_obj::inputtext;

::String Text_obj::lastentry;

Float Text_obj::input_textxp;

Float Text_obj::input_textyp;

Float Text_obj::input_responsexp;

Float Text_obj::input_responseyp;

Int Text_obj::input_textcol;

Int Text_obj::input_responsecol;

::String Text_obj::input_text;

::String Text_obj::input_response;

Int Text_obj::input_cursorglow;

::String Text_obj::input_font;

Float Text_obj::input_textsize;

Int Text_obj::input_show;

void Text_obj::init( ::openfl::display::Stage stage){
            	HX_STACK_FRAME("haxegon.Text","init",0x39c53d43,"haxegon.Text.init","haxegon/Text.hx",72,0xb667cca2)
            	HX_STACK_ARG(stage,"stage")
HXLINE(  73)		::haxegon::Text_obj::drawto = ::haxegon::Gfx_obj::backbuffer;
HXLINE(  74)		::haxegon::Text_obj::gfxstage = stage;
HXLINE(  75)		::haxegon::Text_obj::alphact =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  76)		::haxegon::Text_obj::input_cursorglow = (int)0;
HXLINE(  77)		::haxegon::Text_obj::inputmaxlength = (int)40;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,init,(void))

void Text_obj::align(Int a){
            	HX_STACK_FRAME("haxegon.Text","align",0xb6494132,"haxegon.Text.align","haxegon/Text.hx",81,0xb667cca2)
            	HX_STACK_ARG(a,"a")
HXLINE(  81)		::haxegon::Text_obj::textalign = a;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,align,(void))

void Text_obj::rotation(Float a,hx::Null< Int >  __o_xpivot,hx::Null< Int >  __o_ypivot){
Int xpivot = __o_xpivot.Default(-15000);
Int ypivot = __o_ypivot.Default(-15000);
            	HX_STACK_FRAME("haxegon.Text","rotation",0xf428d4f1,"haxegon.Text.rotation","haxegon/Text.hx",84,0xb667cca2)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(xpivot,"xpivot")
            	HX_STACK_ARG(ypivot,"ypivot")
HXLINE(  85)		::haxegon::Text_obj::textrotate = a;
HXLINE(  86)		::haxegon::Text_obj::textrotatexpivot = xpivot;
HXLINE(  87)		::haxegon::Text_obj::textrotateypivot = ypivot;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Text_obj,rotation,(void))

void Text_obj::input_checkfortext(){
            	HX_STACK_FRAME("haxegon.Text","input_checkfortext",0xffbdc276,"haxegon.Text.input_checkfortext","haxegon/Text.hx",91,0xb667cca2)
HXLINE(  91)		::haxegon::Text_obj::inputtext = ::haxegon::Input_obj::keybuffer;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,input_checkfortext,(void))

Bool Text_obj::input(Float x,Float y,::String text,hx::Null< Int >  __o_col,hx::Null< Int >  __o_responsecol){
Int col = __o_col.Default(16777215);
Int responsecol = __o_responsecol.Default(13421772);
            	HX_STACK_FRAME("haxegon.Text","input",0x52d5ae77,"haxegon.Text.input","haxegon/Text.hx",94,0xb667cca2)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(text,"text")
            	HX_STACK_ARG(col,"col")
            	HX_STACK_ARG(responsecol,"responsecol")
HXLINE(  95)		::haxegon::Text_obj::input_show = (int)2;
HXLINE(  97)		::haxegon::Text_obj::input_font = ::haxegon::Text_obj::currentfont;
HXLINE(  98)		::haxegon::Text_obj::input_textsize = ::haxegon::Text_obj::currentsize;
HXLINE(  99)		Bool _hx_tmp = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN(  99)		if (_hx_tmp) {
HXLINE( 100)			 ::haxegon::bitmapFont::BitmapTextField _hx_tmp1 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap;
HXDLIN( 100)			_hx_tmp1->set_text((text + ::haxegon::Text_obj::inputtext));
            		}
            		else {
HXLINE( 101)			Bool _hx_tmp2 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 101)			if (_hx_tmp2) {
HXLINE( 102)				 ::openfl::text::TextField _hx_tmp3 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf;
HXDLIN( 102)				_hx_tmp3->set_text((text + ::haxegon::Text_obj::inputtext));
            			}
            		}
HXLINE( 104)		x = ::haxegon::Text_obj::alignx(x);
HXDLIN( 104)		y = ::haxegon::Text_obj::aligny(y);
HXLINE( 105)		::haxegon::Text_obj::input_textxp = x;
HXLINE( 106)		::haxegon::Text_obj::input_textyp = y;
HXLINE( 108)		Bool _hx_tmp4 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 108)		if (_hx_tmp4) {
HXLINE( 109)			::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->set_text(text);
HXLINE( 110)			Float _hx_tmp5 = ::haxegon::Text_obj::input_textxp;
HXDLIN( 110)			Float _hx_tmp6 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->get_textWidth();
HXDLIN( 110)			Int _hx_tmp7 = ::Math_obj::floor(_hx_tmp6);
HXDLIN( 110)			::haxegon::Text_obj::input_responsexp = (_hx_tmp5 + _hx_tmp7);
            		}
            		else {
HXLINE( 111)			Bool _hx_tmp8 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 111)			if (_hx_tmp8) {
HXLINE( 112)				::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->set_text(text);
HXLINE( 113)				Float _hx_tmp9 = ::haxegon::Text_obj::input_textxp;
HXDLIN( 113)				Float _hx_tmp10 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->get_textWidth();
HXDLIN( 113)				Int _hx_tmp11 = ::Math_obj::floor(_hx_tmp10);
HXDLIN( 113)				::haxegon::Text_obj::input_responsexp = (_hx_tmp9 + _hx_tmp11);
            			}
            		}
HXLINE( 115)		::haxegon::Text_obj::input_responseyp = y;
HXLINE( 117)		::haxegon::Text_obj::input_text = text;
HXLINE( 118)		::haxegon::Text_obj::input_response = ::haxegon::Text_obj::inputtext;
HXLINE( 119)		::haxegon::Text_obj::input_textcol = col;
HXLINE( 120)		::haxegon::Text_obj::input_responsecol = responsecol;
HXLINE( 121)		::haxegon::Text_obj::input_checkfortext();
HXLINE( 123)		Bool _hx_tmp12;
HXDLIN( 123)		Bool _hx_tmp13 = ::haxegon::Input_obj::just_pressed(::haxegon::Key_obj::ENTER_dyn());
HXDLIN( 123)		if (_hx_tmp13) {
HXLINE( 123)			_hx_tmp12 = (::haxegon::Text_obj::inputtext != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 123)			_hx_tmp12 = false;
            		}
HXDLIN( 123)		if (_hx_tmp12) {
HXLINE( 124)			return true;
            		}
HXLINE( 126)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Text_obj,input,return )

::String Text_obj::get_input(){
            	HX_STACK_FRAME("haxegon.Text","get_input",0x4469454e,"haxegon.Text.get_input","haxegon/Text.hx",130,0xb667cca2)
HXLINE( 131)		HX_VARI( ::String,response) = ::haxegon::Text_obj::inputtext;
HXLINE( 132)		::haxegon::Text_obj::lastentry = ::haxegon::Text_obj::inputtext;
HXLINE( 133)		::haxegon::Text_obj::inputtext = HX_("",00,00,00,00);
HXLINE( 134)		::haxegon::Text_obj::reset_text_input();
HXLINE( 135)		::haxegon::Text_obj::input_show = (int)0;
HXLINE( 137)		return response;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,get_input,return )

void Text_obj::drawstringinput(){
            	HX_STACK_FRAME("haxegon.Text","drawstringinput",0x838c24c2,"haxegon.Text.drawstringinput","haxegon/Text.hx",140,0xb667cca2)
HXLINE( 141)		Bool _hx_tmp = (::haxegon::Text_obj::input_show > (int)0);
HXDLIN( 141)		if (_hx_tmp) {
HXLINE( 142)			::haxegon::Text_obj::setfont(::haxegon::Text_obj::input_font,::haxegon::Text_obj::input_textsize);
HXLINE( 143)			::haxegon::Text_obj::input_cursorglow++;
HXLINE( 144)			Bool _hx_tmp1 = (::haxegon::Text_obj::input_cursorglow >= (int)96);
HXDLIN( 144)			if (_hx_tmp1) {
HXLINE( 144)				::haxegon::Text_obj::input_cursorglow = (int)0;
            			}
HXLINE( 146)			::haxegon::Text_obj::display(::haxegon::Text_obj::input_textxp,::haxegon::Text_obj::input_textyp,::haxegon::Text_obj::input_text,::haxegon::Text_obj::input_textcol);
HXLINE( 147)			Bool _hx_tmp2 = (::haxegon::Text_obj::input_text.length < ::haxegon::Text_obj::inputmaxlength);
HXDLIN( 147)			if (_hx_tmp2) {
HXLINE( 148)				Bool _hx_tmp3 = (hx::Mod(::haxegon::Text_obj::input_cursorglow,(int)48) < (int)24);
HXDLIN( 148)				if (_hx_tmp3) {
HXLINE( 149)					::haxegon::Text_obj::display(::haxegon::Text_obj::input_responsexp,::haxegon::Text_obj::input_responseyp,::haxegon::Text_obj::input_response,::haxegon::Text_obj::input_responsecol);
            				}
            				else {
HXLINE( 151)					Float _hx_tmp4 = ::haxegon::Text_obj::input_responsexp;
HXDLIN( 151)					Float _hx_tmp5 = ::haxegon::Text_obj::input_responseyp;
HXDLIN( 151)					::haxegon::Text_obj::display(_hx_tmp4,_hx_tmp5,(::haxegon::Text_obj::input_response + HX_("_",5f,00,00,00)),::haxegon::Text_obj::input_responsecol);
            				}
            			}
            			else {
HXLINE( 154)				::haxegon::Text_obj::display(::haxegon::Text_obj::input_responsexp,::haxegon::Text_obj::input_responseyp,::haxegon::Text_obj::input_response,::haxegon::Text_obj::input_responsecol);
            			}
            		}
HXLINE( 158)		::haxegon::Text_obj::input_show--;
HXLINE( 159)		Bool _hx_tmp6 = (::haxegon::Text_obj::input_show < (int)0);
HXDLIN( 159)		if (_hx_tmp6) {
HXLINE( 159)			::haxegon::Text_obj::input_show = (int)0;
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,drawstringinput,(void))

Float Text_obj::width(::String t){
            	HX_STACK_FRAME("haxegon.Text","width",0x5f1aa073,"haxegon.Text.width","haxegon/Text.hx",162,0xb667cca2)
            	HX_STACK_ARG(t,"t")
HXLINE( 163)		Bool _hx_tmp = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 163)		if (_hx_tmp) {
HXLINE( 164)			::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->set_text(t);
HXLINE( 165)			return ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->get_textWidth();
            		}
            		else {
HXLINE( 166)			Bool _hx_tmp1 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 166)			if (_hx_tmp1) {
HXLINE( 169)				HX_VARI( ::String,currentline) = HX_("",00,00,00,00);
HXLINE( 170)				HX_VARI( Int,longestline) = (int)-1;
HXLINE( 171)				HX_VAR( Int,thislength);
HXLINE( 172)				HX_VARI( Int,i) = (int)0;
HXLINE( 173)				Bool _hx_tmp2 = ::haxegon::S_obj::isinstring(t,HX_("\n",0a,00,00,00));
HXDLIN( 173)				if (_hx_tmp2) {
HXLINE( 174)					while((i < t.length)){
HXLINE( 175)						::String _hx_tmp3 = t.substr(i,(int)1);
HXDLIN( 175)						if ((_hx_tmp3 == HX_("\n",0a,00,00,00))) {
HXLINE( 177)							Float _hx_tmp4 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(currentline,false);
HXDLIN( 177)							thislength = ::Math_obj::round(_hx_tmp4);
HXLINE( 178)							Bool _hx_tmp5 = (thislength > longestline);
HXDLIN( 178)							if (_hx_tmp5) {
HXLINE( 178)								longestline = thislength;
            							}
HXLINE( 179)							currentline = HX_("",00,00,00,00);
            						}
            						else {
HXLINE( 180)							::String _hx_tmp6 = t.substr(i,(int)1);
HXDLIN( 180)							hx::AddEq(currentline,_hx_tmp6);
            						}
HXLINE( 181)						++i;
            					}
HXLINE( 183)					Float _hx_tmp7 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(currentline,false);
HXDLIN( 183)					thislength = ::Math_obj::round(_hx_tmp7);
HXLINE( 184)					Bool _hx_tmp8 = (thislength > longestline);
HXDLIN( 184)					if (_hx_tmp8) {
HXLINE( 184)						longestline = thislength;
            					}
            				}
            				else {
HXLINE( 186)					Float _hx_tmp9 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(t,false);
HXDLIN( 186)					longestline = ::Math_obj::round(_hx_tmp9);
            				}
HXLINE( 188)				return longestline;
            			}
            		}
HXLINE( 190)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,width,return )

Float Text_obj::height(){
            	HX_STACK_FRAME("haxegon.Text","height",0x8e813cda,"haxegon.Text.height","haxegon/Text.hx",193,0xb667cca2)
HXLINE( 194)		Bool _hx_tmp = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 194)		if (_hx_tmp) {
HXLINE( 195)			HX_VARI( ::String,oldtext) = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->get_text();
HXLINE( 196)			::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->set_text(HX_("???",1f,05,30,00));
HXLINE( 197)			HX_VARI( Float,h) = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->get_textHeight();
HXLINE( 198)			::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->set_text(oldtext);
HXLINE( 199)			return h;
            		}
            		else {
HXLINE( 200)			Bool _hx_tmp1 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 200)			if (_hx_tmp1) {
HXLINE( 201)				::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->set_text(HX_("???",1f,05,30,00));
HXLINE( 202)				return (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->height * ::haxegon::Text_obj::currentsize);
            			}
            		}
HXLINE( 204)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,height,return )

Float Text_obj::t1;

Float Text_obj::t2;

Float Text_obj::t3;

Float Text_obj::cachealignx(Float x,Int c){
            	HX_STACK_FRAME("haxegon.Text","cachealignx",0xf2ce4802,"haxegon.Text.cachealignx","haxegon/Text.hx",211,0xb667cca2)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(c,"c")
HXLINE( 212)		if ((x <= (int)-5000)) {
HXLINE( 213)			::haxegon::Text_obj::t1 = (x - ::haxegon::Text_obj::CENTER);
HXLINE( 214)			::haxegon::Text_obj::t2 = (x - ::haxegon::Text_obj::LEFT);
HXLINE( 215)			::haxegon::Text_obj::t3 = (x - ::haxegon::Text_obj::RIGHT);
HXLINE( 216)			Bool _hx_tmp;
HXDLIN( 216)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 216)			if (_hx_tmp1) {
HXLINE( 216)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 216)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 216)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 216)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 216)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 216)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 216)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 216)				_hx_tmp = true;
            			}
HXDLIN( 216)			if (_hx_tmp) {
HXLINE( 217)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 217)				Int _hx_tmp7 = ::haxegon::Gfx_obj::screen_widthMid;
HXDLIN( 217)				Float _hx_tmp8 = ((Float)(::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->width * ::haxegon::Text_obj::currentsize) / (Float)(int)2);
HXDLIN( 217)				Int _hx_tmp9 = ::Math_obj::floor((_hx_tmp7 - _hx_tmp8));
HXDLIN( 217)				return (_hx_tmp6 + _hx_tmp9);
            			}
            			else {
HXLINE( 218)				Bool _hx_tmp10;
HXDLIN( 218)				Bool _hx_tmp11 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 218)				if (_hx_tmp11) {
HXLINE( 218)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 218)					Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 218)					if ((_hx_tmp12 < _hx_tmp13)) {
HXLINE( 218)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 218)						Float _hx_tmp15 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 218)						_hx_tmp10 = (_hx_tmp14 < _hx_tmp15);
            					}
            					else {
HXLINE( 218)						_hx_tmp10 = false;
            					}
            				}
            				else {
HXLINE( 218)					_hx_tmp10 = true;
            				}
HXDLIN( 218)				if (_hx_tmp10) {
HXLINE( 219)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 221)					Float _hx_tmp16 = ::haxegon::Text_obj::t3;
HXDLIN( 221)					Float _hx_tmp17 = (::haxegon::Gfx_obj::screen_width - (::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->width * ::haxegon::Text_obj::currentsize));
HXDLIN( 221)					Int _hx_tmp18 = ::Math_obj::floor(_hx_tmp17);
HXDLIN( 221)					return (_hx_tmp16 + _hx_tmp18);
            				}
            			}
            		}
HXLINE( 225)		return ::Math_obj::floor(x);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,cachealignx,return )

Float Text_obj::cachealigny(Float y,Int c){
            	HX_STACK_FRAME("haxegon.Text","cachealigny",0xf2ce4803,"haxegon.Text.cachealigny","haxegon/Text.hx",228,0xb667cca2)
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(c,"c")
HXLINE( 229)		if ((y <= (int)-5000)) {
HXLINE( 230)			::haxegon::Text_obj::t1 = (y - ::haxegon::Text_obj::CENTER);
HXLINE( 231)			::haxegon::Text_obj::t2 = (y - ::haxegon::Text_obj::TOP);
HXLINE( 232)			::haxegon::Text_obj::t3 = (y - ::haxegon::Text_obj::BOTTOM);
HXLINE( 233)			Bool _hx_tmp;
HXDLIN( 233)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 233)			if (_hx_tmp1) {
HXLINE( 233)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 233)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 233)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 233)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 233)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 233)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 233)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 233)				_hx_tmp = true;
            			}
HXDLIN( 233)			if (_hx_tmp) {
HXLINE( 234)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 234)				Int _hx_tmp7 = ::haxegon::Gfx_obj::screen_heightMid;
HXDLIN( 234)				Float _hx_tmp8 = ((Float)(::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->height * ::haxegon::Text_obj::currentsize) / (Float)(int)2);
HXDLIN( 234)				Int _hx_tmp9 = ::Math_obj::floor((_hx_tmp7 - _hx_tmp8));
HXDLIN( 234)				return (_hx_tmp6 + _hx_tmp9);
            			}
            			else {
HXLINE( 235)				Bool _hx_tmp10;
HXDLIN( 235)				Bool _hx_tmp11 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 235)				if (_hx_tmp11) {
HXLINE( 235)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 235)					Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 235)					if ((_hx_tmp12 < _hx_tmp13)) {
HXLINE( 235)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 235)						Float _hx_tmp15 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 235)						_hx_tmp10 = (_hx_tmp14 < _hx_tmp15);
            					}
            					else {
HXLINE( 235)						_hx_tmp10 = false;
            					}
            				}
            				else {
HXLINE( 235)					_hx_tmp10 = true;
            				}
HXDLIN( 235)				if (_hx_tmp10) {
HXLINE( 236)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 238)					Float _hx_tmp16 = ::haxegon::Text_obj::t3;
HXDLIN( 238)					Float _hx_tmp17 = (::haxegon::Gfx_obj::screen_height - (::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->height * ::haxegon::Text_obj::currentsize));
HXDLIN( 238)					Int _hx_tmp18 = ::Math_obj::floor(_hx_tmp17);
HXDLIN( 238)					return (_hx_tmp16 + _hx_tmp18);
            				}
            			}
            		}
HXLINE( 242)		return ::Math_obj::floor(y);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,cachealigny,return )

Float Text_obj::currentwidth(){
            	HX_STACK_FRAME("haxegon.Text","currentwidth",0x75351860,"haxegon.Text.currentwidth","haxegon/Text.hx",245,0xb667cca2)
HXLINE( 246)		Bool _hx_tmp = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 246)		if (_hx_tmp) {
HXLINE( 247)			return ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->get_textWidth();
            		}
            		else {
HXLINE( 248)			Bool _hx_tmp1 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 248)			if (_hx_tmp1) {
HXLINE( 249)				HX_VARI( ::String,text) = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->text;
HXLINE( 251)				HX_VARI( ::String,currentline) = HX_("",00,00,00,00);
HXLINE( 252)				HX_VARI( Int,longestline) = (int)-1;
HXLINE( 253)				HX_VAR( Int,thislength);
HXLINE( 254)				HX_VARI( Int,i) = (int)0;
HXLINE( 255)				Bool _hx_tmp2 = ::haxegon::S_obj::isinstring(text,HX_("\n",0a,00,00,00));
HXDLIN( 255)				if (_hx_tmp2) {
HXLINE( 256)					while((i < text.length)){
HXLINE( 257)						::String _hx_tmp3 = text.substr(i,(int)1);
HXDLIN( 257)						if ((_hx_tmp3 == HX_("\n",0a,00,00,00))) {
HXLINE( 259)							Float _hx_tmp4 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(currentline,false);
HXDLIN( 259)							thislength = ::Math_obj::round(_hx_tmp4);
HXLINE( 260)							Bool _hx_tmp5 = (thislength > longestline);
HXDLIN( 260)							if (_hx_tmp5) {
HXLINE( 260)								longestline = thislength;
            							}
HXLINE( 261)							currentline = HX_("",00,00,00,00);
            						}
            						else {
HXLINE( 262)							::String _hx_tmp6 = text.substr(i,(int)1);
HXDLIN( 262)							hx::AddEq(currentline,_hx_tmp6);
            						}
HXLINE( 263)						++i;
            					}
HXLINE( 265)					Float _hx_tmp7 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(currentline,false);
HXDLIN( 265)					thislength = ::Math_obj::round(_hx_tmp7);
HXLINE( 266)					Bool _hx_tmp8 = (thislength > longestline);
HXDLIN( 266)					if (_hx_tmp8) {
HXLINE( 266)						longestline = thislength;
            					}
            				}
            				else {
HXLINE( 268)					Float _hx_tmp9 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(text,false);
HXDLIN( 268)					longestline = ::Math_obj::round(_hx_tmp9);
            				}
HXLINE( 270)				return longestline;
            			}
            		}
HXLINE( 272)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,currentwidth,return )

Float Text_obj::alignx(Float x){
            	HX_STACK_FRAME("haxegon.Text","alignx",0xc9cfcb06,"haxegon.Text.alignx","haxegon/Text.hx",275,0xb667cca2)
            	HX_STACK_ARG(x,"x")
HXLINE( 276)		if ((x <= (int)-5000)) {
HXLINE( 277)			::haxegon::Text_obj::t1 = (x - ::haxegon::Text_obj::CENTER);
HXLINE( 278)			::haxegon::Text_obj::t2 = (x - ::haxegon::Text_obj::LEFT);
HXLINE( 279)			::haxegon::Text_obj::t3 = (x - ::haxegon::Text_obj::RIGHT);
HXLINE( 280)			Bool _hx_tmp;
HXDLIN( 280)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 280)			if (_hx_tmp1) {
HXLINE( 280)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 280)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 280)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 280)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 280)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 280)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 280)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 280)				_hx_tmp = true;
            			}
HXDLIN( 280)			if (_hx_tmp) {
HXLINE( 281)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 281)				Int _hx_tmp7 = ::haxegon::Gfx_obj::screen_widthMid;
HXDLIN( 281)				Float _hx_tmp8 = ::haxegon::Text_obj::currentwidth();
HXDLIN( 281)				Int _hx_tmp9 = ::Math_obj::floor((_hx_tmp7 - ((Float)_hx_tmp8 / (Float)(int)2)));
HXDLIN( 281)				return (_hx_tmp6 + _hx_tmp9);
            			}
            			else {
HXLINE( 282)				Bool _hx_tmp10;
HXDLIN( 282)				Bool _hx_tmp11 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 282)				if (_hx_tmp11) {
HXLINE( 282)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 282)					Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 282)					if ((_hx_tmp12 < _hx_tmp13)) {
HXLINE( 282)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 282)						Float _hx_tmp15 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 282)						_hx_tmp10 = (_hx_tmp14 < _hx_tmp15);
            					}
            					else {
HXLINE( 282)						_hx_tmp10 = false;
            					}
            				}
            				else {
HXLINE( 282)					_hx_tmp10 = true;
            				}
HXDLIN( 282)				if (_hx_tmp10) {
HXLINE( 283)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 285)					Float _hx_tmp16 = ::haxegon::Text_obj::t3;
HXDLIN( 285)					Int _hx_tmp17 = ::haxegon::Gfx_obj::screen_width;
HXDLIN( 285)					Float _hx_tmp18 = ::haxegon::Text_obj::currentwidth();
HXDLIN( 285)					Int _hx_tmp19 = ::Math_obj::floor((_hx_tmp17 - _hx_tmp18));
HXDLIN( 285)					return (_hx_tmp16 + _hx_tmp19);
            				}
            			}
            		}
HXLINE( 289)		return ::Math_obj::floor(x);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,alignx,return )

Float Text_obj::currentheight(){
            	HX_STACK_FRAME("haxegon.Text","currentheight",0xcf8fb44d,"haxegon.Text.currentheight","haxegon/Text.hx",292,0xb667cca2)
HXLINE( 293)		Bool _hx_tmp = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 293)		if (_hx_tmp) {
HXLINE( 294)			return ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->get_textHeight();
            		}
            		else {
HXLINE( 295)			Bool _hx_tmp1 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 295)			if (_hx_tmp1) {
HXLINE( 296)				Float _hx_tmp2 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->get_textHeight();
HXDLIN( 296)				return (_hx_tmp2 * ::haxegon::Text_obj::currentsize);
            			}
            		}
HXLINE( 298)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,currentheight,return )

Float Text_obj::aligny(Float y){
            	HX_STACK_FRAME("haxegon.Text","aligny",0xc9cfcb07,"haxegon.Text.aligny","haxegon/Text.hx",301,0xb667cca2)
            	HX_STACK_ARG(y,"y")
HXLINE( 302)		if ((y <= (int)-5000)) {
HXLINE( 303)			::haxegon::Text_obj::t1 = (y - ::haxegon::Text_obj::CENTER);
HXLINE( 304)			::haxegon::Text_obj::t2 = (y - ::haxegon::Text_obj::TOP);
HXLINE( 305)			::haxegon::Text_obj::t3 = (y - ::haxegon::Text_obj::BOTTOM);
HXLINE( 306)			Bool _hx_tmp;
HXDLIN( 306)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 306)			if (_hx_tmp1) {
HXLINE( 306)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 306)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 306)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 306)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 306)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 306)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 306)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 306)				_hx_tmp = true;
            			}
HXDLIN( 306)			if (_hx_tmp) {
HXLINE( 307)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 307)				Int _hx_tmp7 = ::haxegon::Gfx_obj::screen_heightMid;
HXDLIN( 307)				Float _hx_tmp8 = ::haxegon::Text_obj::currentheight();
HXDLIN( 307)				Int _hx_tmp9 = ::Math_obj::floor((_hx_tmp7 - ((Float)_hx_tmp8 / (Float)(int)2)));
HXDLIN( 307)				return (_hx_tmp6 + _hx_tmp9);
            			}
            			else {
HXLINE( 308)				Bool _hx_tmp10;
HXDLIN( 308)				Bool _hx_tmp11 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 308)				if (_hx_tmp11) {
HXLINE( 308)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 308)					Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 308)					if ((_hx_tmp12 < _hx_tmp13)) {
HXLINE( 308)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 308)						Float _hx_tmp15 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 308)						_hx_tmp10 = (_hx_tmp14 < _hx_tmp15);
            					}
            					else {
HXLINE( 308)						_hx_tmp10 = false;
            					}
            				}
            				else {
HXLINE( 308)					_hx_tmp10 = true;
            				}
HXDLIN( 308)				if (_hx_tmp10) {
HXLINE( 309)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 311)					Float _hx_tmp16 = ::haxegon::Text_obj::t3;
HXDLIN( 311)					Int _hx_tmp17 = ::haxegon::Gfx_obj::screen_height;
HXDLIN( 311)					Float _hx_tmp18 = ::haxegon::Text_obj::currentheight();
HXDLIN( 311)					Int _hx_tmp19 = ::Math_obj::floor((_hx_tmp17 - _hx_tmp18));
HXDLIN( 311)					return (_hx_tmp16 + _hx_tmp19);
            				}
            			}
            		}
HXLINE( 315)		return ::Math_obj::floor(y);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,aligny,return )

Float Text_obj::cachealigntextx(Int c,Float x){
            	HX_STACK_FRAME("haxegon.Text","cachealigntextx",0x67e31fb5,"haxegon.Text.cachealigntextx","haxegon/Text.hx",318,0xb667cca2)
            	HX_STACK_ARG(c,"c")
            	HX_STACK_ARG(x,"x")
HXLINE( 319)		if ((x <= (int)-5000)) {
HXLINE( 320)			::haxegon::Text_obj::t1 = (x - ::haxegon::Text_obj::CENTER);
HXLINE( 321)			::haxegon::Text_obj::t2 = (x - ::haxegon::Text_obj::LEFT);
HXLINE( 322)			::haxegon::Text_obj::t3 = (x - ::haxegon::Text_obj::RIGHT);
HXLINE( 323)			Bool _hx_tmp;
HXDLIN( 323)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 323)			if (_hx_tmp1) {
HXLINE( 323)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 323)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 323)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 323)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 323)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 323)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 323)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 323)				_hx_tmp = true;
            			}
HXDLIN( 323)			if (_hx_tmp) {
HXLINE( 324)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 324)				Float _hx_tmp7 = ((Float)(::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->width * ::haxegon::Text_obj::currentsize) / (Float)(int)2);
HXDLIN( 324)				Int _hx_tmp8 = ::Math_obj::floor(_hx_tmp7);
HXDLIN( 324)				return (_hx_tmp6 + _hx_tmp8);
            			}
            			else {
HXLINE( 325)				Bool _hx_tmp9;
HXDLIN( 325)				Bool _hx_tmp10 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 325)				if (_hx_tmp10) {
HXLINE( 325)					Float _hx_tmp11 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 325)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 325)					if ((_hx_tmp11 < _hx_tmp12)) {
HXLINE( 325)						Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 325)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 325)						_hx_tmp9 = (_hx_tmp13 < _hx_tmp14);
            					}
            					else {
HXLINE( 325)						_hx_tmp9 = false;
            					}
            				}
            				else {
HXLINE( 325)					_hx_tmp9 = true;
            				}
HXDLIN( 325)				if (_hx_tmp9) {
HXLINE( 326)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 328)					return (::haxegon::Text_obj::t3 + (::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->width * ::haxegon::Text_obj::currentsize));
            				}
            			}
            		}
HXLINE( 332)		return x;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,cachealigntextx,return )

Float Text_obj::cachealigntexty(Int c,Float y){
            	HX_STACK_FRAME("haxegon.Text","cachealigntexty",0x67e31fb6,"haxegon.Text.cachealigntexty","haxegon/Text.hx",335,0xb667cca2)
            	HX_STACK_ARG(c,"c")
            	HX_STACK_ARG(y,"y")
HXLINE( 336)		if ((y <= (int)-5000)) {
HXLINE( 337)			::haxegon::Text_obj::t1 = (y - ::haxegon::Text_obj::CENTER);
HXLINE( 338)			::haxegon::Text_obj::t2 = (y - ::haxegon::Text_obj::TOP);
HXLINE( 339)			::haxegon::Text_obj::t3 = (y - ::haxegon::Text_obj::BOTTOM);
HXLINE( 340)			Bool _hx_tmp;
HXDLIN( 340)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 340)			if (_hx_tmp1) {
HXLINE( 340)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 340)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 340)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 340)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 340)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 340)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 340)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 340)				_hx_tmp = true;
            			}
HXDLIN( 340)			if (_hx_tmp) {
HXLINE( 341)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 341)				Float _hx_tmp7 = ((Float)(::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->height * ::haxegon::Text_obj::currentsize) / (Float)(int)2);
HXDLIN( 341)				Int _hx_tmp8 = ::Math_obj::floor(_hx_tmp7);
HXDLIN( 341)				return (_hx_tmp6 + _hx_tmp8);
            			}
            			else {
HXLINE( 342)				Bool _hx_tmp9;
HXDLIN( 342)				Bool _hx_tmp10 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 342)				if (_hx_tmp10) {
HXLINE( 342)					Float _hx_tmp11 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 342)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 342)					if ((_hx_tmp11 < _hx_tmp12)) {
HXLINE( 342)						Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 342)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 342)						_hx_tmp9 = (_hx_tmp13 < _hx_tmp14);
            					}
            					else {
HXLINE( 342)						_hx_tmp9 = false;
            					}
            				}
            				else {
HXLINE( 342)					_hx_tmp9 = true;
            				}
HXDLIN( 342)				if (_hx_tmp9) {
HXLINE( 343)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 345)					return (::haxegon::Text_obj::t3 + (::haxegon::Text_obj::cachedtext->__get(c).StaticCast<  ::openfl::display::BitmapData >()->height * ::haxegon::Text_obj::currentsize));
            				}
            			}
            		}
HXLINE( 348)		return y;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,cachealigntexty,return )

Float Text_obj::aligntextx(::String t,Float x){
            	HX_STACK_FRAME("haxegon.Text","aligntextx",0x1efc74b9,"haxegon.Text.aligntextx","haxegon/Text.hx",351,0xb667cca2)
            	HX_STACK_ARG(t,"t")
            	HX_STACK_ARG(x,"x")
HXLINE( 352)		if ((x <= (int)-5000)) {
HXLINE( 353)			::haxegon::Text_obj::t1 = (x - ::haxegon::Text_obj::CENTER);
HXLINE( 354)			::haxegon::Text_obj::t2 = (x - ::haxegon::Text_obj::LEFT);
HXLINE( 355)			::haxegon::Text_obj::t3 = (x - ::haxegon::Text_obj::RIGHT);
HXLINE( 356)			Bool _hx_tmp;
HXDLIN( 356)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 356)			if (_hx_tmp1) {
HXLINE( 356)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 356)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 356)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 356)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 356)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 356)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 356)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 356)				_hx_tmp = true;
            			}
HXDLIN( 356)			if (_hx_tmp) {
HXLINE( 357)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 357)				Float _hx_tmp7 = ::haxegon::Text_obj::width(t);
HXDLIN( 357)				Int _hx_tmp8 = ::Math_obj::floor(((Float)_hx_tmp7 / (Float)(int)2));
HXDLIN( 357)				return (_hx_tmp6 + _hx_tmp8);
            			}
            			else {
HXLINE( 358)				Bool _hx_tmp9;
HXDLIN( 358)				Bool _hx_tmp10 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 358)				if (_hx_tmp10) {
HXLINE( 358)					Float _hx_tmp11 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 358)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 358)					if ((_hx_tmp11 < _hx_tmp12)) {
HXLINE( 358)						Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 358)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 358)						_hx_tmp9 = (_hx_tmp13 < _hx_tmp14);
            					}
            					else {
HXLINE( 358)						_hx_tmp9 = false;
            					}
            				}
            				else {
HXLINE( 358)					_hx_tmp9 = true;
            				}
HXDLIN( 358)				if (_hx_tmp9) {
HXLINE( 359)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 361)					Float _hx_tmp15 = ::haxegon::Text_obj::t3;
HXDLIN( 361)					Float _hx_tmp16 = ::haxegon::Text_obj::width(t);
HXDLIN( 361)					return (_hx_tmp15 + _hx_tmp16);
            				}
            			}
            		}
HXLINE( 365)		return x;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,aligntextx,return )

Float Text_obj::aligntexty(Float y){
            	HX_STACK_FRAME("haxegon.Text","aligntexty",0x1efc74ba,"haxegon.Text.aligntexty","haxegon/Text.hx",368,0xb667cca2)
            	HX_STACK_ARG(y,"y")
HXLINE( 369)		if ((y <= (int)-5000)) {
HXLINE( 370)			::haxegon::Text_obj::t1 = (y - ::haxegon::Text_obj::CENTER);
HXLINE( 371)			::haxegon::Text_obj::t2 = (y - ::haxegon::Text_obj::TOP);
HXLINE( 372)			::haxegon::Text_obj::t3 = (y - ::haxegon::Text_obj::BOTTOM);
HXLINE( 373)			Bool _hx_tmp;
HXDLIN( 373)			Bool _hx_tmp1 = (::haxegon::Text_obj::t1 != (int)0);
HXDLIN( 373)			if (_hx_tmp1) {
HXLINE( 373)				Float _hx_tmp2 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 373)				Float _hx_tmp3 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 373)				if ((_hx_tmp2 < _hx_tmp3)) {
HXLINE( 373)					Float _hx_tmp4 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 373)					Float _hx_tmp5 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 373)					_hx_tmp = (_hx_tmp4 < _hx_tmp5);
            				}
            				else {
HXLINE( 373)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 373)				_hx_tmp = true;
            			}
HXDLIN( 373)			if (_hx_tmp) {
HXLINE( 374)				Float _hx_tmp6 = ::haxegon::Text_obj::t1;
HXDLIN( 374)				Float _hx_tmp7 = ::haxegon::Text_obj::height();
HXDLIN( 374)				Int _hx_tmp8 = ::Math_obj::floor(((Float)_hx_tmp7 / (Float)(int)2));
HXDLIN( 374)				return (_hx_tmp6 + _hx_tmp8);
            			}
            			else {
HXLINE( 375)				Bool _hx_tmp9;
HXDLIN( 375)				Bool _hx_tmp10 = (::haxegon::Text_obj::t2 != (int)0);
HXDLIN( 375)				if (_hx_tmp10) {
HXLINE( 375)					Float _hx_tmp11 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 375)					Float _hx_tmp12 = ::Math_obj::abs(::haxegon::Text_obj::t1);
HXDLIN( 375)					if ((_hx_tmp11 < _hx_tmp12)) {
HXLINE( 375)						Float _hx_tmp13 = ::Math_obj::abs(::haxegon::Text_obj::t2);
HXDLIN( 375)						Float _hx_tmp14 = ::Math_obj::abs(::haxegon::Text_obj::t3);
HXDLIN( 375)						_hx_tmp9 = (_hx_tmp13 < _hx_tmp14);
            					}
            					else {
HXLINE( 375)						_hx_tmp9 = false;
            					}
            				}
            				else {
HXLINE( 375)					_hx_tmp9 = true;
            				}
HXDLIN( 375)				if (_hx_tmp9) {
HXLINE( 376)					return ::haxegon::Text_obj::t2;
            				}
            				else {
HXLINE( 378)					Float _hx_tmp15 = ::haxegon::Text_obj::t3;
HXDLIN( 378)					Float _hx_tmp16 = ::haxegon::Text_obj::height();
HXDLIN( 378)					return (_hx_tmp15 + _hx_tmp16);
            				}
            			}
            		}
HXLINE( 381)		return y;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,aligntexty,return )

void Text_obj::reset_text_input(){
            	HX_STACK_FRAME("haxegon.Text","reset_text_input",0x0e8ce21b,"haxegon.Text.reset_text_input","haxegon/Text.hx",385,0xb667cca2)
HXLINE( 385)		::haxegon::Input_obj::keybuffer = HX_("",00,00,00,00);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,reset_text_input,(void))

 ::haxe::ds::StringMap Text_obj::cachedtextindex;

::Array< ::Dynamic> Text_obj::cachedtext;

Int Text_obj::cacheindex;

::String Text_obj::cachelabel;

void Text_obj::cleartextcache(){
            	HX_STACK_FRAME("haxegon.Text","cleartextcache",0xf0b70f3b,"haxegon.Text.cleartextcache","haxegon/Text.hx",393,0xb667cca2)
HXLINE( 394)		::haxegon::Text_obj::cachedtextindex =  ::haxe::ds::StringMap_obj::__new();
HXLINE( 395)		{
HXLINE( 395)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 395)			HX_VARI( Int,_g) = ::haxegon::Text_obj::cachedtext->length;
HXDLIN( 395)			while((_g1 < _g)){
HXLINE( 395)				HX_VARI( Int,i) = _g1++;
HXLINE( 396)				::haxegon::Text_obj::cachedtext->__get(i).StaticCast<  ::openfl::display::BitmapData >()->dispose();
            			}
            		}
HXLINE( 398)		::haxegon::Text_obj::cachedtext = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 400)		::haxegon::Text_obj::align(::haxegon::Text_obj::LEFT);
HXLINE( 401)		::haxegon::Text_obj::rotation((int)0,null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Text_obj,cleartextcache,(void))

void Text_obj::display(Float x,Float y,::String text,hx::Null< Int >  __o_col){
Int col = __o_col.Default(16777215);
            	HX_STACK_FRAME("haxegon.Text","display",0xdda349ef,"haxegon.Text.display","haxegon/Text.hx",404,0xb667cca2)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(text,"text")
            	HX_STACK_ARG(col,"col")
HXLINE( 405)		if (!(::haxegon::Gfx_obj::clearscreeneachframe)) {
HXLINE( 405)			Bool _hx_tmp;
HXDLIN( 405)			if (::haxegon::Gfx_obj::skiprender) {
HXLINE( 405)				_hx_tmp = ::haxegon::Gfx_obj::drawingtoscreen;
            			}
            			else {
HXLINE( 405)				_hx_tmp = false;
            			}
HXDLIN( 405)			if (_hx_tmp) {
HXLINE( 405)				return;
            			}
            		}
HXLINE( 406)		if ((text == HX_("",00,00,00,00))) {
HXLINE( 406)			return;
            		}
HXLINE( 407)		Bool _hx_tmp1 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 407)		if (_hx_tmp1) {
HXLINE( 408)			::String _hx_tmp2 = ((text + HX_("_",5f,00,00,00)) + ::haxegon::Text_obj::currentfont);
HXDLIN( 408)			::String _hx_tmp3 = ::Std_obj::string(col);
HXDLIN( 408)			::haxegon::Text_obj::cachelabel = (_hx_tmp2 + _hx_tmp3);
HXLINE( 409)			Bool _hx_tmp4 = !(::haxegon::Text_obj::cachedtextindex->exists(::haxegon::Text_obj::cachelabel));
HXDLIN( 409)			if (_hx_tmp4) {
HXLINE( 411)				HX_VARI( Int,numlines) = (int)1;
HXLINE( 412)				HX_VARI( ::String,currentline) = HX_("",00,00,00,00);
HXLINE( 413)				HX_VARI( Int,longestline) = (int)-1;
HXLINE( 414)				HX_VAR( Int,thislength);
HXLINE( 415)				HX_VARI( Int,i) = (int)0;
HXLINE( 416)				Bool _hx_tmp5 = ::haxegon::S_obj::isinstring(text,HX_("\n",0a,00,00,00));
HXDLIN( 416)				if (_hx_tmp5) {
HXLINE( 417)					while((i < text.length)){
HXLINE( 418)						::String _hx_tmp6 = text.substr(i,(int)1);
HXDLIN( 418)						if ((_hx_tmp6 == HX_("\n",0a,00,00,00))) {
HXLINE( 419)							++numlines;
HXLINE( 420)							Float _hx_tmp7 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(currentline,false);
HXDLIN( 420)							thislength = ::Math_obj::round(_hx_tmp7);
HXLINE( 421)							Bool _hx_tmp8 = (thislength > longestline);
HXDLIN( 421)							if (_hx_tmp8) {
HXLINE( 421)								longestline = thislength;
            							}
HXLINE( 422)							currentline = HX_("",00,00,00,00);
            						}
            						else {
HXLINE( 423)							::String _hx_tmp9 = text.substr(i,(int)1);
HXDLIN( 423)							hx::AddEq(currentline,_hx_tmp9);
            						}
HXLINE( 424)						++i;
            					}
HXLINE( 426)					Float _hx_tmp10 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(currentline,false);
HXDLIN( 426)					thislength = ::Math_obj::round(_hx_tmp10);
HXLINE( 427)					Bool _hx_tmp11 = (thislength > longestline);
HXDLIN( 427)					if (_hx_tmp11) {
HXLINE( 427)						longestline = thislength;
            					}
            				}
            				else {
HXLINE( 429)					Float _hx_tmp12 = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->getStringWidth(text,false);
HXDLIN( 429)					longestline = ::Math_obj::round(_hx_tmp12);
            				}
HXLINE( 432)				::haxegon::Text_obj::cacheindex = ::haxegon::Text_obj::cachedtext->length;
HXLINE( 433)				{
HXLINE( 433)					Int value = ::haxegon::Text_obj::cacheindex;
HXDLIN( 433)					::haxegon::Text_obj::cachedtextindex->set(::haxegon::Text_obj::cachelabel,value);
            				}
HXLINE( 434)				Int _hx_tmp13 = ::Math_obj::round(::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->height);
HXDLIN( 434)				::haxegon::Text_obj::cachedtext->push( ::openfl::display::BitmapData_obj::__new(longestline,(_hx_tmp13 * numlines),true,(int)0));
HXLINE( 436)				::haxegon::Text_obj::drawto = ::haxegon::Text_obj::cachedtext->__get(::haxegon::Text_obj::cacheindex).StaticCast<  ::openfl::display::BitmapData >();
HXLINE( 438)				::haxegon::Text_obj::cache_bitmap_text(text,col);
HXLINE( 439)				::haxegon::Text_obj::drawto = ::haxegon::Gfx_obj::drawto;
            			}
HXLINE( 442)			::haxegon::Text_obj::cacheindex = ::haxegon::Text_obj::cachedtextindex->get(::haxegon::Text_obj::cachelabel);
HXLINE( 443)			::haxegon::Text_obj::display_bitmap(x,y,::haxegon::Text_obj::cacheindex,::haxegon::Text_obj::currentsize);
            		}
            		else {
HXLINE( 444)			Bool _hx_tmp14 = (::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 444)			if (_hx_tmp14) {
HXLINE( 445)				::haxegon::Text_obj::display_ttf(x,y,text,col);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Text_obj,display,(void))

void Text_obj::cache_bitmap_text(::String text,Int col){
            	HX_STACK_FRAME("haxegon.Text","cache_bitmap_text",0x5a55b36d,"haxegon.Text.cache_bitmap_text","haxegon/Text.hx",449,0xb667cca2)
            	HX_STACK_ARG(text,"text")
            	HX_STACK_ARG(col,"col")
HXLINE( 450)		::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->set_useTextColor(true);
HXLINE( 451)		 ::haxegon::bitmapFont::BitmapTextField _hx_tmp = ::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap;
HXDLIN( 451)		_hx_tmp->set_textColor(((int)-16777216 + col));
HXLINE( 452)		::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap->set_text(text);
HXLINE( 453)		::haxegon::Text_obj::drawto->draw(::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_bitmap,null(),null(),null(),null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,cache_bitmap_text,(void))

void Text_obj::display_bitmap(Float x,Float y,Int text,Float size){
            	HX_STACK_FRAME("haxegon.Text","display_bitmap",0x94e3837f,"haxegon.Text.display_bitmap","haxegon/Text.hx",456,0xb667cca2)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(text,"text")
            	HX_STACK_ARG(size,"size")
HXLINE( 457)		x = ::haxegon::Text_obj::cachealignx(x,text);
HXDLIN( 457)		y = ::haxegon::Text_obj::cachealigny(y,text);
HXLINE( 458)		Float _hx_tmp = ::haxegon::Text_obj::cachealigntextx(text,::haxegon::Text_obj::textalign);
HXDLIN( 458)		hx::SubEq(x,_hx_tmp);
HXLINE( 460)		::haxegon::Text_obj::fontmatrix->identity();
HXLINE( 461)		if ((size != (int)1)) {
HXLINE( 462)			::haxegon::Text_obj::fontmatrix->scale(size,size);
            		}
HXLINE( 464)		Bool _hx_tmp1 = (::haxegon::Text_obj::textrotate != (int)0);
HXDLIN( 464)		if (_hx_tmp1) {
HXLINE( 465)			Bool _hx_tmp2 = (::haxegon::Text_obj::textrotatexpivot != ((Float)0.0));
HXDLIN( 465)			if (_hx_tmp2) {
HXLINE( 465)				::haxegon::Text_obj::tempxpivot = ::haxegon::Text_obj::cachealigntextx(text,::haxegon::Text_obj::textrotatexpivot);
            			}
HXLINE( 466)			Bool _hx_tmp3 = (::haxegon::Text_obj::textrotateypivot != ((Float)0.0));
HXDLIN( 466)			if (_hx_tmp3) {
HXLINE( 466)				::haxegon::Text_obj::tempypivot = ::haxegon::Text_obj::cachealigntexty(text,::haxegon::Text_obj::textrotatexpivot);
            			}
HXLINE( 467)			::haxegon::Text_obj::fontmatrix->translate(-(::haxegon::Text_obj::tempxpivot),-(::haxegon::Text_obj::tempypivot));
HXLINE( 468)			Float _hx_tmp4 = ((Float)(::haxegon::Text_obj::textrotate * ((Float)3.1415)) / (Float)(int)180);
HXDLIN( 468)			::haxegon::Text_obj::fontmatrix->rotate(_hx_tmp4);
HXLINE( 469)			::haxegon::Text_obj::fontmatrix->translate(::haxegon::Text_obj::tempxpivot,::haxegon::Text_obj::tempypivot);
            		}
HXLINE( 472)		Int _hx_tmp5 = ::Math_obj::floor(x);
HXDLIN( 472)		Int _hx_tmp6 = ::Math_obj::floor(y);
HXDLIN( 472)		::haxegon::Text_obj::fontmatrix->translate(_hx_tmp5,_hx_tmp6);
HXLINE( 473)		 ::openfl::display::BitmapData _hx_tmp7 = ::haxegon::Text_obj::cachedtext->__get(text).StaticCast<  ::openfl::display::BitmapData >();
HXDLIN( 473)		::haxegon::Text_obj::drawto->draw(_hx_tmp7,::haxegon::Text_obj::fontmatrix,null(),null(),null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Text_obj,display_bitmap,(void))

void Text_obj::display_ttf(Float x,Float y,::String text,hx::Null< Int >  __o_col){
Int col = __o_col.Default(16777215);
            	HX_STACK_FRAME("haxegon.Text","display_ttf",0x07641d56,"haxegon.Text.display_ttf","haxegon/Text.hx",476,0xb667cca2)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(text,"text")
            	HX_STACK_ARG(col,"col")
HXLINE( 477)		if (!(::haxegon::Gfx_obj::clearscreeneachframe)) {
HXLINE( 477)			Bool _hx_tmp;
HXDLIN( 477)			if (::haxegon::Gfx_obj::skiprender) {
HXLINE( 477)				_hx_tmp = ::haxegon::Gfx_obj::drawingtoscreen;
            			}
            			else {
HXLINE( 477)				_hx_tmp = false;
            			}
HXDLIN( 477)			if (_hx_tmp) {
HXLINE( 477)				return;
            			}
            		}
HXLINE( 478)		Bool _hx_tmp1 = hx::IsNull( text );
HXDLIN( 478)		if (_hx_tmp1) {
HXLINE( 479)			text = HX_("",00,00,00,00);
            		}
HXLINE( 482)		::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->set_textColor(col);
HXLINE( 483)		::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf->set_text(text);
HXLINE( 485)		x = ::haxegon::Text_obj::alignx(x);
HXDLIN( 485)		y = ::haxegon::Text_obj::aligny(y);
HXLINE( 486)		Float _hx_tmp2 = ::haxegon::Text_obj::aligntextx(text,::haxegon::Text_obj::textalign);
HXDLIN( 486)		hx::SubEq(x,_hx_tmp2);
HXLINE( 488)		::haxegon::Text_obj::fontmatrix->identity();
HXLINE( 490)		Bool _hx_tmp3 = (::haxegon::Text_obj::textrotate != (int)0);
HXDLIN( 490)		if (_hx_tmp3) {
HXLINE( 491)			Bool _hx_tmp4 = (::haxegon::Text_obj::textrotatexpivot != ((Float)0.0));
HXDLIN( 491)			if (_hx_tmp4) {
HXLINE( 491)				::haxegon::Text_obj::tempxpivot = ::haxegon::Text_obj::aligntextx(text,::haxegon::Text_obj::textrotatexpivot);
            			}
HXLINE( 492)			Bool _hx_tmp5 = (::haxegon::Text_obj::textrotateypivot != ((Float)0.0));
HXDLIN( 492)			if (_hx_tmp5) {
HXLINE( 492)				::haxegon::Text_obj::tempypivot = ::haxegon::Text_obj::aligntexty(::haxegon::Text_obj::textrotatexpivot);
            			}
HXLINE( 493)			::haxegon::Text_obj::fontmatrix->translate(-(::haxegon::Text_obj::tempxpivot),-(::haxegon::Text_obj::tempypivot));
HXLINE( 494)			Float _hx_tmp6 = ((Float)(::haxegon::Text_obj::textrotate * ((Float)3.1415)) / (Float)(int)180);
HXDLIN( 494)			::haxegon::Text_obj::fontmatrix->rotate(_hx_tmp6);
HXLINE( 495)			::haxegon::Text_obj::fontmatrix->translate(::haxegon::Text_obj::tempxpivot,::haxegon::Text_obj::tempypivot);
            		}
HXLINE( 498)		::haxegon::Text_obj::fontmatrix->translate(x,y);
HXLINE( 499)		::haxegon::Text_obj::drawto->draw(::haxegon::Text_obj::typeface->__get(::haxegon::Text_obj::currentindex).StaticCast<  ::haxegon::util::Fontclass >()->tf_ttf,::haxegon::Text_obj::fontmatrix,null(),null(),null(),null());
HXLINE( 500)		::haxegon::Text_obj::fontmatrix->identity();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Text_obj,display_ttf,(void))

void Text_obj::createtypeface(::String t){
            	HX_STACK_FRAME("haxegon.Text","createtypeface",0xcbe02f46,"haxegon.Text.createtypeface","haxegon/Text.hx",506,0xb667cca2)
            	HX_STACK_ARG(t,"t")
HXLINE( 506)		Bool _hx_tmp = (::haxegon::Text_obj::fontfile->__get(( (Int)(::haxegon::Text_obj::fontfileindex->get(t)) )).StaticCast<  ::haxegon::util::Fontfile >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 506)		if (_hx_tmp) {
HXLINE( 507)			Bool _hx_tmp1 = !(::haxegon::Text_obj::typefaceindex->exists((t + HX_("_1",f2,52,00,00))));
HXDLIN( 507)			if (_hx_tmp1) {
HXLINE( 508)				::haxegon::Text_obj::addtypeface(t,(int)1);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,createtypeface,(void))

void Text_obj::setfont(::String t,hx::Null< Float >  __o_s){
Float s = __o_s.Default(1);
            	HX_STACK_FRAME("haxegon.Text","setfont",0x40c4921e,"haxegon.Text.setfont","haxegon/Text.hx",513,0xb667cca2)
            	HX_STACK_ARG(t,"t")
            	HX_STACK_ARG(s,"s")
HXLINE( 514)		Bool _hx_tmp = !(::haxegon::Text_obj::fontfileindex->exists(t));
HXDLIN( 514)		if (_hx_tmp) {
HXLINE( 515)			::haxegon::Text_obj::addfont(t,s);
            		}
HXLINE( 518)		if ((t != ::haxegon::Text_obj::currentfont)) {
HXLINE( 519)			::haxegon::Text_obj::currentfont = t;
HXLINE( 520)			if ((s != (int)-1)) {
HXLINE( 521)				Bool _hx_tmp1 = (::haxegon::Text_obj::fontfile->__get(( (Int)(::haxegon::Text_obj::fontfileindex->get(t)) )).StaticCast<  ::haxegon::util::Fontfile >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 521)				if (_hx_tmp1) {
HXLINE( 522)					Bool _hx_tmp2 = ::haxegon::Text_obj::typefaceindex->exists((::haxegon::Text_obj::currentfont + HX_("_1",f2,52,00,00)));
HXDLIN( 522)					if (_hx_tmp2) {
HXLINE( 523)						::haxegon::Text_obj::currentindex = ::haxegon::Text_obj::typefaceindex->get((::haxegon::Text_obj::currentfont + HX_("_1",f2,52,00,00)));
            					}
            					else {
HXLINE( 525)						::haxegon::Text_obj::addtypeface(::haxegon::Text_obj::currentfont,(int)1);
HXLINE( 526)						::haxegon::Text_obj::currentindex = ::haxegon::Text_obj::typefaceindex->get((::haxegon::Text_obj::currentfont + HX_("_1",f2,52,00,00)));
            					}
            				}
            				else {
HXLINE( 528)					Bool _hx_tmp3 = (::haxegon::Text_obj::fontfile->__get(( (Int)(::haxegon::Text_obj::fontfileindex->get(t)) )).StaticCast<  ::haxegon::util::Fontfile >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 528)					if (_hx_tmp3) {
HXLINE( 529)						::String _hx_tmp4 = (::haxegon::Text_obj::currentfont + HX_("_",5f,00,00,00));
HXDLIN( 529)						::String _hx_tmp5 = ::Std_obj::string(::haxegon::Text_obj::currentsize);
HXDLIN( 529)						Bool _hx_tmp6 = ::haxegon::Text_obj::typefaceindex->exists((_hx_tmp4 + _hx_tmp5));
HXDLIN( 529)						if (_hx_tmp6) {
HXLINE( 530)							::String _hx_tmp7 = (::haxegon::Text_obj::currentfont + HX_("_",5f,00,00,00));
HXDLIN( 530)							::String _hx_tmp8 = ::Std_obj::string(::haxegon::Text_obj::currentsize);
HXDLIN( 530)							 ::Dynamic _hx_tmp9 = ::haxegon::Text_obj::typefaceindex->get((_hx_tmp7 + _hx_tmp8));
HXDLIN( 530)							::haxegon::Text_obj::currentindex = _hx_tmp9;
            						}
            						else {
HXLINE( 532)							::haxegon::Text_obj::addtypeface(::haxegon::Text_obj::currentfont,::haxegon::Text_obj::currentsize);
HXLINE( 533)							::String _hx_tmp10 = (::haxegon::Text_obj::currentfont + HX_("_",5f,00,00,00));
HXDLIN( 533)							::String _hx_tmp11 = ::Std_obj::string(::haxegon::Text_obj::currentsize);
HXDLIN( 533)							 ::Dynamic _hx_tmp12 = ::haxegon::Text_obj::typefaceindex->get((_hx_tmp10 + _hx_tmp11));
HXDLIN( 533)							::haxegon::Text_obj::currentindex = _hx_tmp12;
            						}
            					}
            				}
            			}
            		}
HXLINE( 539)		::haxegon::Text_obj::change_size(s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,setfont,(void))

void Text_obj::change_size(Float t){
            	HX_STACK_FRAME("haxegon.Text","change_size",0x5d23ef5d,"haxegon.Text.change_size","haxegon/Text.hx",543,0xb667cca2)
            	HX_STACK_ARG(t,"t")
HXLINE( 543)		Bool _hx_tmp = (t != ::haxegon::Text_obj::currentsize);
HXDLIN( 543)		if (_hx_tmp) {
HXLINE( 544)			::haxegon::Text_obj::currentsize = t;
HXLINE( 545)			if ((::haxegon::Text_obj::currentfont != HX_("null",87,9e,0e,49))) {
HXLINE( 546)				Bool _hx_tmp1 = (::haxegon::Text_obj::fontfile->__get(( (Int)(::haxegon::Text_obj::fontfileindex->get(::haxegon::Text_obj::currentfont)) )).StaticCast<  ::haxegon::util::Fontfile >()->type == HX_("bitmap",ef,0f,0c,f1));
HXDLIN( 546)				if (_hx_tmp1) {
HXLINE( 547)					Bool _hx_tmp2 = ::haxegon::Text_obj::typefaceindex->exists((::haxegon::Text_obj::currentfont + HX_("_1",f2,52,00,00)));
HXDLIN( 547)					if (_hx_tmp2) {
HXLINE( 548)						::haxegon::Text_obj::currentindex = ::haxegon::Text_obj::typefaceindex->get((::haxegon::Text_obj::currentfont + HX_("_1",f2,52,00,00)));
            					}
            					else {
HXLINE( 550)						::haxegon::Text_obj::addtypeface(::haxegon::Text_obj::currentfont,(int)1);
HXLINE( 551)						::haxegon::Text_obj::currentindex = ::haxegon::Text_obj::typefaceindex->get((::haxegon::Text_obj::currentfont + HX_("_1",f2,52,00,00)));
            					}
            				}
            				else {
HXLINE( 553)					Bool _hx_tmp3 = (::haxegon::Text_obj::fontfile->__get(( (Int)(::haxegon::Text_obj::fontfileindex->get(::haxegon::Text_obj::currentfont)) )).StaticCast<  ::haxegon::util::Fontfile >()->type == HX_("ttf",e6,6a,58,00));
HXDLIN( 553)					if (_hx_tmp3) {
HXLINE( 554)						::String _hx_tmp4 = (::haxegon::Text_obj::currentfont + HX_("_",5f,00,00,00));
HXDLIN( 554)						::String _hx_tmp5 = ::Std_obj::string(::haxegon::Text_obj::currentsize);
HXDLIN( 554)						Bool _hx_tmp6 = ::haxegon::Text_obj::typefaceindex->exists((_hx_tmp4 + _hx_tmp5));
HXDLIN( 554)						if (_hx_tmp6) {
HXLINE( 555)							::String _hx_tmp7 = (::haxegon::Text_obj::currentfont + HX_("_",5f,00,00,00));
HXDLIN( 555)							::String _hx_tmp8 = ::Std_obj::string(::haxegon::Text_obj::currentsize);
HXDLIN( 555)							 ::Dynamic _hx_tmp9 = ::haxegon::Text_obj::typefaceindex->get((_hx_tmp7 + _hx_tmp8));
HXDLIN( 555)							::haxegon::Text_obj::currentindex = _hx_tmp9;
            						}
            						else {
HXLINE( 557)							::haxegon::Text_obj::addtypeface(::haxegon::Text_obj::currentfont,::haxegon::Text_obj::currentsize);
HXLINE( 558)							::String _hx_tmp10 = (::haxegon::Text_obj::currentfont + HX_("_",5f,00,00,00));
HXDLIN( 558)							::String _hx_tmp11 = ::Std_obj::string(::haxegon::Text_obj::currentsize);
HXDLIN( 558)							 ::Dynamic _hx_tmp12 = ::haxegon::Text_obj::typefaceindex->get((_hx_tmp10 + _hx_tmp11));
HXDLIN( 558)							::haxegon::Text_obj::currentindex = _hx_tmp12;
            						}
            					}
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,change_size,(void))

void Text_obj::addfont(::String t,hx::Null< Float >  __o_defaultsize){
Float defaultsize = __o_defaultsize.Default(1);
            	HX_STACK_FRAME("haxegon.Text","addfont",0xb77d941d,"haxegon.Text.addfont","haxegon/Text.hx",565,0xb667cca2)
            	HX_STACK_ARG(t,"t")
            	HX_STACK_ARG(defaultsize,"defaultsize")
HXLINE( 566)		::haxegon::Text_obj::fontfile->push( ::haxegon::util::Fontfile_obj::__new(t));
HXLINE( 567)		{
HXLINE( 567)			Int value = (::haxegon::Text_obj::fontfile->length - (int)1);
HXDLIN( 567)			::haxegon::Text_obj::fontfileindex->set(t,value);
            		}
HXLINE( 568)		::haxegon::Text_obj::currentfont = t;
HXLINE( 570)		::haxegon::Text_obj::change_size(defaultsize);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,addfont,(void))

void Text_obj::addtypeface(::String _name,Float _size){
            	HX_STACK_FRAME("haxegon.Text","addtypeface",0xe87901a5,"haxegon.Text.addtypeface","haxegon/Text.hx",573,0xb667cca2)
            	HX_STACK_ARG(_name,"_name")
            	HX_STACK_ARG(_size,"_size")
HXLINE( 574)		::haxegon::Text_obj::typeface->push( ::haxegon::util::Fontclass_obj::__new(_name,_size));
HXLINE( 575)		{
HXLINE( 575)			Int value = (::haxegon::Text_obj::typeface->length - (int)1);
HXDLIN( 575)			::String _hx_tmp = (_name + HX_("_",5f,00,00,00));
HXDLIN( 575)			::String _hx_tmp1 = ::Std_obj::string(_size);
HXDLIN( 575)			::haxegon::Text_obj::typefaceindex->set((_hx_tmp + _hx_tmp1),value);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Text_obj,addtypeface,(void))

::String Text_obj::getfonttypename(::String fontname){
            	HX_STACK_FRAME("haxegon.Text","getfonttypename",0xda16ad17,"haxegon.Text.getfonttypename","haxegon/Text.hx",580,0xb667cca2)
            	HX_STACK_ARG(fontname,"fontname")
HXLINE( 580)		return ::haxegon::Text_obj::fontfile->__get(( (Int)(::haxegon::Text_obj::fontfileindex->get(fontname)) )).StaticCast<  ::haxegon::util::Fontfile >()->_hx_typename;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Text_obj,getfonttypename,return )


Text_obj::Text_obj()
{
}

bool Text_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"t1") ) { outValue = t1; return true; }
		if (HX_FIELD_EQ(inName,"t2") ) { outValue = t2; return true; }
		if (HX_FIELD_EQ(inName,"t3") ) { outValue = t3; return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"TOP") ) { outValue = TOP; return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"LEFT") ) { outValue = LEFT; return true; }
		if (HX_FIELD_EQ(inName,"init") ) { outValue = init_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"RIGHT") ) { outValue = RIGHT; return true; }
		if (HX_FIELD_EQ(inName,"align") ) { outValue = align_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"input") ) { outValue = input_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"width") ) { outValue = width_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"drawto") ) { outValue = drawto; return true; }
		if (HX_FIELD_EQ(inName,"BOTTOM") ) { outValue = BOTTOM; return true; }
		if (HX_FIELD_EQ(inName,"CENTER") ) { outValue = CENTER; return true; }
		if (HX_FIELD_EQ(inName,"height") ) { outValue = height_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"alignx") ) { outValue = alignx_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"aligny") ) { outValue = aligny_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempred") ) { outValue = tempred; return true; }
		if (HX_FIELD_EQ(inName,"alphact") ) { outValue = alphact; return true; }
		if (HX_FIELD_EQ(inName,"display") ) { outValue = display_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"setfont") ) { outValue = setfont_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addfont") ) { outValue = addfont_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"fontfile") ) { outValue = fontfile; return true; }
		if (HX_FIELD_EQ(inName,"typeface") ) { outValue = typeface; return true; }
		if (HX_FIELD_EQ(inName,"gfxstage") ) { outValue = gfxstage; return true; }
		if (HX_FIELD_EQ(inName,"tempblue") ) { outValue = tempblue; return true; }
		if (HX_FIELD_EQ(inName,"rotation") ) { outValue = rotation_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"textalign") ) { outValue = textalign; return true; }
		if (HX_FIELD_EQ(inName,"tempalpha") ) { outValue = tempalpha; return true; }
		if (HX_FIELD_EQ(inName,"tempgreen") ) { outValue = tempgreen; return true; }
		if (HX_FIELD_EQ(inName,"inputtext") ) { outValue = inputtext; return true; }
		if (HX_FIELD_EQ(inName,"lastentry") ) { outValue = lastentry; return true; }
		if (HX_FIELD_EQ(inName,"get_input") ) { outValue = get_input_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fontmatrix") ) { outValue = fontmatrix; return true; }
		if (HX_FIELD_EQ(inName,"textrotate") ) { outValue = textrotate; return true; }
		if (HX_FIELD_EQ(inName,"temprotate") ) { outValue = temprotate; return true; }
		if (HX_FIELD_EQ(inName,"tempxscale") ) { outValue = tempxscale; return true; }
		if (HX_FIELD_EQ(inName,"tempyscale") ) { outValue = tempyscale; return true; }
		if (HX_FIELD_EQ(inName,"tempxpivot") ) { outValue = tempxpivot; return true; }
		if (HX_FIELD_EQ(inName,"tempypivot") ) { outValue = tempypivot; return true; }
		if (HX_FIELD_EQ(inName,"input_text") ) { outValue = input_text; return true; }
		if (HX_FIELD_EQ(inName,"input_font") ) { outValue = input_font; return true; }
		if (HX_FIELD_EQ(inName,"input_show") ) { outValue = input_show; return true; }
		if (HX_FIELD_EQ(inName,"aligntextx") ) { outValue = aligntextx_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"aligntexty") ) { outValue = aligntexty_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"cachedtext") ) { outValue = cachedtext; return true; }
		if (HX_FIELD_EQ(inName,"cacheindex") ) { outValue = cacheindex; return true; }
		if (HX_FIELD_EQ(inName,"cachelabel") ) { outValue = cachelabel; return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"currentfont") ) { outValue = currentfont; return true; }
		if (HX_FIELD_EQ(inName,"currentsize") ) { outValue = currentsize; return true; }
		if (HX_FIELD_EQ(inName,"cachealignx") ) { outValue = cachealignx_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"cachealigny") ) { outValue = cachealigny_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"display_ttf") ) { outValue = display_ttf_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"change_size") ) { outValue = change_size_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addtypeface") ) { outValue = addtypeface_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentindex") ) { outValue = currentindex; return true; }
		if (HX_FIELD_EQ(inName,"input_textxp") ) { outValue = input_textxp; return true; }
		if (HX_FIELD_EQ(inName,"input_textyp") ) { outValue = input_textyp; return true; }
		if (HX_FIELD_EQ(inName,"currentwidth") ) { outValue = currentwidth_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fontfileindex") ) { outValue = fontfileindex; return true; }
		if (HX_FIELD_EQ(inName,"typefaceindex") ) { outValue = typefaceindex; return true; }
		if (HX_FIELD_EQ(inName,"textalphamult") ) { outValue = textalphamult; return true; }
		if (HX_FIELD_EQ(inName,"changecolours") ) { outValue = changecolours; return true; }
		if (HX_FIELD_EQ(inName,"input_textcol") ) { outValue = input_textcol; return true; }
		if (HX_FIELD_EQ(inName,"currentheight") ) { outValue = currentheight_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"inputmaxlength") ) { outValue = inputmaxlength; return true; }
		if (HX_FIELD_EQ(inName,"input_response") ) { outValue = input_response; return true; }
		if (HX_FIELD_EQ(inName,"input_textsize") ) { outValue = input_textsize; return true; }
		if (HX_FIELD_EQ(inName,"cleartextcache") ) { outValue = cleartextcache_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"display_bitmap") ) { outValue = display_bitmap_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"createtypeface") ) { outValue = createtypeface_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"drawstringinput") ) { outValue = drawstringinput_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"cachealigntextx") ) { outValue = cachealigntextx_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"cachealigntexty") ) { outValue = cachealigntexty_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"cachedtextindex") ) { outValue = cachedtextindex; return true; }
		if (HX_FIELD_EQ(inName,"getfonttypename") ) { outValue = getfonttypename_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"textrotatexpivot") ) { outValue = textrotatexpivot; return true; }
		if (HX_FIELD_EQ(inName,"textrotateypivot") ) { outValue = textrotateypivot; return true; }
		if (HX_FIELD_EQ(inName,"input_responsexp") ) { outValue = input_responsexp; return true; }
		if (HX_FIELD_EQ(inName,"input_responseyp") ) { outValue = input_responseyp; return true; }
		if (HX_FIELD_EQ(inName,"input_cursorglow") ) { outValue = input_cursorglow; return true; }
		if (HX_FIELD_EQ(inName,"reset_text_input") ) { outValue = reset_text_input_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"input_responsecol") ) { outValue = input_responsecol; return true; }
		if (HX_FIELD_EQ(inName,"cache_bitmap_text") ) { outValue = cache_bitmap_text_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"input_checkfortext") ) { outValue = input_checkfortext_dyn(); return true; }
	}
	return false;
}

bool Text_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"t1") ) { t1=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"t2") ) { t2=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"t3") ) { t3=ioValue.Cast< Float >(); return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"TOP") ) { TOP=ioValue.Cast< Int >(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"LEFT") ) { LEFT=ioValue.Cast< Int >(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"RIGHT") ) { RIGHT=ioValue.Cast< Int >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"drawto") ) { drawto=ioValue.Cast<  ::openfl::display::BitmapData >(); return true; }
		if (HX_FIELD_EQ(inName,"BOTTOM") ) { BOTTOM=ioValue.Cast< Int >(); return true; }
		if (HX_FIELD_EQ(inName,"CENTER") ) { CENTER=ioValue.Cast< Int >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempred") ) { tempred=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"alphact") ) { alphact=ioValue.Cast<  ::openfl::geom::ColorTransform >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"fontfile") ) { fontfile=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		if (HX_FIELD_EQ(inName,"typeface") ) { typeface=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		if (HX_FIELD_EQ(inName,"gfxstage") ) { gfxstage=ioValue.Cast<  ::openfl::display::Stage >(); return true; }
		if (HX_FIELD_EQ(inName,"tempblue") ) { tempblue=ioValue.Cast< Float >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"textalign") ) { textalign=ioValue.Cast< Int >(); return true; }
		if (HX_FIELD_EQ(inName,"tempalpha") ) { tempalpha=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"tempgreen") ) { tempgreen=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"inputtext") ) { inputtext=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"lastentry") ) { lastentry=ioValue.Cast< ::String >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fontmatrix") ) { fontmatrix=ioValue.Cast<  ::openfl::geom::Matrix >(); return true; }
		if (HX_FIELD_EQ(inName,"textrotate") ) { textrotate=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"temprotate") ) { temprotate=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"tempxscale") ) { tempxscale=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"tempyscale") ) { tempyscale=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"tempxpivot") ) { tempxpivot=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"tempypivot") ) { tempypivot=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"input_text") ) { input_text=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"input_font") ) { input_font=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"input_show") ) { input_show=ioValue.Cast< Int >(); return true; }
		if (HX_FIELD_EQ(inName,"cachedtext") ) { cachedtext=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		if (HX_FIELD_EQ(inName,"cacheindex") ) { cacheindex=ioValue.Cast< Int >(); return true; }
		if (HX_FIELD_EQ(inName,"cachelabel") ) { cachelabel=ioValue.Cast< ::String >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"currentfont") ) { currentfont=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"currentsize") ) { currentsize=ioValue.Cast< Float >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentindex") ) { currentindex=ioValue.Cast< Int >(); return true; }
		if (HX_FIELD_EQ(inName,"input_textxp") ) { input_textxp=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"input_textyp") ) { input_textyp=ioValue.Cast< Float >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fontfileindex") ) { fontfileindex=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		if (HX_FIELD_EQ(inName,"typefaceindex") ) { typefaceindex=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		if (HX_FIELD_EQ(inName,"textalphamult") ) { textalphamult=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"changecolours") ) { changecolours=ioValue.Cast< Bool >(); return true; }
		if (HX_FIELD_EQ(inName,"input_textcol") ) { input_textcol=ioValue.Cast< Int >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"inputmaxlength") ) { inputmaxlength=ioValue.Cast< Int >(); return true; }
		if (HX_FIELD_EQ(inName,"input_response") ) { input_response=ioValue.Cast< ::String >(); return true; }
		if (HX_FIELD_EQ(inName,"input_textsize") ) { input_textsize=ioValue.Cast< Float >(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"cachedtextindex") ) { cachedtextindex=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"textrotatexpivot") ) { textrotatexpivot=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"textrotateypivot") ) { textrotateypivot=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"input_responsexp") ) { input_responsexp=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"input_responseyp") ) { input_responseyp=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"input_cursorglow") ) { input_cursorglow=ioValue.Cast< Int >(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"input_responsecol") ) { input_responsecol=ioValue.Cast< Int >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Text_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Text_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Text_obj::fontfile,HX_HCSTRING("fontfile","\xcb","\xbf","\x60","\xdb")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(void *) &Text_obj::fontfileindex,HX_HCSTRING("fontfileindex","\x67","\xbb","\x11","\xfb")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Text_obj::typeface,HX_HCSTRING("typeface","\x57","\x8c","\xa7","\xc5")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(void *) &Text_obj::typefaceindex,HX_HCSTRING("typefaceindex","\x5b","\xf3","\x9d","\xda")},
	{hx::fsObject /*::openfl::geom::Matrix*/ ,(void *) &Text_obj::fontmatrix,HX_HCSTRING("fontmatrix","\x50","\x59","\x87","\x3b")},
	{hx::fsInt,(void *) &Text_obj::currentindex,HX_HCSTRING("currentindex","\x39","\x10","\xf3","\x71")},
	{hx::fsString,(void *) &Text_obj::currentfont,HX_HCSTRING("currentfont","\x88","\x0a","\x79","\x91")},
	{hx::fsFloat,(void *) &Text_obj::currentsize,HX_HCSTRING("currentsize","\x7a","\x4d","\x0c","\x9a")},
	{hx::fsObject /*::openfl::display::Stage*/ ,(void *) &Text_obj::gfxstage,HX_HCSTRING("gfxstage","\xa5","\xf2","\xb7","\x13")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(void *) &Text_obj::drawto,HX_HCSTRING("drawto","\x7f","\x9a","\xd6","\xdf")},
	{hx::fsInt,(void *) &Text_obj::LEFT,HX_HCSTRING("LEFT","\x07","\xd0","\x70","\x32")},
	{hx::fsInt,(void *) &Text_obj::RIGHT,HX_HCSTRING("RIGHT","\xbc","\x43","\x52","\x67")},
	{hx::fsInt,(void *) &Text_obj::TOP,HX_HCSTRING("TOP","\x75","\x02","\x40","\x00")},
	{hx::fsInt,(void *) &Text_obj::BOTTOM,HX_HCSTRING("BOTTOM","\xeb","\x92","\xfb","\x17")},
	{hx::fsInt,(void *) &Text_obj::CENTER,HX_HCSTRING("CENTER","\xd5","\xd1","\x5d","\xb8")},
	{hx::fsInt,(void *) &Text_obj::textalign,HX_HCSTRING("textalign","\xf8","\x76","\x51","\x27")},
	{hx::fsFloat,(void *) &Text_obj::textrotate,HX_HCSTRING("textrotate","\xc8","\x52","\x7c","\xcd")},
	{hx::fsFloat,(void *) &Text_obj::textrotatexpivot,HX_HCSTRING("textrotatexpivot","\x12","\x30","\xc0","\x2c")},
	{hx::fsFloat,(void *) &Text_obj::textrotateypivot,HX_HCSTRING("textrotateypivot","\x71","\x8c","\x1b","\x93")},
	{hx::fsFloat,(void *) &Text_obj::textalphamult,HX_HCSTRING("textalphamult","\x01","\xcc","\x45","\x0d")},
	{hx::fsFloat,(void *) &Text_obj::temprotate,HX_HCSTRING("temprotate","\x6f","\x90","\xfb","\xb1")},
	{hx::fsFloat,(void *) &Text_obj::tempxscale,HX_HCSTRING("tempxscale","\x26","\x65","\x7d","\x5a")},
	{hx::fsFloat,(void *) &Text_obj::tempyscale,HX_HCSTRING("tempyscale","\x85","\xc1","\xd8","\xc0")},
	{hx::fsFloat,(void *) &Text_obj::tempxpivot,HX_HCSTRING("tempxpivot","\x5e","\xe1","\x50","\xa4")},
	{hx::fsFloat,(void *) &Text_obj::tempypivot,HX_HCSTRING("tempypivot","\xbd","\x3d","\xac","\x0a")},
	{hx::fsFloat,(void *) &Text_obj::tempalpha,HX_HCSTRING("tempalpha","\xca","\x3b","\x7d","\xc4")},
	{hx::fsFloat,(void *) &Text_obj::tempred,HX_HCSTRING("tempred","\xbd","\x3a","\xd1","\x46")},
	{hx::fsFloat,(void *) &Text_obj::tempgreen,HX_HCSTRING("tempgreen","\x2f","\xa3","\xd3","\x3c")},
	{hx::fsFloat,(void *) &Text_obj::tempblue,HX_HCSTRING("tempblue","\xae","\x1f","\xb4","\xa5")},
	{hx::fsBool,(void *) &Text_obj::changecolours,HX_HCSTRING("changecolours","\x37","\xf7","\xeb","\x82")},
	{hx::fsObject /*::openfl::geom::ColorTransform*/ ,(void *) &Text_obj::alphact,HX_HCSTRING("alphact","\x8f","\x11","\x16","\xb2")},
	{hx::fsInt,(void *) &Text_obj::inputmaxlength,HX_HCSTRING("inputmaxlength","\x40","\x9d","\xf0","\x36")},
	{hx::fsString,(void *) &Text_obj::inputtext,HX_HCSTRING("inputtext","\xb7","\x5d","\x4b","\x29")},
	{hx::fsString,(void *) &Text_obj::lastentry,HX_HCSTRING("lastentry","\x5c","\x36","\x06","\x2a")},
	{hx::fsFloat,(void *) &Text_obj::input_textxp,HX_HCSTRING("input_textxp","\xba","\xbd","\xda","\x11")},
	{hx::fsFloat,(void *) &Text_obj::input_textyp,HX_HCSTRING("input_textyp","\x99","\xbe","\xda","\x11")},
	{hx::fsFloat,(void *) &Text_obj::input_responsexp,HX_HCSTRING("input_responsexp","\x0e","\x4b","\x6b","\x22")},
	{hx::fsFloat,(void *) &Text_obj::input_responseyp,HX_HCSTRING("input_responseyp","\xed","\x4b","\x6b","\x22")},
	{hx::fsInt,(void *) &Text_obj::input_textcol,HX_HCSTRING("input_textcol","\x3e","\x55","\x7b","\x8d")},
	{hx::fsInt,(void *) &Text_obj::input_responsecol,HX_HCSTRING("input_responsecol","\x6a","\x71","\x66","\xfb")},
	{hx::fsString,(void *) &Text_obj::input_text,HX_HCSTRING("input_text","\x42","\x40","\x18","\xeb")},
	{hx::fsString,(void *) &Text_obj::input_response,HX_HCSTRING("input_response","\x96","\x10","\x95","\x86")},
	{hx::fsInt,(void *) &Text_obj::input_cursorglow,HX_HCSTRING("input_cursorglow","\xb8","\xd1","\x63","\x96")},
	{hx::fsString,(void *) &Text_obj::input_font,HX_HCSTRING("input_font","\x64","\xd1","\xde","\xe1")},
	{hx::fsFloat,(void *) &Text_obj::input_textsize,HX_HCSTRING("input_textsize","\x03","\x2a","\xfe","\x48")},
	{hx::fsInt,(void *) &Text_obj::input_show,HX_HCSTRING("input_show","\x92","\x48","\x71","\xea")},
	{hx::fsFloat,(void *) &Text_obj::t1,HX_HCSTRING("t1","\x3d","\x65","\x00","\x00")},
	{hx::fsFloat,(void *) &Text_obj::t2,HX_HCSTRING("t2","\x3e","\x65","\x00","\x00")},
	{hx::fsFloat,(void *) &Text_obj::t3,HX_HCSTRING("t3","\x3f","\x65","\x00","\x00")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(void *) &Text_obj::cachedtextindex,HX_HCSTRING("cachedtextindex","\x23","\x4f","\xdc","\xc8")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Text_obj::cachedtext,HX_HCSTRING("cachedtext","\x8f","\xc5","\x96","\x90")},
	{hx::fsInt,(void *) &Text_obj::cacheindex,HX_HCSTRING("cacheindex","\x90","\x91","\x9f","\x6d")},
	{hx::fsString,(void *) &Text_obj::cachelabel,HX_HCSTRING("cachelabel","\x72","\x04","\x3a","\x1f")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Text_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Text_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Text_obj::fontfile,"fontfile");
	HX_MARK_MEMBER_NAME(Text_obj::fontfileindex,"fontfileindex");
	HX_MARK_MEMBER_NAME(Text_obj::typeface,"typeface");
	HX_MARK_MEMBER_NAME(Text_obj::typefaceindex,"typefaceindex");
	HX_MARK_MEMBER_NAME(Text_obj::fontmatrix,"fontmatrix");
	HX_MARK_MEMBER_NAME(Text_obj::currentindex,"currentindex");
	HX_MARK_MEMBER_NAME(Text_obj::currentfont,"currentfont");
	HX_MARK_MEMBER_NAME(Text_obj::currentsize,"currentsize");
	HX_MARK_MEMBER_NAME(Text_obj::gfxstage,"gfxstage");
	HX_MARK_MEMBER_NAME(Text_obj::drawto,"drawto");
	HX_MARK_MEMBER_NAME(Text_obj::LEFT,"LEFT");
	HX_MARK_MEMBER_NAME(Text_obj::RIGHT,"RIGHT");
	HX_MARK_MEMBER_NAME(Text_obj::TOP,"TOP");
	HX_MARK_MEMBER_NAME(Text_obj::BOTTOM,"BOTTOM");
	HX_MARK_MEMBER_NAME(Text_obj::CENTER,"CENTER");
	HX_MARK_MEMBER_NAME(Text_obj::textalign,"textalign");
	HX_MARK_MEMBER_NAME(Text_obj::textrotate,"textrotate");
	HX_MARK_MEMBER_NAME(Text_obj::textrotatexpivot,"textrotatexpivot");
	HX_MARK_MEMBER_NAME(Text_obj::textrotateypivot,"textrotateypivot");
	HX_MARK_MEMBER_NAME(Text_obj::textalphamult,"textalphamult");
	HX_MARK_MEMBER_NAME(Text_obj::temprotate,"temprotate");
	HX_MARK_MEMBER_NAME(Text_obj::tempxscale,"tempxscale");
	HX_MARK_MEMBER_NAME(Text_obj::tempyscale,"tempyscale");
	HX_MARK_MEMBER_NAME(Text_obj::tempxpivot,"tempxpivot");
	HX_MARK_MEMBER_NAME(Text_obj::tempypivot,"tempypivot");
	HX_MARK_MEMBER_NAME(Text_obj::tempalpha,"tempalpha");
	HX_MARK_MEMBER_NAME(Text_obj::tempred,"tempred");
	HX_MARK_MEMBER_NAME(Text_obj::tempgreen,"tempgreen");
	HX_MARK_MEMBER_NAME(Text_obj::tempblue,"tempblue");
	HX_MARK_MEMBER_NAME(Text_obj::changecolours,"changecolours");
	HX_MARK_MEMBER_NAME(Text_obj::alphact,"alphact");
	HX_MARK_MEMBER_NAME(Text_obj::inputmaxlength,"inputmaxlength");
	HX_MARK_MEMBER_NAME(Text_obj::inputtext,"inputtext");
	HX_MARK_MEMBER_NAME(Text_obj::lastentry,"lastentry");
	HX_MARK_MEMBER_NAME(Text_obj::input_textxp,"input_textxp");
	HX_MARK_MEMBER_NAME(Text_obj::input_textyp,"input_textyp");
	HX_MARK_MEMBER_NAME(Text_obj::input_responsexp,"input_responsexp");
	HX_MARK_MEMBER_NAME(Text_obj::input_responseyp,"input_responseyp");
	HX_MARK_MEMBER_NAME(Text_obj::input_textcol,"input_textcol");
	HX_MARK_MEMBER_NAME(Text_obj::input_responsecol,"input_responsecol");
	HX_MARK_MEMBER_NAME(Text_obj::input_text,"input_text");
	HX_MARK_MEMBER_NAME(Text_obj::input_response,"input_response");
	HX_MARK_MEMBER_NAME(Text_obj::input_cursorglow,"input_cursorglow");
	HX_MARK_MEMBER_NAME(Text_obj::input_font,"input_font");
	HX_MARK_MEMBER_NAME(Text_obj::input_textsize,"input_textsize");
	HX_MARK_MEMBER_NAME(Text_obj::input_show,"input_show");
	HX_MARK_MEMBER_NAME(Text_obj::t1,"t1");
	HX_MARK_MEMBER_NAME(Text_obj::t2,"t2");
	HX_MARK_MEMBER_NAME(Text_obj::t3,"t3");
	HX_MARK_MEMBER_NAME(Text_obj::cachedtextindex,"cachedtextindex");
	HX_MARK_MEMBER_NAME(Text_obj::cachedtext,"cachedtext");
	HX_MARK_MEMBER_NAME(Text_obj::cacheindex,"cacheindex");
	HX_MARK_MEMBER_NAME(Text_obj::cachelabel,"cachelabel");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Text_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Text_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Text_obj::fontfile,"fontfile");
	HX_VISIT_MEMBER_NAME(Text_obj::fontfileindex,"fontfileindex");
	HX_VISIT_MEMBER_NAME(Text_obj::typeface,"typeface");
	HX_VISIT_MEMBER_NAME(Text_obj::typefaceindex,"typefaceindex");
	HX_VISIT_MEMBER_NAME(Text_obj::fontmatrix,"fontmatrix");
	HX_VISIT_MEMBER_NAME(Text_obj::currentindex,"currentindex");
	HX_VISIT_MEMBER_NAME(Text_obj::currentfont,"currentfont");
	HX_VISIT_MEMBER_NAME(Text_obj::currentsize,"currentsize");
	HX_VISIT_MEMBER_NAME(Text_obj::gfxstage,"gfxstage");
	HX_VISIT_MEMBER_NAME(Text_obj::drawto,"drawto");
	HX_VISIT_MEMBER_NAME(Text_obj::LEFT,"LEFT");
	HX_VISIT_MEMBER_NAME(Text_obj::RIGHT,"RIGHT");
	HX_VISIT_MEMBER_NAME(Text_obj::TOP,"TOP");
	HX_VISIT_MEMBER_NAME(Text_obj::BOTTOM,"BOTTOM");
	HX_VISIT_MEMBER_NAME(Text_obj::CENTER,"CENTER");
	HX_VISIT_MEMBER_NAME(Text_obj::textalign,"textalign");
	HX_VISIT_MEMBER_NAME(Text_obj::textrotate,"textrotate");
	HX_VISIT_MEMBER_NAME(Text_obj::textrotatexpivot,"textrotatexpivot");
	HX_VISIT_MEMBER_NAME(Text_obj::textrotateypivot,"textrotateypivot");
	HX_VISIT_MEMBER_NAME(Text_obj::textalphamult,"textalphamult");
	HX_VISIT_MEMBER_NAME(Text_obj::temprotate,"temprotate");
	HX_VISIT_MEMBER_NAME(Text_obj::tempxscale,"tempxscale");
	HX_VISIT_MEMBER_NAME(Text_obj::tempyscale,"tempyscale");
	HX_VISIT_MEMBER_NAME(Text_obj::tempxpivot,"tempxpivot");
	HX_VISIT_MEMBER_NAME(Text_obj::tempypivot,"tempypivot");
	HX_VISIT_MEMBER_NAME(Text_obj::tempalpha,"tempalpha");
	HX_VISIT_MEMBER_NAME(Text_obj::tempred,"tempred");
	HX_VISIT_MEMBER_NAME(Text_obj::tempgreen,"tempgreen");
	HX_VISIT_MEMBER_NAME(Text_obj::tempblue,"tempblue");
	HX_VISIT_MEMBER_NAME(Text_obj::changecolours,"changecolours");
	HX_VISIT_MEMBER_NAME(Text_obj::alphact,"alphact");
	HX_VISIT_MEMBER_NAME(Text_obj::inputmaxlength,"inputmaxlength");
	HX_VISIT_MEMBER_NAME(Text_obj::inputtext,"inputtext");
	HX_VISIT_MEMBER_NAME(Text_obj::lastentry,"lastentry");
	HX_VISIT_MEMBER_NAME(Text_obj::input_textxp,"input_textxp");
	HX_VISIT_MEMBER_NAME(Text_obj::input_textyp,"input_textyp");
	HX_VISIT_MEMBER_NAME(Text_obj::input_responsexp,"input_responsexp");
	HX_VISIT_MEMBER_NAME(Text_obj::input_responseyp,"input_responseyp");
	HX_VISIT_MEMBER_NAME(Text_obj::input_textcol,"input_textcol");
	HX_VISIT_MEMBER_NAME(Text_obj::input_responsecol,"input_responsecol");
	HX_VISIT_MEMBER_NAME(Text_obj::input_text,"input_text");
	HX_VISIT_MEMBER_NAME(Text_obj::input_response,"input_response");
	HX_VISIT_MEMBER_NAME(Text_obj::input_cursorglow,"input_cursorglow");
	HX_VISIT_MEMBER_NAME(Text_obj::input_font,"input_font");
	HX_VISIT_MEMBER_NAME(Text_obj::input_textsize,"input_textsize");
	HX_VISIT_MEMBER_NAME(Text_obj::input_show,"input_show");
	HX_VISIT_MEMBER_NAME(Text_obj::t1,"t1");
	HX_VISIT_MEMBER_NAME(Text_obj::t2,"t2");
	HX_VISIT_MEMBER_NAME(Text_obj::t3,"t3");
	HX_VISIT_MEMBER_NAME(Text_obj::cachedtextindex,"cachedtextindex");
	HX_VISIT_MEMBER_NAME(Text_obj::cachedtext,"cachedtext");
	HX_VISIT_MEMBER_NAME(Text_obj::cacheindex,"cacheindex");
	HX_VISIT_MEMBER_NAME(Text_obj::cachelabel,"cachelabel");
};

#endif

hx::Class Text_obj::__mClass;

static ::String Text_obj_sStaticFields[] = {
	HX_HCSTRING("fontfile","\xcb","\xbf","\x60","\xdb"),
	HX_HCSTRING("fontfileindex","\x67","\xbb","\x11","\xfb"),
	HX_HCSTRING("typeface","\x57","\x8c","\xa7","\xc5"),
	HX_HCSTRING("typefaceindex","\x5b","\xf3","\x9d","\xda"),
	HX_HCSTRING("fontmatrix","\x50","\x59","\x87","\x3b"),
	HX_HCSTRING("currentindex","\x39","\x10","\xf3","\x71"),
	HX_HCSTRING("currentfont","\x88","\x0a","\x79","\x91"),
	HX_HCSTRING("currentsize","\x7a","\x4d","\x0c","\x9a"),
	HX_HCSTRING("gfxstage","\xa5","\xf2","\xb7","\x13"),
	HX_HCSTRING("drawto","\x7f","\x9a","\xd6","\xdf"),
	HX_HCSTRING("LEFT","\x07","\xd0","\x70","\x32"),
	HX_HCSTRING("RIGHT","\xbc","\x43","\x52","\x67"),
	HX_HCSTRING("TOP","\x75","\x02","\x40","\x00"),
	HX_HCSTRING("BOTTOM","\xeb","\x92","\xfb","\x17"),
	HX_HCSTRING("CENTER","\xd5","\xd1","\x5d","\xb8"),
	HX_HCSTRING("textalign","\xf8","\x76","\x51","\x27"),
	HX_HCSTRING("textrotate","\xc8","\x52","\x7c","\xcd"),
	HX_HCSTRING("textrotatexpivot","\x12","\x30","\xc0","\x2c"),
	HX_HCSTRING("textrotateypivot","\x71","\x8c","\x1b","\x93"),
	HX_HCSTRING("textalphamult","\x01","\xcc","\x45","\x0d"),
	HX_HCSTRING("temprotate","\x6f","\x90","\xfb","\xb1"),
	HX_HCSTRING("tempxscale","\x26","\x65","\x7d","\x5a"),
	HX_HCSTRING("tempyscale","\x85","\xc1","\xd8","\xc0"),
	HX_HCSTRING("tempxpivot","\x5e","\xe1","\x50","\xa4"),
	HX_HCSTRING("tempypivot","\xbd","\x3d","\xac","\x0a"),
	HX_HCSTRING("tempalpha","\xca","\x3b","\x7d","\xc4"),
	HX_HCSTRING("tempred","\xbd","\x3a","\xd1","\x46"),
	HX_HCSTRING("tempgreen","\x2f","\xa3","\xd3","\x3c"),
	HX_HCSTRING("tempblue","\xae","\x1f","\xb4","\xa5"),
	HX_HCSTRING("changecolours","\x37","\xf7","\xeb","\x82"),
	HX_HCSTRING("alphact","\x8f","\x11","\x16","\xb2"),
	HX_HCSTRING("inputmaxlength","\x40","\x9d","\xf0","\x36"),
	HX_HCSTRING("inputtext","\xb7","\x5d","\x4b","\x29"),
	HX_HCSTRING("lastentry","\x5c","\x36","\x06","\x2a"),
	HX_HCSTRING("input_textxp","\xba","\xbd","\xda","\x11"),
	HX_HCSTRING("input_textyp","\x99","\xbe","\xda","\x11"),
	HX_HCSTRING("input_responsexp","\x0e","\x4b","\x6b","\x22"),
	HX_HCSTRING("input_responseyp","\xed","\x4b","\x6b","\x22"),
	HX_HCSTRING("input_textcol","\x3e","\x55","\x7b","\x8d"),
	HX_HCSTRING("input_responsecol","\x6a","\x71","\x66","\xfb"),
	HX_HCSTRING("input_text","\x42","\x40","\x18","\xeb"),
	HX_HCSTRING("input_response","\x96","\x10","\x95","\x86"),
	HX_HCSTRING("input_cursorglow","\xb8","\xd1","\x63","\x96"),
	HX_HCSTRING("input_font","\x64","\xd1","\xde","\xe1"),
	HX_HCSTRING("input_textsize","\x03","\x2a","\xfe","\x48"),
	HX_HCSTRING("input_show","\x92","\x48","\x71","\xea"),
	HX_HCSTRING("init","\x10","\x3b","\xbb","\x45"),
	HX_HCSTRING("align","\xc5","\x56","\x91","\x21"),
	HX_HCSTRING("rotation","\x3e","\x3d","\x86","\x08"),
	HX_HCSTRING("input_checkfortext","\x03","\x6d","\xd3","\x28"),
	HX_HCSTRING("input","\x0a","\xc4","\x1d","\xbe"),
	HX_HCSTRING("get_input","\x61","\x20","\xc7","\x01"),
	HX_HCSTRING("drawstringinput","\x15","\x10","\x58","\x17"),
	HX_HCSTRING("width","\x06","\xb6","\x62","\xca"),
	HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"),
	HX_HCSTRING("t1","\x3d","\x65","\x00","\x00"),
	HX_HCSTRING("t2","\x3e","\x65","\x00","\x00"),
	HX_HCSTRING("t3","\x3f","\x65","\x00","\x00"),
	HX_HCSTRING("cachealignx","\xd5","\x4d","\xa7","\x27"),
	HX_HCSTRING("cachealigny","\xd6","\x4d","\xa7","\x27"),
	HX_HCSTRING("currentwidth","\x2d","\x2b","\x41","\x7e"),
	HX_HCSTRING("alignx","\x13","\x96","\x9a","\x3d"),
	HX_HCSTRING("currentheight","\xe0","\x14","\x14","\xb1"),
	HX_HCSTRING("aligny","\x14","\x96","\x9a","\x3d"),
	HX_HCSTRING("cachealigntextx","\x08","\x0b","\xaf","\xfb"),
	HX_HCSTRING("cachealigntexty","\x09","\x0b","\xaf","\xfb"),
	HX_HCSTRING("aligntextx","\x46","\x4a","\xbe","\x13"),
	HX_HCSTRING("aligntexty","\x47","\x4a","\xbe","\x13"),
	HX_HCSTRING("reset_text_input","\x68","\xdf","\x2e","\xcd"),
	HX_HCSTRING("cachedtextindex","\x23","\x4f","\xdc","\xc8"),
	HX_HCSTRING("cachedtext","\x8f","\xc5","\x96","\x90"),
	HX_HCSTRING("cacheindex","\x90","\x91","\x9f","\x6d"),
	HX_HCSTRING("cachelabel","\x72","\x04","\x3a","\x1f"),
	HX_HCSTRING("cleartextcache","\x48","\x2f","\x07","\x63"),
	HX_HCSTRING("display","\x42","\x2a","\x4a","\xbb"),
	HX_HCSTRING("cache_bitmap_text","\x80","\x59","\x71","\x69"),
	HX_HCSTRING("display_bitmap","\x8c","\xa3","\x33","\x07"),
	HX_HCSTRING("display_ttf","\x29","\x23","\x3d","\x3c"),
	HX_HCSTRING("createtypeface","\x53","\x4f","\x30","\x3e"),
	HX_HCSTRING("setfont","\x71","\x72","\x6b","\x1e"),
	HX_HCSTRING("change_size","\x30","\xf5","\xfc","\x91"),
	HX_HCSTRING("addfont","\x70","\x74","\x24","\x95"),
	HX_HCSTRING("addtypeface","\x78","\x07","\x52","\x1d"),
	HX_HCSTRING("getfonttypename","\x6a","\x98","\xe2","\x6d"),
	::String(null())
};

void Text_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.Text","\x1b","\x8b","\xcf","\xa0");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Text_obj::__GetStatic;
	__mClass->mSetStaticField = &Text_obj::__SetStatic;
	__mClass->mMarkFunc = Text_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Text_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Text_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Text_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Text_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Text_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Text_obj::__boot()
{
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",14,0xb667cca2)
HXLINE(  14)		fontfile = ::Array_obj< ::Dynamic>::__new();
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",15,0xb667cca2)
HXLINE(  15)		fontfileindex =  ::haxe::ds::StringMap_obj::__new();
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",17,0xb667cca2)
HXLINE(  17)		typeface = ::Array_obj< ::Dynamic>::__new();
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",18,0xb667cca2)
HXLINE(  18)		typefaceindex =  ::haxe::ds::StringMap_obj::__new();
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",20,0xb667cca2)
HXLINE(  20)		fontmatrix =  ::openfl::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",21,0xb667cca2)
HXLINE(  21)		currentindex = (int)-1;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",22,0xb667cca2)
HXLINE(  22)		currentfont = HX_("null",87,9e,0e,49);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",23,0xb667cca2)
HXLINE(  23)		currentsize = ((Float)-1);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",28,0xb667cca2)
HXLINE(  28)		LEFT = (int)-10000;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",29,0xb667cca2)
HXLINE(  29)		RIGHT = (int)-20000;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",30,0xb667cca2)
HXLINE(  30)		TOP = (int)-10000;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",31,0xb667cca2)
HXLINE(  31)		BOTTOM = (int)-20000;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",32,0xb667cca2)
HXLINE(  32)		CENTER = (int)-15000;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",34,0xb667cca2)
HXLINE(  34)		textalign = ::haxegon::Text_obj::LEFT;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",35,0xb667cca2)
HXLINE(  35)		textrotate = ((Float)0);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",36,0xb667cca2)
HXLINE(  36)		textrotatexpivot = ((Float)0);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",37,0xb667cca2)
HXLINE(  37)		textrotateypivot = ((Float)0);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",38,0xb667cca2)
HXLINE(  38)		textalphamult = ((Float)1.0);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",39,0xb667cca2)
HXLINE(  39)		temprotate = ((Float)0);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",40,0xb667cca2)
HXLINE(  40)		tempxscale = ((Float)1);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",41,0xb667cca2)
HXLINE(  41)		tempyscale = ((Float)1);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",42,0xb667cca2)
HXLINE(  42)		tempxpivot = ((Float)0);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",43,0xb667cca2)
HXLINE(  43)		tempypivot = ((Float)0);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",44,0xb667cca2)
HXLINE(  44)		tempalpha = ((Float)1);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",45,0xb667cca2)
HXLINE(  45)		tempred = ((Float)1);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",46,0xb667cca2)
HXLINE(  46)		tempgreen = ((Float)1);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",47,0xb667cca2)
HXLINE(  47)		tempblue = ((Float)1);
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",48,0xb667cca2)
HXLINE(  48)		changecolours = false;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",69,0xb667cca2)
HXLINE(  69)		input_show = (int)0;
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",388,0xb667cca2)
HXLINE( 388)		cachedtextindex =  ::haxe::ds::StringMap_obj::__new();
            	}
{
            	HX_STACK_FRAME("haxegon.Text","boot",0x35258665,"haxegon.Text.boot","haxegon/Text.hx",389,0xb667cca2)
HXLINE( 389)		cachedtext = ::Array_obj< ::Dynamic>::__new(0);
            	}
}

} // end namespace haxegon
