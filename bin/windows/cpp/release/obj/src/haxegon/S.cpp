// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxegon_S
#include <haxegon/S.h>
#endif

namespace haxegon{

void S_obj::__construct() { }

Dynamic S_obj::__CreateEmpty() { return new S_obj; }

hx::ObjectPtr< S_obj > S_obj::__new()
{
	hx::ObjectPtr< S_obj > _hx_result = new S_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic S_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< S_obj > _hx_result = new S_obj();
	_hx_result->__construct();
	return _hx_result;
}

::String S_obj::uppercase(::String currentstring){
            	HX_STACK_FRAME("haxegon.S","uppercase",0x5db554a9,"haxegon.S.uppercase","haxegon/S.hx",6,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
HXLINE(   6)		return currentstring.toUpperCase();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(S_obj,uppercase,return )

::String S_obj::lowercase(::String currentstring){
            	HX_STACK_FRAME("haxegon.S","lowercase",0xdd1c70c8,"haxegon.S.lowercase","haxegon/S.hx",11,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
HXLINE(  11)		return currentstring.toLowerCase();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(S_obj,lowercase,return )

::Array< ::String > S_obj::split(::String currentstring,::String delimiter){
            	HX_STACK_FRAME("haxegon.S","split",0x728856f1,"haxegon.S.split","haxegon/S.hx",16,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(delimiter,"delimiter")
HXLINE(  16)		return currentstring.split(delimiter);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,split,return )

::String S_obj::removefromstring(::String fullstring,::String substring){
            	HX_STACK_FRAME("haxegon.S","removefromstring",0xf0d0c048,"haxegon.S.removefromstring","haxegon/S.hx",20,0x33631f1a)
            	HX_STACK_ARG(fullstring,"fullstring")
            	HX_STACK_ARG(substring,"substring")
HXLINE(  21)		HX_VARI( Int,t) = ::haxegon::S_obj::positioninstring(fullstring,substring,null());
HXLINE(  22)		if ((t == (int)-1)) {
HXLINE(  23)			return fullstring;
            		}
            		else {
HXLINE(  25)			::String _hx_tmp = ::haxegon::S_obj::getroot(fullstring,substring);
HXDLIN(  25)			::String _hx_tmp1 = ::haxegon::S_obj::getbranch(fullstring,substring);
HXDLIN(  25)			return ::haxegon::S_obj::removefromstring((_hx_tmp + _hx_tmp1),substring);
            		}
HXLINE(  22)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,removefromstring,return )

Bool S_obj::isinstring(::String fullstring,::String stringtocheck){
            	HX_STACK_FRAME("haxegon.S","isinstring",0x378bb4e9,"haxegon.S.isinstring","haxegon/S.hx",30,0x33631f1a)
            	HX_STACK_ARG(fullstring,"fullstring")
            	HX_STACK_ARG(stringtocheck,"stringtocheck")
HXLINE(  31)		Int _hx_tmp = ::haxegon::S_obj::positioninstring(fullstring,stringtocheck,null());
HXDLIN(  31)		if ((_hx_tmp != (int)-1)) {
HXLINE(  31)			return true;
            		}
HXLINE(  32)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,isinstring,return )

Int S_obj::positioninstring(::String fullstring,::String substring,hx::Null< Int >  __o_start){
Int start = __o_start.Default(0);
            	HX_STACK_FRAME("haxegon.S","positioninstring",0xeb0bdd68,"haxegon.S.positioninstring","haxegon/S.hx",37,0x33631f1a)
            	HX_STACK_ARG(fullstring,"fullstring")
            	HX_STACK_ARG(substring,"substring")
            	HX_STACK_ARG(start,"start")
HXLINE(  37)		return fullstring.indexOf(substring,start);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(S_obj,positioninstring,return )

::String S_obj::letterat(::String currentstring,hx::Null< Int >  __o_position){
Int position = __o_position.Default(0);
            	HX_STACK_FRAME("haxegon.S","letterat",0x6f0083a2,"haxegon.S.letterat","haxegon/S.hx",42,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(position,"position")
HXLINE(  42)		return currentstring.substr(position,(int)1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,letterat,return )

::String S_obj::mid(::String currentstring,hx::Null< Int >  __o_start,hx::Null< Int >  __o_length){
Int start = __o_start.Default(0);
Int length = __o_length.Default(1);
            	HX_STACK_FRAME("haxegon.S","mid",0x5d0079df,"haxegon.S.mid","haxegon/S.hx",47,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(start,"start")
            	HX_STACK_ARG(length,"length")
HXLINE(  47)		return currentstring.substr(start,length);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(S_obj,mid,return )

::String S_obj::left(::String currentstring,hx::Null< Int >  __o_length){
Int length = __o_length.Default(1);
            	HX_STACK_FRAME("haxegon.S","left",0x02bdebd0,"haxegon.S.left","haxegon/S.hx",52,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(length,"length")
HXLINE(  52)		return currentstring.substr((int)0,length);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,left,return )

::String S_obj::right(::String currentstring,hx::Null< Int >  __o_length){
Int length = __o_length.Default(1);
            	HX_STACK_FRAME("haxegon.S","right",0xda7d77f3,"haxegon.S.right","haxegon/S.hx",57,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(length,"length")
HXLINE(  57)		Int _hx_tmp = (currentstring.length - length);
HXDLIN(  57)		return currentstring.substr(_hx_tmp,length);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,right,return )

::String S_obj::reversetext(::String currentstring){
            	HX_STACK_FRAME("haxegon.S","reversetext",0x15065626,"haxegon.S.reversetext","haxegon/S.hx",61,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
HXLINE(  62)		HX_VARI( ::String,t2) = HX_("",00,00,00,00);
HXLINE(  64)		{
HXLINE(  64)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  64)			HX_VARI( Int,_g) = currentstring.length;
HXDLIN(  64)			while((_g1 < _g)){
HXLINE(  64)				HX_VARI( Int,i) = _g1++;
HXLINE(  65)				Int _hx_tmp = ((currentstring.length - i) - (int)1);
HXDLIN(  65)				::String _hx_tmp1 = ::haxegon::S_obj::mid(currentstring,_hx_tmp,(int)1);
HXDLIN(  65)				hx::AddEq(t2,_hx_tmp1);
            			}
            		}
HXLINE(  67)		return t2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(S_obj,reversetext,return )

::String S_obj::replacechar(::String currentstring,::String __o_ch,::String __o_ch2){
::String ch = __o_ch.Default(HX_HCSTRING("|","\x7c","\x00","\x00","\x00"));
::String ch2 = __o_ch2.Default(HX_HCSTRING("","\x00","\x00","\x00","\x00"));
            	HX_STACK_FRAME("haxegon.S","replacechar",0x7fe1e861,"haxegon.S.replacechar","haxegon/S.hx",71,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(ch,"ch")
            	HX_STACK_ARG(ch2,"ch2")
HXLINE(  72)		HX_VARI( ::String,fixedstring) = HX_("",00,00,00,00);
HXLINE(  73)		{
HXLINE(  73)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  73)			HX_VARI( Int,_g) = currentstring.length;
HXDLIN(  73)			while((_g1 < _g)){
HXLINE(  73)				HX_VARI( Int,i) = _g1++;
HXLINE(  74)				::String _hx_tmp = ::haxegon::S_obj::mid(currentstring,i,null());
HXDLIN(  74)				if ((_hx_tmp == ch)) {
HXLINE(  75)					hx::AddEq(fixedstring,ch2);
            				}
            				else {
HXLINE(  77)					::String _hx_tmp1 = ::haxegon::S_obj::mid(currentstring,i,null());
HXDLIN(  77)					hx::AddEq(fixedstring,_hx_tmp1);
            				}
            			}
            		}
HXLINE(  80)		return fixedstring;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(S_obj,replacechar,return )

::String S_obj::getlastbranch(::String currentstring,::String ch){
            	HX_STACK_FRAME("haxegon.S","getlastbranch",0x0d36a0a5,"haxegon.S.getlastbranch","haxegon/S.hx",84,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(ch,"ch")
HXLINE(  85)		HX_VARI( Int,i) = (currentstring.length - (int)1);
HXLINE(  86)		while((i >= (int)0)){
HXLINE(  87)			::String _hx_tmp = ::haxegon::S_obj::mid(currentstring,i,(int)1);
HXDLIN(  87)			if ((_hx_tmp == ch)) {
HXLINE(  88)				Int _hx_tmp1 = (i + (int)1);
HXDLIN(  88)				Int _hx_tmp2 = ((currentstring.length - i) - (int)1);
HXDLIN(  88)				return ::haxegon::S_obj::mid(currentstring,_hx_tmp1,_hx_tmp2);
            			}
HXLINE(  90)			--i;
            		}
HXLINE(  92)		return currentstring;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,getlastbranch,return )

::String S_obj::getroot(::String currentstring,::String ch){
            	HX_STACK_FRAME("haxegon.S","getroot",0xaeb6518f,"haxegon.S.getroot","haxegon/S.hx",96,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(ch,"ch")
HXLINE(  97)		{
HXLINE(  97)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  97)			HX_VARI( Int,_g) = currentstring.length;
HXDLIN(  97)			while((_g1 < _g)){
HXLINE(  97)				HX_VARI( Int,i) = _g1++;
HXLINE(  98)				::String _hx_tmp = ::haxegon::S_obj::mid(currentstring,i,(int)1);
HXDLIN(  98)				if ((_hx_tmp == ch)) {
HXLINE(  99)					return ::haxegon::S_obj::mid(currentstring,(int)0,i);
            				}
            			}
            		}
HXLINE( 102)		return currentstring;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,getroot,return )

::String S_obj::getbranch(::String currentstring,::String ch){
            	HX_STACK_FRAME("haxegon.S","getbranch",0xd151d74f,"haxegon.S.getbranch","haxegon/S.hx",106,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
            	HX_STACK_ARG(ch,"ch")
HXLINE( 107)		{
HXLINE( 107)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 107)			HX_VARI( Int,_g) = currentstring.length;
HXDLIN( 107)			while((_g1 < _g)){
HXLINE( 107)				HX_VARI( Int,i) = _g1++;
HXLINE( 108)				::String _hx_tmp = ::haxegon::S_obj::mid(currentstring,i,(int)1);
HXDLIN( 108)				if ((_hx_tmp == ch)) {
HXLINE( 109)					Int _hx_tmp1 = (i + (int)1);
HXDLIN( 109)					Int _hx_tmp2 = ((currentstring.length - i) - (int)1);
HXDLIN( 109)					return ::haxegon::S_obj::mid(currentstring,_hx_tmp1,_hx_tmp2);
            				}
            			}
            		}
HXLINE( 112)		return currentstring;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(S_obj,getbranch,return )

::String S_obj::getbetweenbrackets(::String currentstring){
            	HX_STACK_FRAME("haxegon.S","getbetweenbrackets",0x5734a0c6,"haxegon.S.getbetweenbrackets","haxegon/S.hx",116,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
HXLINE( 117)		while(true){
HXLINE( 117)			Bool _hx_tmp;
HXDLIN( 117)			::String _hx_tmp1 = ::haxegon::S_obj::mid(currentstring,(int)0,(int)1);
HXDLIN( 117)			if ((_hx_tmp1 != HX_("(",28,00,00,00))) {
HXLINE( 117)				_hx_tmp = (currentstring.length > (int)0);
            			}
            			else {
HXLINE( 117)				_hx_tmp = false;
            			}
HXDLIN( 117)			if (!(_hx_tmp)) {
HXLINE( 117)				goto _hx_goto_5;
            			}
HXDLIN( 117)			Int _hx_tmp2 = (currentstring.length - (int)1);
HXDLIN( 117)			currentstring = ::haxegon::S_obj::mid(currentstring,(int)1,_hx_tmp2);
            		}
            		_hx_goto_5:;
HXLINE( 118)		while(true){
HXLINE( 118)			Bool _hx_tmp3;
HXDLIN( 118)			Int _hx_tmp4 = (currentstring.length - (int)1);
HXDLIN( 118)			::String _hx_tmp5 = ::haxegon::S_obj::mid(currentstring,_hx_tmp4,(int)1);
HXDLIN( 118)			if ((_hx_tmp5 != HX_(")",29,00,00,00))) {
HXLINE( 118)				_hx_tmp3 = (currentstring.length > (int)0);
            			}
            			else {
HXLINE( 118)				_hx_tmp3 = false;
            			}
HXDLIN( 118)			if (!(_hx_tmp3)) {
HXLINE( 118)				goto _hx_goto_6;
            			}
HXDLIN( 118)			Int _hx_tmp6 = (currentstring.length - (int)1);
HXDLIN( 118)			currentstring = ::haxegon::S_obj::mid(currentstring,(int)0,_hx_tmp6);
            		}
            		_hx_goto_6:;
HXLINE( 120)		if ((currentstring.length <= (int)0)) {
HXLINE( 120)			return HX_("",00,00,00,00);
            		}
HXLINE( 121)		Int _hx_tmp7 = (currentstring.length - (int)2);
HXDLIN( 121)		return ::haxegon::S_obj::mid(currentstring,(int)1,_hx_tmp7);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(S_obj,getbetweenbrackets,return )

::String S_obj::trimspaces(::String currentstring){
            	HX_STACK_FRAME("haxegon.S","trimspaces",0x255c73d8,"haxegon.S.trimspaces","haxegon/S.hx",125,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
HXLINE( 126)		while(true){
HXLINE( 126)			Bool _hx_tmp;
HXDLIN( 126)			::String _hx_tmp1 = ::haxegon::S_obj::mid(currentstring,(int)0,(int)1);
HXDLIN( 126)			if ((_hx_tmp1 == HX_(" ",20,00,00,00))) {
HXLINE( 126)				_hx_tmp = (currentstring.length > (int)0);
            			}
            			else {
HXLINE( 126)				_hx_tmp = false;
            			}
HXDLIN( 126)			if (!(_hx_tmp)) {
HXLINE( 126)				goto _hx_goto_7;
            			}
HXDLIN( 126)			Int _hx_tmp2 = (currentstring.length - (int)1);
HXDLIN( 126)			currentstring = ::haxegon::S_obj::mid(currentstring,(int)1,_hx_tmp2);
            		}
            		_hx_goto_7:;
HXLINE( 127)		while(true){
HXLINE( 127)			Bool _hx_tmp3;
HXDLIN( 127)			Int _hx_tmp4 = (currentstring.length - (int)1);
HXDLIN( 127)			::String _hx_tmp5 = ::haxegon::S_obj::mid(currentstring,_hx_tmp4,(int)1);
HXDLIN( 127)			if ((_hx_tmp5 == HX_(" ",20,00,00,00))) {
HXLINE( 127)				_hx_tmp3 = (currentstring.length > (int)0);
            			}
            			else {
HXLINE( 127)				_hx_tmp3 = false;
            			}
HXDLIN( 127)			if (!(_hx_tmp3)) {
HXLINE( 127)				goto _hx_goto_8;
            			}
HXDLIN( 127)			Int _hx_tmp6 = (currentstring.length - (int)1);
HXDLIN( 127)			currentstring = ::haxegon::S_obj::mid(currentstring,(int)0,_hx_tmp6);
            		}
            		_hx_goto_8:;
HXLINE( 129)		while(true){
HXLINE( 129)			Bool _hx_tmp7;
HXDLIN( 129)			::String _hx_tmp8 = ::haxegon::S_obj::mid(currentstring,(int)0,(int)1);
HXDLIN( 129)			if ((_hx_tmp8 == HX_("\t",09,00,00,00))) {
HXLINE( 129)				_hx_tmp7 = (currentstring.length > (int)0);
            			}
            			else {
HXLINE( 129)				_hx_tmp7 = false;
            			}
HXDLIN( 129)			if (!(_hx_tmp7)) {
HXLINE( 129)				goto _hx_goto_9;
            			}
HXDLIN( 129)			Int _hx_tmp9 = (currentstring.length - (int)1);
HXDLIN( 129)			currentstring = ::haxegon::S_obj::mid(currentstring,(int)1,_hx_tmp9);
            		}
            		_hx_goto_9:;
HXLINE( 130)		while(true){
HXLINE( 130)			Bool _hx_tmp10;
HXDLIN( 130)			Int _hx_tmp11 = (currentstring.length - (int)1);
HXDLIN( 130)			::String _hx_tmp12 = ::haxegon::S_obj::mid(currentstring,_hx_tmp11,(int)1);
HXDLIN( 130)			if ((_hx_tmp12 == HX_("\t",09,00,00,00))) {
HXLINE( 130)				_hx_tmp10 = (currentstring.length > (int)0);
            			}
            			else {
HXLINE( 130)				_hx_tmp10 = false;
            			}
HXDLIN( 130)			if (!(_hx_tmp10)) {
HXLINE( 130)				goto _hx_goto_10;
            			}
HXDLIN( 130)			Int _hx_tmp13 = (currentstring.length - (int)1);
HXDLIN( 130)			currentstring = ::haxegon::S_obj::mid(currentstring,(int)0,_hx_tmp13);
            		}
            		_hx_goto_10:;
HXLINE( 132)		if ((currentstring.length <= (int)0)) {
HXLINE( 132)			return HX_("",00,00,00,00);
            		}
HXLINE( 133)		return currentstring;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(S_obj,trimspaces,return )

Bool S_obj::isnumber(::String currentstring){
            	HX_STACK_FRAME("haxegon.S","isnumber",0x3c15aa7c,"haxegon.S.isnumber","haxegon/S.hx",137,0x33631f1a)
            	HX_STACK_ARG(currentstring,"currentstring")
HXLINE( 138)		Float _hx_tmp = ::Std_obj::parseFloat(currentstring);
HXDLIN( 138)		Bool _hx_tmp1 = ::Math_obj::isNaN(_hx_tmp);
HXDLIN( 138)		if (_hx_tmp1) {
HXLINE( 139)			return false;
            		}
            		else {
HXLINE( 141)			return true;
            		}
HXLINE( 138)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(S_obj,isnumber,return )


S_obj::S_obj()
{
}

bool S_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"mid") ) { outValue = mid_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"left") ) { outValue = left_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"split") ) { outValue = split_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"right") ) { outValue = right_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getroot") ) { outValue = getroot_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"letterat") ) { outValue = letterat_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isnumber") ) { outValue = isnumber_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"uppercase") ) { outValue = uppercase_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"lowercase") ) { outValue = lowercase_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getbranch") ) { outValue = getbranch_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"isinstring") ) { outValue = isinstring_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"trimspaces") ) { outValue = trimspaces_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"reversetext") ) { outValue = reversetext_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"replacechar") ) { outValue = replacechar_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getlastbranch") ) { outValue = getlastbranch_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"removefromstring") ) { outValue = removefromstring_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"positioninstring") ) { outValue = positioninstring_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getbetweenbrackets") ) { outValue = getbetweenbrackets_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *S_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *S_obj_sStaticStorageInfo = 0;
#endif

static void S_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(S_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void S_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(S_obj::__mClass,"__mClass");
};

#endif

hx::Class S_obj::__mClass;

static ::String S_obj_sStaticFields[] = {
	HX_HCSTRING("uppercase","\x12","\x91","\x3e","\xe7"),
	HX_HCSTRING("lowercase","\x31","\xad","\xa5","\x66"),
	HX_HCSTRING("split","\xda","\xea","\x6e","\x81"),
	HX_HCSTRING("removefromstring","\xff","\xd2","\xd7","\xe2"),
	HX_HCSTRING("isinstring","\x60","\x54","\x17","\x06"),
	HX_HCSTRING("positioninstring","\x1f","\xf0","\x12","\xdd"),
	HX_HCSTRING("letterat","\x59","\x87","\x3a","\xf8"),
	HX_HCSTRING("mid","\x88","\x11","\x53","\x00"),
	HX_HCSTRING("left","\x07","\x08","\xb0","\x47"),
	HX_HCSTRING("right","\xdc","\x0b","\x64","\xe9"),
	HX_HCSTRING("reversetext","\xcf","\x3e","\xa6","\x00"),
	HX_HCSTRING("replacechar","\x0a","\xd1","\x81","\x6b"),
	HX_HCSTRING("getlastbranch","\x8e","\xc5","\x20","\x0f"),
	HX_HCSTRING("getroot","\xb8","\x71","\x58","\x33"),
	HX_HCSTRING("getbranch","\xb8","\x13","\xdb","\x5a"),
	HX_HCSTRING("getbetweenbrackets","\x3d","\x0f","\x2f","\x27"),
	HX_HCSTRING("trimspaces","\x4f","\x13","\xe8","\xf3"),
	HX_HCSTRING("isnumber","\x33","\xae","\x4f","\xc5"),
	::String(null())
};

void S_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.S","\x45","\x11","\x43","\xd6");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &S_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = S_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(S_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< S_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = S_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = S_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = S_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxegon
