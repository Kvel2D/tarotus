// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapFont
#include <haxegon/bitmapFont/BitmapFont.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapGlyph
#include <haxegon/bitmapFont/BitmapGlyph.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapGlyphCollection
#include <haxegon/bitmapFont/BitmapGlyphCollection.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapGlyphFrame
#include <haxegon/bitmapFont/BitmapGlyphFrame.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

namespace haxegon{
namespace bitmapFont{

void BitmapGlyphCollection_obj::__construct( ::haxegon::bitmapFont::BitmapFont font,Float scale,Int color,hx::Null< Bool >  __o_useColor,hx::Null< Bool >  __o_smoothing){
Bool useColor = __o_useColor.Default(true);
Bool smoothing = __o_smoothing.Default(false);
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapGlyphCollection","new",0x9186098b,"haxegon.bitmapFont.BitmapGlyphCollection.new","haxegon/bitmapFont/BitmapFont.hx",628,0x0e43809e)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(font,"font")
            	HX_STACK_ARG(scale,"scale")
            	HX_STACK_ARG(color,"color")
            	HX_STACK_ARG(useColor,"useColor")
            	HX_STACK_ARG(smoothing,"smoothing")
HXLINE( 640)		this->spaceWidth = ((Float)0);
HXLINE( 630)		this->minOffsetX = ((Float)0);
HXLINE( 646)		this->glyphMap =  ::haxe::ds::IntMap_obj::__new();
HXLINE( 647)		this->glyphs = ::Array_obj< ::Dynamic>::__new();
HXLINE( 648)		this->font = font;
HXLINE( 649)		this->scale = scale;
HXLINE( 650)		Int _hx_tmp;
HXDLIN( 650)		if (useColor) {
HXLINE( 650)			_hx_tmp = color;
            		}
            		else {
HXLINE( 650)			_hx_tmp = (int)-1;
            		}
HXDLIN( 650)		this->color = _hx_tmp;
HXLINE( 651)		this->minOffsetX = (font->minOffsetX * scale);
HXLINE( 652)		this->prepareGlyphs(smoothing);
            	}

Dynamic BitmapGlyphCollection_obj::__CreateEmpty() { return new BitmapGlyphCollection_obj; }

hx::ObjectPtr< BitmapGlyphCollection_obj > BitmapGlyphCollection_obj::__new( ::haxegon::bitmapFont::BitmapFont font,Float scale,Int color,hx::Null< Bool >  __o_useColor,hx::Null< Bool >  __o_smoothing)
{
	hx::ObjectPtr< BitmapGlyphCollection_obj > _hx_result = new BitmapGlyphCollection_obj();
	_hx_result->__construct(font,scale,color,__o_useColor,__o_smoothing);
	return _hx_result;
}

Dynamic BitmapGlyphCollection_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< BitmapGlyphCollection_obj > _hx_result = new BitmapGlyphCollection_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

void BitmapGlyphCollection_obj::prepareGlyphs(hx::Null< Bool >  __o_smoothing){
Bool smoothing = __o_smoothing.Default(false);
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapGlyphCollection","prepareGlyphs",0x638edb19,"haxegon.bitmapFont.BitmapGlyphCollection.prepareGlyphs","haxegon/bitmapFont/BitmapFont.hx",656,0x0e43809e)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(smoothing,"smoothing")
HXLINE( 657)		HX_VARI(  ::openfl::geom::Matrix,matrix) =  ::openfl::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
HXLINE( 658)		matrix->scale(this->scale,this->scale);
HXLINE( 660)		HX_VARI(  ::openfl::geom::ColorTransform,colorTransform) =  ::openfl::geom::ColorTransform_obj::__new(null(),null(),null(),null(),null(),null(),null(),null());
HXLINE( 661)		HX_VARI_NAME( Int,_hx_int,"int") = ((int)hx::UShr(this->color,(int)16) & (int)(int)255);
HXDLIN( 661)		Float _hx_tmp;
HXDLIN( 661)		if ((_hx_int < (int)0)) {
HXLINE( 661)			_hx_tmp = (((Float)4294967296.0) + _hx_int);
            		}
            		else {
HXLINE( 661)			_hx_tmp = (_hx_int + ((Float)0.0));
            		}
HXDLIN( 661)		colorTransform->redMultiplier = ((Float)_hx_tmp / (Float)((Float)255.));
HXLINE( 662)		HX_VARI_NAME( Int,int1,"int") = ((int)hx::UShr(this->color,(int)8) & (int)(int)255);
HXDLIN( 662)		Float _hx_tmp1;
HXDLIN( 662)		if ((int1 < (int)0)) {
HXLINE( 662)			_hx_tmp1 = (((Float)4294967296.0) + int1);
            		}
            		else {
HXLINE( 662)			_hx_tmp1 = (int1 + ((Float)0.0));
            		}
HXDLIN( 662)		colorTransform->greenMultiplier = ((Float)_hx_tmp1 / (Float)((Float)255.));
HXLINE( 663)		HX_VARI_NAME( Int,int2,"int") = ((int)this->color & (int)(int)255);
HXDLIN( 663)		Float _hx_tmp2;
HXDLIN( 663)		if ((int2 < (int)0)) {
HXLINE( 663)			_hx_tmp2 = (((Float)4294967296.0) + int2);
            		}
            		else {
HXLINE( 663)			_hx_tmp2 = (int2 + ((Float)0.0));
            		}
HXDLIN( 663)		colorTransform->blueMultiplier = ((Float)_hx_tmp2 / (Float)((Float)255.));
HXLINE( 664)		HX_VARI_NAME( Int,int3,"int") = ((int)hx::UShr(this->color,(int)24) & (int)(int)255);
HXDLIN( 664)		Float _hx_tmp3;
HXDLIN( 664)		if ((int3 < (int)0)) {
HXLINE( 664)			_hx_tmp3 = (((Float)4294967296.0) + int3);
            		}
            		else {
HXLINE( 664)			_hx_tmp3 = (int3 + ((Float)0.0));
            		}
HXDLIN( 664)		colorTransform->alphaMultiplier = ((Float)_hx_tmp3 / (Float)((Float)255.));
HXLINE( 666)		HX_VAR(  ::openfl::display::BitmapData,glyphBD);
HXLINE( 667)		HX_VAR(  ::openfl::display::BitmapData,preparedBD);
HXLINE( 669)		HX_VAR(  ::haxegon::bitmapFont::BitmapGlyph,preparedGlyph);
HXLINE( 670)		HX_VAR( Int,bdWidth);
HXDLIN( 670)		HX_VAR( Int,bdHeight);
HXLINE( 671)		HX_VAR( Int,offsetX);
HXDLIN( 671)		HX_VAR( Int,offsetY);
HXDLIN( 671)		HX_VAR( Int,xAdvance);
HXLINE( 673)		this->spaceWidth = (this->font->spaceWidth * this->scale);
HXLINE( 675)		{
HXLINE( 675)			HX_VARI(  ::Dynamic,tmp) = this->font->glyphs->iterator();
HXDLIN( 675)			while(true){
HXLINE( 675)				Bool _hx_tmp4 = !(( (Bool)( ::Dynamic(tmp->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic))()) ));
HXDLIN( 675)				if (_hx_tmp4) {
HXLINE( 675)					goto _hx_goto_0;
            				}
HXDLIN( 675)				HX_VARI(  ::haxegon::bitmapFont::BitmapGlyphFrame,glyph) = ( ( ::haxegon::bitmapFont::BitmapGlyphFrame)( ::Dynamic(tmp->__Field(HX_("next",f3,84,02,49),hx::paccDynamic))()) );
HXLINE( 677)				glyphBD = glyph->get_bitmap();
HXLINE( 679)				Float _hx_tmp5 = (glyphBD->width * this->scale);
HXDLIN( 679)				bdWidth = ::Math_obj::ceil(_hx_tmp5);
HXLINE( 680)				Float _hx_tmp6 = (glyphBD->height * this->scale);
HXDLIN( 680)				bdHeight = ::Math_obj::ceil(_hx_tmp6);
HXLINE( 682)				Bool _hx_tmp7 = (bdWidth > (int)0);
HXDLIN( 682)				if (_hx_tmp7) {
HXLINE( 682)					bdWidth = bdWidth;
            				}
            				else {
HXLINE( 682)					bdWidth = (int)1;
            				}
HXLINE( 683)				Bool _hx_tmp8 = (bdHeight > (int)0);
HXDLIN( 683)				if (_hx_tmp8) {
HXLINE( 683)					bdHeight = bdHeight;
            				}
            				else {
HXLINE( 683)					bdHeight = (int)1;
            				}
HXLINE( 685)				preparedBD =  ::openfl::display::BitmapData_obj::__new(bdWidth,bdHeight,true,(int)0);
HXLINE( 688)				preparedBD->draw(glyphBD,matrix,colorTransform,null(),null(),smoothing);
HXLINE( 694)				Float _hx_tmp9 = (glyph->xoffset * this->scale);
HXDLIN( 694)				offsetX = ::Math_obj::ceil(_hx_tmp9);
HXLINE( 695)				Float _hx_tmp10 = (glyph->yoffset * this->scale);
HXDLIN( 695)				offsetY = ::Math_obj::ceil(_hx_tmp10);
HXLINE( 696)				Float _hx_tmp11 = (glyph->xadvance * this->scale);
HXDLIN( 696)				xAdvance = ::Math_obj::ceil(_hx_tmp11);
HXLINE( 698)				preparedGlyph =  ::haxegon::bitmapFont::BitmapGlyph_obj::__new(glyph->charCode,preparedBD,offsetX,offsetY,xAdvance);
HXLINE( 700)				this->glyphs->push(preparedGlyph);
HXLINE( 701)				{
HXLINE( 701)					Int key = preparedGlyph->charCode;
HXDLIN( 701)					this->glyphMap->set(key,preparedGlyph);
            				}
            			}
            			_hx_goto_0:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapGlyphCollection_obj,prepareGlyphs,(void))

void BitmapGlyphCollection_obj::dispose(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapGlyphCollection","dispose",0x66ca2b4a,"haxegon.bitmapFont.BitmapGlyphCollection.dispose","haxegon/bitmapFont/BitmapFont.hx",706,0x0e43809e)
            	HX_STACK_THIS(this)
HXLINE( 707)		Bool _hx_tmp = hx::IsNotNull( this->glyphs );
HXDLIN( 707)		if (_hx_tmp) {
HXLINE( 709)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 709)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->glyphs;
HXDLIN( 709)			while((_g < _g1->length)){
HXLINE( 709)				HX_VARI(  ::haxegon::bitmapFont::BitmapGlyph,glyph) = _g1->__get(_g).StaticCast<  ::haxegon::bitmapFont::BitmapGlyph >();
HXDLIN( 709)				++_g;
HXLINE( 711)				glyph->dispose();
            			}
            		}
HXLINE( 715)		this->glyphs = null();
HXLINE( 716)		this->glyphMap = null();
HXLINE( 717)		this->font = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapGlyphCollection_obj,dispose,(void))


BitmapGlyphCollection_obj::BitmapGlyphCollection_obj()
{
}

void BitmapGlyphCollection_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BitmapGlyphCollection);
	HX_MARK_MEMBER_NAME(minOffsetX,"minOffsetX");
	HX_MARK_MEMBER_NAME(glyphMap,"glyphMap");
	HX_MARK_MEMBER_NAME(glyphs,"glyphs");
	HX_MARK_MEMBER_NAME(color,"color");
	HX_MARK_MEMBER_NAME(scale,"scale");
	HX_MARK_MEMBER_NAME(spaceWidth,"spaceWidth");
	HX_MARK_MEMBER_NAME(font,"font");
	HX_MARK_END_CLASS();
}

void BitmapGlyphCollection_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(minOffsetX,"minOffsetX");
	HX_VISIT_MEMBER_NAME(glyphMap,"glyphMap");
	HX_VISIT_MEMBER_NAME(glyphs,"glyphs");
	HX_VISIT_MEMBER_NAME(color,"color");
	HX_VISIT_MEMBER_NAME(scale,"scale");
	HX_VISIT_MEMBER_NAME(spaceWidth,"spaceWidth");
	HX_VISIT_MEMBER_NAME(font,"font");
}

hx::Val BitmapGlyphCollection_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { return hx::Val( font); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"color") ) { return hx::Val( color); }
		if (HX_FIELD_EQ(inName,"scale") ) { return hx::Val( scale); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"glyphs") ) { return hx::Val( glyphs); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"dispose") ) { return hx::Val( dispose_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"glyphMap") ) { return hx::Val( glyphMap); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"minOffsetX") ) { return hx::Val( minOffsetX); }
		if (HX_FIELD_EQ(inName,"spaceWidth") ) { return hx::Val( spaceWidth); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"prepareGlyphs") ) { return hx::Val( prepareGlyphs_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val BitmapGlyphCollection_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { font=inValue.Cast<  ::haxegon::bitmapFont::BitmapFont >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"color") ) { color=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scale") ) { scale=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"glyphs") ) { glyphs=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"glyphMap") ) { glyphMap=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"minOffsetX") ) { minOffsetX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"spaceWidth") ) { spaceWidth=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BitmapGlyphCollection_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("minOffsetX","\xf3","\x55","\x1c","\x9d"));
	outFields->push(HX_HCSTRING("glyphMap","\x50","\x98","\x62","\xb1"));
	outFields->push(HX_HCSTRING("glyphs","\x47","\xf9","\x58","\xae"));
	outFields->push(HX_HCSTRING("color","\x63","\x71","\x5c","\x4a"));
	outFields->push(HX_HCSTRING("scale","\x8a","\xce","\xce","\x78"));
	outFields->push(HX_HCSTRING("spaceWidth","\x60","\x8b","\x97","\x2b"));
	outFields->push(HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo BitmapGlyphCollection_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(BitmapGlyphCollection_obj,minOffsetX),HX_HCSTRING("minOffsetX","\xf3","\x55","\x1c","\x9d")},
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(int)offsetof(BitmapGlyphCollection_obj,glyphMap),HX_HCSTRING("glyphMap","\x50","\x98","\x62","\xb1")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(BitmapGlyphCollection_obj,glyphs),HX_HCSTRING("glyphs","\x47","\xf9","\x58","\xae")},
	{hx::fsInt,(int)offsetof(BitmapGlyphCollection_obj,color),HX_HCSTRING("color","\x63","\x71","\x5c","\x4a")},
	{hx::fsFloat,(int)offsetof(BitmapGlyphCollection_obj,scale),HX_HCSTRING("scale","\x8a","\xce","\xce","\x78")},
	{hx::fsFloat,(int)offsetof(BitmapGlyphCollection_obj,spaceWidth),HX_HCSTRING("spaceWidth","\x60","\x8b","\x97","\x2b")},
	{hx::fsObject /*::haxegon::bitmapFont::BitmapFont*/ ,(int)offsetof(BitmapGlyphCollection_obj,font),HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *BitmapGlyphCollection_obj_sStaticStorageInfo = 0;
#endif

static ::String BitmapGlyphCollection_obj_sMemberFields[] = {
	HX_HCSTRING("minOffsetX","\xf3","\x55","\x1c","\x9d"),
	HX_HCSTRING("glyphMap","\x50","\x98","\x62","\xb1"),
	HX_HCSTRING("glyphs","\x47","\xf9","\x58","\xae"),
	HX_HCSTRING("color","\x63","\x71","\x5c","\x4a"),
	HX_HCSTRING("scale","\x8a","\xce","\xce","\x78"),
	HX_HCSTRING("spaceWidth","\x60","\x8b","\x97","\x2b"),
	HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"),
	HX_HCSTRING("prepareGlyphs","\x2e","\x5e","\x9f","\x74"),
	HX_HCSTRING("dispose","\x9f","\x80","\x4c","\xbb"),
	::String(null()) };

static void BitmapGlyphCollection_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(BitmapGlyphCollection_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void BitmapGlyphCollection_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(BitmapGlyphCollection_obj::__mClass,"__mClass");
};

#endif

hx::Class BitmapGlyphCollection_obj::__mClass;

void BitmapGlyphCollection_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.bitmapFont.BitmapGlyphCollection","\x19","\xe8","\xb1","\x6a");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = BitmapGlyphCollection_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(BitmapGlyphCollection_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< BitmapGlyphCollection_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = BitmapGlyphCollection_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BitmapGlyphCollection_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BitmapGlyphCollection_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxegon
} // end namespace bitmapFont
