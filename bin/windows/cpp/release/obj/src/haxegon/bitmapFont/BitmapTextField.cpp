// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Utf8
#include <haxe/Utf8.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapFont
#include <haxegon/bitmapFont/BitmapFont.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapGlyph
#include <haxegon/bitmapFont/BitmapGlyph.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapGlyphCollection
#include <haxegon/bitmapFont/BitmapGlyphCollection.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapGlyphFrame
#include <haxegon/bitmapFont/BitmapGlyphFrame.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_BitmapTextField
#include <haxegon/bitmapFont/BitmapTextField.h>
#endif
#ifndef INCLUDED_haxegon_bitmapFont_TextBorderStyle
#include <haxegon/bitmapFont/TextBorderStyle.h>
#endif
#ifndef INCLUDED_openfl_display_Bitmap
#include <openfl/display/Bitmap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

namespace haxegon{
namespace bitmapFont{

void BitmapTextField_obj::__construct( ::haxegon::bitmapFont::BitmapFont font,::String __o_text, ::Dynamic pixelSnapping,hx::Null< Bool >  __o_smoothing){
::String text = __o_text.Default(HX_HCSTRING("","\x00","\x00","\x00","\x00"));
Bool smoothing = __o_smoothing.Default(false);
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","new",0x10550f6e,"haxegon.bitmapFont.BitmapTextField.new","haxegon/bitmapFont/BitmapTextField.hx",17,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(font,"font")
            	HX_STACK_ARG(text,"text")
            	HX_STACK_ARG(pixelSnapping,"pixelSnapping")
            	HX_STACK_ARG(smoothing,"smoothing")
HXLINE( 183)		this->_fieldHeight = (int)1;
HXLINE( 182)		this->_fieldWidth = (int)1;
HXLINE( 180)		this->_pendingBorderGlyphsChange = false;
HXLINE( 179)		this->_pendingTextGlyphsChange = true;
HXLINE( 177)		this->_pendingGraphicChange = true;
HXLINE( 176)		this->_pendingTextChange = true;
HXLINE( 174)		this->updateImmediately = true;
HXLINE( 162)		this->size = ((Float)1);
HXLINE( 157)		this->numLines = (int)0;
HXLINE( 152)		this->multiLine = true;
HXLINE( 147)		this->backgroundColor = (int)0;
HXLINE( 142)		this->background = false;
HXLINE( 131)		this->borderQuality = ((Float)0);
HXLINE( 124)		this->borderSize = ((Float)1);
HXLINE( 119)		this->borderColor = (int)-16777216;
HXLINE( 114)		this->borderStyle = ::haxegon::bitmapFont::TextBorderStyle_obj::NONE_dyn();
HXLINE( 109)		this->useTextColor = false;
HXLINE( 104)		this->textColor = (int)-1;
HXLINE(  99)		this->_tabSpaces = HX_("    ",00,38,3f,15);
HXLINE(  98)		this->numSpacesInTab = (int)4;
HXLINE(  78)		this->padding = (int)0;
HXLINE(  73)		this->autoSize = true;
HXLINE(  67)		this->wrapByWord = true;
HXLINE(  61)		this->wordWrap = true;
HXLINE(  56)		this->autoUpperCase = false;
HXLINE(  51)		this->letterSpacing = (int)0;
HXLINE(  46)		this->lineSpacing = (int)0;
HXLINE(  41)		this->alignment = HX_("left",07,08,b0,47);
HXLINE(  36)		this->_linesWidth = ::Array_obj< Float >::__new(0);
HXLINE(  32)		this->_lines = ::Array_obj< ::String >::__new(0);
HXLINE(  27)		this->text = HX_("",00,00,00,00);
HXLINE( 211)		super::__construct();
HXLINE( 213)		this->shadowOffset =  ::openfl::geom::Point_obj::__new((int)1,(int)1);
HXLINE( 216)		Bool _hx_tmp = hx::IsNull( pixelSnapping );
HXDLIN( 216)		if (_hx_tmp) {
HXLINE( 216)			pixelSnapping = (int)1;
            		}
            		else {
HXLINE( 216)			pixelSnapping = pixelSnapping;
            		}
HXLINE( 217)		this->_bitmapData =  ::openfl::display::BitmapData_obj::__new(this->_fieldWidth,this->_fieldHeight,true,(int)0);
HXLINE( 218)		this->_bitmap =  ::openfl::display::Bitmap_obj::__new(this->_bitmapData,pixelSnapping,smoothing);
HXLINE( 219)		this->_bitmap->smoothing = false;
HXLINE( 220)		this->addChild(this->_bitmap);
HXLINE( 221)		this->_point =  ::openfl::geom::Point_obj::__new(null(),null());
HXLINE( 226)		Bool _hx_tmp1 = hx::IsNull( font );
HXDLIN( 226)		if (_hx_tmp1) {
HXLINE( 228)			font = ::haxegon::bitmapFont::BitmapFont_obj::getDefaultFont();
            		}
HXLINE( 231)		this->set_font(font);
HXLINE( 232)		this->set_text(text);
HXLINE( 233)		this->set_smoothing(smoothing);
            	}

Dynamic BitmapTextField_obj::__CreateEmpty() { return new BitmapTextField_obj; }

hx::ObjectPtr< BitmapTextField_obj > BitmapTextField_obj::__new( ::haxegon::bitmapFont::BitmapFont font,::String __o_text, ::Dynamic pixelSnapping,hx::Null< Bool >  __o_smoothing)
{
	hx::ObjectPtr< BitmapTextField_obj > _hx_result = new BitmapTextField_obj();
	_hx_result->__construct(font,__o_text,pixelSnapping,__o_smoothing);
	return _hx_result;
}

Dynamic BitmapTextField_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< BitmapTextField_obj > _hx_result = new BitmapTextField_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

void BitmapTextField_obj::dispose(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","dispose",0xadf55ead,"haxegon.bitmapFont.BitmapTextField.dispose","haxegon/bitmapFont/BitmapTextField.hx",240,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 241)		this->set_updateImmediately(false);
HXLINE( 243)		this->set_font(null());
HXLINE( 244)		this->set_text(null());
HXLINE( 245)		this->_lines = null();
HXLINE( 246)		this->_linesWidth = null();
HXLINE( 247)		this->shadowOffset = null();
HXLINE( 250)		this->_point = null();
HXLINE( 252)		Bool _hx_tmp = hx::IsNotNull( this->textGlyphs );
HXDLIN( 252)		if (_hx_tmp) {
HXLINE( 254)			this->textGlyphs->dispose();
            		}
HXLINE( 256)		this->textGlyphs = null();
HXLINE( 258)		Bool _hx_tmp1 = hx::IsNotNull( this->borderGlyphs );
HXDLIN( 258)		if (_hx_tmp1) {
HXLINE( 260)			this->borderGlyphs->dispose();
            		}
HXLINE( 262)		this->borderGlyphs = null();
HXLINE( 264)		Bool _hx_tmp2 = hx::IsNotNull( this->_bitmap );
HXDLIN( 264)		if (_hx_tmp2) {
HXLINE( 266)			this->removeChild(this->_bitmap);
            		}
HXLINE( 268)		this->_bitmap = null();
HXLINE( 270)		Bool _hx_tmp3 = hx::IsNotNull( this->_bitmapData );
HXDLIN( 270)		if (_hx_tmp3) {
HXLINE( 272)			this->_bitmapData->dispose();
            		}
HXLINE( 274)		this->_bitmapData = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,dispose,(void))

void BitmapTextField_obj::forceGraphicUpdate(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","forceGraphicUpdate",0x9f332a98,"haxegon.bitmapFont.BitmapTextField.forceGraphicUpdate","haxegon/bitmapFont/BitmapTextField.hx",284,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 285)		this->_pendingGraphicChange = true;
HXLINE( 286)		{
HXLINE( 286)			Bool _hx_tmp = this->_pendingTextGlyphsChange;
HXDLIN( 286)			if (_hx_tmp) {
HXLINE( 286)				this->updateTextGlyphs();
            			}
HXDLIN( 286)			Bool _hx_tmp1 = this->_pendingBorderGlyphsChange;
HXDLIN( 286)			if (_hx_tmp1) {
HXLINE( 286)				this->updateBorderGlyphs();
            			}
HXDLIN( 286)			Bool _hx_tmp2 = this->_pendingTextChange;
HXDLIN( 286)			if (_hx_tmp2) {
HXLINE( 286)				this->updateText();
HXDLIN( 286)				this->_pendingGraphicChange = true;
            			}
HXDLIN( 286)			Bool _hx_tmp3 = this->_pendingGraphicChange;
HXDLIN( 286)			if (_hx_tmp3) {
HXLINE( 286)				this->updateGraphic();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,forceGraphicUpdate,(void))

void BitmapTextField_obj::checkImmediateChanges(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","checkImmediateChanges",0x13143488,"haxegon.bitmapFont.BitmapTextField.checkImmediateChanges","haxegon/bitmapFont/BitmapTextField.hx",291,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 291)		Bool _hx_tmp = this->updateImmediately;
HXDLIN( 291)		if (_hx_tmp) {
HXLINE( 293)			Bool _hx_tmp1 = this->_pendingTextGlyphsChange;
HXDLIN( 293)			if (_hx_tmp1) {
HXLINE( 293)				this->updateTextGlyphs();
            			}
HXDLIN( 293)			Bool _hx_tmp2 = this->_pendingBorderGlyphsChange;
HXDLIN( 293)			if (_hx_tmp2) {
HXLINE( 293)				this->updateBorderGlyphs();
            			}
HXDLIN( 293)			Bool _hx_tmp3 = this->_pendingTextChange;
HXDLIN( 293)			if (_hx_tmp3) {
HXLINE( 293)				this->updateText();
HXDLIN( 293)				this->_pendingGraphicChange = true;
            			}
HXDLIN( 293)			Bool _hx_tmp4 = this->_pendingGraphicChange;
HXDLIN( 293)			if (_hx_tmp4) {
HXLINE( 293)				this->updateGraphic();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,checkImmediateChanges,(void))

void BitmapTextField_obj::checkPendingChanges(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","checkPendingChanges",0x8198bf62,"haxegon.bitmapFont.BitmapTextField.checkPendingChanges","haxegon/bitmapFont/BitmapTextField.hx",298,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 299)		Bool _hx_tmp = this->_pendingTextGlyphsChange;
HXDLIN( 299)		if (_hx_tmp) {
HXLINE( 301)			this->updateTextGlyphs();
            		}
HXLINE( 304)		Bool _hx_tmp1 = this->_pendingBorderGlyphsChange;
HXDLIN( 304)		if (_hx_tmp1) {
HXLINE( 306)			this->updateBorderGlyphs();
            		}
HXLINE( 309)		Bool _hx_tmp2 = this->_pendingTextChange;
HXDLIN( 309)		if (_hx_tmp2) {
HXLINE( 311)			this->updateText();
HXLINE( 312)			this->_pendingGraphicChange = true;
            		}
HXLINE( 315)		Bool _hx_tmp3 = this->_pendingGraphicChange;
HXDLIN( 315)		if (_hx_tmp3) {
HXLINE( 317)			this->updateGraphic();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,checkPendingChanges,(void))

Int BitmapTextField_obj::set_textColor(Int value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_textColor",0x2d8393e7,"haxegon.bitmapFont.BitmapTextField.set_textColor","haxegon/bitmapFont/BitmapTextField.hx",322,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 323)		Bool _hx_tmp = (this->textColor != value);
HXDLIN( 323)		if (_hx_tmp) {
HXLINE( 325)			this->textColor = value;
HXLINE( 326)			this->_pendingTextGlyphsChange = true;
HXLINE( 327)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN( 327)			if (_hx_tmp1) {
HXLINE( 327)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN( 327)				if (_hx_tmp2) {
HXLINE( 327)					this->updateTextGlyphs();
            				}
HXDLIN( 327)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN( 327)				if (_hx_tmp3) {
HXLINE( 327)					this->updateBorderGlyphs();
            				}
HXDLIN( 327)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN( 327)				if (_hx_tmp4) {
HXLINE( 327)					this->updateText();
HXDLIN( 327)					this->_pendingGraphicChange = true;
            				}
HXDLIN( 327)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN( 327)				if (_hx_tmp5) {
HXLINE( 327)					this->updateGraphic();
            				}
            			}
            		}
HXLINE( 330)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_textColor,return )

Bool BitmapTextField_obj::set_useTextColor(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_useTextColor",0x3e243e5e,"haxegon.bitmapFont.BitmapTextField.set_useTextColor","haxegon/bitmapFont/BitmapTextField.hx",334,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 335)		Bool _hx_tmp = (this->useTextColor != value);
HXDLIN( 335)		if (_hx_tmp) {
HXLINE( 337)			this->useTextColor = value;
HXLINE( 338)			this->_pendingTextGlyphsChange = true;
HXLINE( 339)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN( 339)			if (_hx_tmp1) {
HXLINE( 339)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN( 339)				if (_hx_tmp2) {
HXLINE( 339)					this->updateTextGlyphs();
            				}
HXDLIN( 339)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN( 339)				if (_hx_tmp3) {
HXLINE( 339)					this->updateBorderGlyphs();
            				}
HXDLIN( 339)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN( 339)				if (_hx_tmp4) {
HXLINE( 339)					this->updateText();
HXDLIN( 339)					this->_pendingGraphicChange = true;
            				}
HXDLIN( 339)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN( 339)				if (_hx_tmp5) {
HXLINE( 339)					this->updateGraphic();
            				}
            			}
            		}
HXLINE( 342)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_useTextColor,return )

::String BitmapTextField_obj::set_text(::String value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_text",0xdc2b4fdc,"haxegon.bitmapFont.BitmapTextField.set_text","haxegon/bitmapFont/BitmapTextField.hx",346,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 347)		Bool _hx_tmp;
HXDLIN( 347)		if ((value != this->text)) {
HXLINE( 347)			_hx_tmp = hx::IsNotNull( value );
            		}
            		else {
HXLINE( 347)			_hx_tmp = false;
            		}
HXDLIN( 347)		if (_hx_tmp) {
HXLINE( 349)			this->text = value;
HXLINE( 350)			this->_pendingTextChange = true;
HXLINE( 351)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN( 351)			if (_hx_tmp1) {
HXLINE( 351)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN( 351)				if (_hx_tmp2) {
HXLINE( 351)					this->updateTextGlyphs();
            				}
HXDLIN( 351)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN( 351)				if (_hx_tmp3) {
HXLINE( 351)					this->updateBorderGlyphs();
            				}
HXDLIN( 351)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN( 351)				if (_hx_tmp4) {
HXLINE( 351)					this->updateText();
HXDLIN( 351)					this->_pendingGraphicChange = true;
            				}
HXDLIN( 351)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN( 351)				if (_hx_tmp5) {
HXLINE( 351)					this->updateGraphic();
            				}
            			}
            		}
HXLINE( 354)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_text,return )

void BitmapTextField_obj::updateText(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","updateText",0xf2a59608,"haxegon.bitmapFont.BitmapTextField.updateText","haxegon/bitmapFont/BitmapTextField.hx",358,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 359)		HX_VAR( ::String,tmp);
HXDLIN( 359)		Bool _hx_tmp = this->autoUpperCase;
HXDLIN( 359)		if (_hx_tmp) {
HXLINE( 359)			tmp = this->text.toUpperCase();
            		}
            		else {
HXLINE( 359)			tmp = this->text;
            		}
HXLINE( 361)		this->_lines = tmp.split(HX_("\n",0a,00,00,00));
HXLINE( 363)		Bool _hx_tmp1 = !(this->autoSize);
HXDLIN( 363)		if (_hx_tmp1) {
HXLINE( 365)			Bool _hx_tmp2 = this->wordWrap;
HXDLIN( 365)			if (_hx_tmp2) {
HXLINE( 367)				this->wrap();
            			}
            			else {
HXLINE( 371)				this->cutLines();
            			}
            		}
HXLINE( 375)		Bool _hx_tmp3 = !(this->multiLine);
HXDLIN( 375)		if (_hx_tmp3) {
HXLINE( 377)			::String _hx_tmp4 = this->_lines->__get((int)0);
HXDLIN( 377)			this->_lines = ::Array_obj< ::String >::__new(1)->init(0,_hx_tmp4);
            		}
HXLINE( 380)		this->_pendingTextChange = false;
HXLINE( 381)		this->_pendingGraphicChange = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,updateText,(void))

void BitmapTextField_obj::computeTextSize(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","computeTextSize",0xa3ba62b3,"haxegon.bitmapFont.BitmapTextField.computeTextSize","haxegon/bitmapFont/BitmapTextField.hx",388,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 389)		HX_VARI( Int,txtWidth) = ::Math_obj::ceil(this->_fieldWidth);
HXLINE( 390)		Float _hx_tmp = this->get_textHeight();
HXDLIN( 390)		Int _hx_tmp1 = ::Math_obj::ceil(_hx_tmp);
HXDLIN( 390)		HX_VARI( Int,txtHeight) = (_hx_tmp1 + ((int)2 * this->padding));
HXLINE( 392)		Float _hx_tmp2 = this->get_textWidth();
HXDLIN( 392)		HX_VARI( Int,tw) = ::Math_obj::ceil(_hx_tmp2);
HXLINE( 394)		Bool _hx_tmp3 = this->autoSize;
HXDLIN( 394)		if (_hx_tmp3) {
HXLINE( 396)			txtWidth = (tw + ((int)2 * this->padding));
            		}
            		else {
HXLINE( 400)			txtWidth = ::Math_obj::ceil(this->_fieldWidth);
            		}
HXLINE( 403)		Int _hx_tmp4;
HXDLIN( 403)		if ((txtWidth == (int)0)) {
HXLINE( 403)			_hx_tmp4 = (int)1;
            		}
            		else {
HXLINE( 403)			_hx_tmp4 = txtWidth;
            		}
HXDLIN( 403)		this->_fieldWidth = _hx_tmp4;
HXLINE( 404)		Int _hx_tmp5;
HXDLIN( 404)		if ((txtHeight == (int)0)) {
HXLINE( 404)			_hx_tmp5 = (int)1;
            		}
            		else {
HXLINE( 404)			_hx_tmp5 = txtHeight;
            		}
HXDLIN( 404)		this->_fieldHeight = _hx_tmp5;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,computeTextSize,(void))

Float BitmapTextField_obj::getLineWidth(Int lineIndex){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","getLineWidth",0x6025c52e,"haxegon.bitmapFont.BitmapTextField.getLineWidth","haxegon/bitmapFont/BitmapTextField.hx",414,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(lineIndex,"lineIndex")
HXLINE( 415)		Bool _hx_tmp;
HXDLIN( 415)		if ((lineIndex >= (int)0)) {
HXLINE( 415)			_hx_tmp = (lineIndex >= this->_lines->length);
            		}
            		else {
HXLINE( 415)			_hx_tmp = true;
            		}
HXDLIN( 415)		if (_hx_tmp) {
HXLINE( 417)			return (int)0;
            		}
HXLINE( 420)		::String _hx_tmp1 = this->_lines->__get(lineIndex);
HXDLIN( 420)		return this->getStringWidth(_hx_tmp1,null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,getLineWidth,return )

Float BitmapTextField_obj::getStringWidth(::String str,hx::Null< Bool >  __o_fordrawing){
Bool fordrawing = __o_fordrawing.Default(true);
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","getStringWidth",0x6f14da31,"haxegon.bitmapFont.BitmapTextField.getStringWidth","haxegon/bitmapFont/BitmapTextField.hx",430,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(str,"str")
            	HX_STACK_ARG(fordrawing,"fordrawing")
HXLINE( 431)		Float _hx_tmp = (this->font->spaceWidth * this->size);
HXDLIN( 431)		HX_VARI( Float,spaceWidth) = ::Math_obj::ceil(_hx_tmp);
HXLINE( 432)		Float _hx_tmp1 = (spaceWidth * this->numSpacesInTab);
HXDLIN( 432)		HX_VARI( Float,tabWidth) = ::Math_obj::ceil(_hx_tmp1);
HXLINE( 434)		HX_VARI( Int,lineLength) = ::haxe::Utf8_obj::length(str);
HXLINE( 435)		Float _hx_tmp2 = ::Math_obj::abs(this->font->minOffsetX);
HXDLIN( 435)		Float _hx_tmp3 = (_hx_tmp2 * this->size);
HXDLIN( 435)		HX_VARI( Float,lineWidth) = ::Math_obj::ceil(_hx_tmp3);
HXLINE( 436)		if (!(fordrawing)) {
HXLINE( 436)			lineWidth = (int)0;
            		}
HXLINE( 438)		HX_VAR( Int,charCode);
HXLINE( 439)		HX_VARI( Float,charWidth) = (int)0;
HXLINE( 441)		HX_VARI( Int,widthPlusOffset) = (int)0;
HXLINE( 442)		HX_VAR(  ::haxegon::bitmapFont::BitmapGlyphFrame,glyphFrame);
HXLINE( 444)		{
HXLINE( 444)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 444)			while((_g1 < lineLength)){
HXLINE( 444)				HX_VARI( Int,c) = _g1++;
HXLINE( 446)				charCode = ::haxe::Utf8_obj::charCodeAt(str,c);
HXLINE( 448)				if ((charCode == (int)32)) {
HXLINE( 450)					charWidth = spaceWidth;
            				}
            				else {
HXLINE( 452)					if ((charCode == (int)9)) {
HXLINE( 454)						charWidth = tabWidth;
            					}
            					else {
HXLINE( 458)						Bool _hx_tmp4 = this->font->glyphs->exists(charCode);
HXDLIN( 458)						if (_hx_tmp4) {
HXLINE( 460)							glyphFrame = this->font->glyphs->get(charCode).StaticCast<  ::haxegon::bitmapFont::BitmapGlyphFrame >();
HXLINE( 461)							Float _hx_tmp5 = (glyphFrame->xadvance * this->size);
HXDLIN( 461)							charWidth = ::Math_obj::ceil(_hx_tmp5);
HXLINE( 463)							if ((c == (lineLength - (int)1))) {
HXLINE( 465)								Int _hx_tmp6 = glyphFrame->xoffset;
HXDLIN( 465)								Int _hx_tmp7 = (_hx_tmp6 + glyphFrame->get_bitmap()->width);
HXDLIN( 465)								Float _hx_tmp8 = (_hx_tmp7 * this->size);
HXDLIN( 465)								widthPlusOffset = ::Math_obj::ceil(_hx_tmp8);
HXLINE( 466)								Bool _hx_tmp9 = (widthPlusOffset > charWidth);
HXDLIN( 466)								if (_hx_tmp9) {
HXLINE( 468)									charWidth = widthPlusOffset;
            								}
            							}
            						}
            						else {
HXLINE( 474)							charWidth = (int)0;
            						}
            					}
            				}
HXLINE( 478)				hx::AddEq(lineWidth,(charWidth + this->letterSpacing));
            			}
            		}
HXLINE( 481)		if ((lineLength > (int)0)) {
HXLINE( 483)			hx::SubEq(lineWidth,this->letterSpacing);
            		}
HXLINE( 486)		return lineWidth;
            	}


HX_DEFINE_DYNAMIC_FUNC2(BitmapTextField_obj,getStringWidth,return )

void BitmapTextField_obj::cutLines(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","cutLines",0xea7fff4f,"haxegon.bitmapFont.BitmapTextField.cutLines","haxegon/bitmapFont/BitmapTextField.hx",493,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 494)		HX_VARI( ::Array< ::String >,newLines) = ::Array_obj< ::String >::__new(0);
HXLINE( 496)		HX_VAR( Int,lineLength);
HXLINE( 498)		HX_VAR( Int,c);
HXLINE( 500)		HX_VAR( Int,charCode);
HXLINE( 501)		HX_VARI( Float,charWidth) = (int)0;
HXLINE( 503)		HX_VAR(  ::haxe::Utf8,subLine);
HXLINE( 504)		HX_VAR( Float,subLineWidth);
HXLINE( 506)		HX_VARI( Float,spaceWidth) = (this->font->spaceWidth * this->size);
HXLINE( 507)		HX_VARI( Float,tabWidth) = (spaceWidth * this->numSpacesInTab);
HXLINE( 509)		Float _hx_tmp = ::Math_obj::abs(this->font->minOffsetX);
HXDLIN( 509)		HX_VARI( Float,startX) = (_hx_tmp * this->size);
HXLINE( 511)		{
HXLINE( 511)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 511)			HX_VARI( ::Array< ::String >,_g1) = this->_lines;
HXDLIN( 511)			while((_g < _g1->length)){
HXLINE( 511)				HX_VARI( ::String,line) = _g1->__get(_g);
HXDLIN( 511)				++_g;
HXLINE( 513)				lineLength = ::haxe::Utf8_obj::length(line);
HXLINE( 514)				subLine =  ::haxe::Utf8_obj::__new(null());
HXLINE( 515)				subLineWidth = startX;
HXLINE( 517)				c = (int)0;
HXLINE( 518)				while((c < lineLength)){
HXLINE( 520)					charCode = ::haxe::Utf8_obj::charCodeAt(line,c);
HXLINE( 522)					if ((charCode == (int)32)) {
HXLINE( 524)						charWidth = spaceWidth;
            					}
            					else {
HXLINE( 526)						if ((charCode == (int)9)) {
HXLINE( 528)							charWidth = tabWidth;
            						}
            						else {
HXLINE( 532)							Bool _hx_tmp1 = this->font->glyphs->exists(charCode);
HXDLIN( 532)							if (_hx_tmp1) {
HXLINE( 532)								charWidth = (this->font->glyphs->get(charCode).StaticCast<  ::haxegon::bitmapFont::BitmapGlyphFrame >()->xadvance * this->size);
            							}
            							else {
HXLINE( 532)								charWidth = (int)0;
            							}
            						}
            					}
HXLINE( 534)					hx::AddEq(charWidth,this->letterSpacing);
HXLINE( 536)					Float _hx_tmp2 = (subLineWidth + charWidth);
HXDLIN( 536)					Int _hx_tmp3 = (this->_fieldWidth - ((int)2 * this->padding));
HXDLIN( 536)					if ((_hx_tmp2 > _hx_tmp3)) {
HXLINE( 538)						subLine->addChar(charCode);
HXLINE( 539)						::String _hx_tmp4 = subLine->toString();
HXDLIN( 539)						newLines->push(_hx_tmp4);
HXLINE( 540)						subLine =  ::haxe::Utf8_obj::__new(null());
HXLINE( 541)						subLineWidth = startX;
HXLINE( 542)						c = lineLength;
            					}
            					else {
HXLINE( 546)						subLine->addChar(charCode);
HXLINE( 547)						hx::AddEq(subLineWidth,charWidth);
            					}
HXLINE( 550)					++c;
            				}
            			}
            		}
HXLINE( 554)		this->_lines = newLines;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,cutLines,(void))

void BitmapTextField_obj::wrap(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","wrap",0x401526fc,"haxegon.bitmapFont.BitmapTextField.wrap","haxegon/bitmapFont/BitmapTextField.hx",562,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 564)		HX_VARI( ::Array< ::String >,newLines) = ::Array_obj< ::String >::__new(0);
HXLINE( 565)		HX_VAR( ::Array< ::String >,words);
HXLINE( 567)		{
HXLINE( 567)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 567)			HX_VARI( ::Array< ::String >,_g1) = this->_lines;
HXDLIN( 567)			while((_g < _g1->length)){
HXLINE( 567)				HX_VARI( ::String,line) = _g1->__get(_g);
HXDLIN( 567)				++_g;
HXLINE( 569)				words = ::Array_obj< ::String >::__new(0);
HXLINE( 571)				this->splitLineIntoWords(line,words);
HXLINE( 573)				Bool _hx_tmp = this->wrapByWord;
HXDLIN( 573)				if (_hx_tmp) {
HXLINE( 575)					this->wrapLineByWord(words,newLines);
            				}
            				else {
HXLINE( 579)					this->wrapLineByCharacter(words,newLines);
            				}
            			}
            		}
HXLINE( 583)		this->_lines = newLines;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,wrap,(void))

void BitmapTextField_obj::splitLineIntoWords(::String line,::Array< ::String > words){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","splitLineIntoWords",0xfe89258d,"haxegon.bitmapFont.BitmapTextField.splitLineIntoWords","haxegon/bitmapFont/BitmapTextField.hx",593,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(line,"line")
            	HX_STACK_ARG(words,"words")
HXLINE( 594)		HX_VARI( ::String,word) = HX_("",00,00,00,00);
HXLINE( 595)		HX_VARI(  ::haxe::Utf8,wordUtf8) =  ::haxe::Utf8_obj::__new(null());
HXLINE( 596)		HX_VARI( Bool,isSpaceWord) = false;
HXLINE( 597)		HX_VARI( Int,lineLength) = ::haxe::Utf8_obj::length(line);
HXLINE( 599)		HX_VARI( Int,hyphenCode) = ::haxe::Utf8_obj::charCodeAt(HX_("-",2d,00,00,00),(int)0);
HXLINE( 601)		HX_VARI( Int,c) = (int)0;
HXLINE( 602)		HX_VAR( Int,charCode);
HXLINE( 603)		HX_VAR(  ::haxe::Utf8,charUtf8);
HXLINE( 605)		while((c < lineLength)){
HXLINE( 607)			charCode = ::haxe::Utf8_obj::charCodeAt(line,c);
HXLINE( 608)			word = wordUtf8->toString();
HXLINE( 610)			Bool _hx_tmp;
HXDLIN( 610)			if ((charCode != (int)32)) {
HXLINE( 610)				_hx_tmp = (charCode == (int)9);
            			}
            			else {
HXLINE( 610)				_hx_tmp = true;
            			}
HXDLIN( 610)			if (_hx_tmp) {
HXLINE( 612)				if (!(isSpaceWord)) {
HXLINE( 614)					isSpaceWord = true;
HXLINE( 616)					if ((word != HX_("",00,00,00,00))) {
HXLINE( 618)						words->push(word);
HXLINE( 619)						wordUtf8 =  ::haxe::Utf8_obj::__new(null());
            					}
            				}
HXLINE( 623)				wordUtf8->addChar(charCode);
            			}
            			else {
HXLINE( 625)				if ((charCode == hyphenCode)) {
HXLINE( 627)					Bool _hx_tmp1;
HXDLIN( 627)					if (isSpaceWord) {
HXLINE( 627)						_hx_tmp1 = (word != HX_("",00,00,00,00));
            					}
            					else {
HXLINE( 627)						_hx_tmp1 = false;
            					}
HXDLIN( 627)					if (_hx_tmp1) {
HXLINE( 629)						isSpaceWord = false;
HXLINE( 630)						words->push(word);
HXLINE( 631)						words->push(HX_("-",2d,00,00,00));
            					}
            					else {
HXLINE( 633)						if ((isSpaceWord == false)) {
HXLINE( 635)							charUtf8 =  ::haxe::Utf8_obj::__new(null());
HXLINE( 636)							charUtf8->addChar(charCode);
HXLINE( 637)							::String _hx_tmp2 = charUtf8->toString();
HXDLIN( 637)							words->push((word + _hx_tmp2));
            						}
            					}
HXLINE( 640)					wordUtf8 =  ::haxe::Utf8_obj::__new(null());
            				}
            				else {
HXLINE( 644)					Bool _hx_tmp3;
HXDLIN( 644)					if (isSpaceWord) {
HXLINE( 644)						_hx_tmp3 = (word != HX_("",00,00,00,00));
            					}
            					else {
HXLINE( 644)						_hx_tmp3 = false;
            					}
HXDLIN( 644)					if (_hx_tmp3) {
HXLINE( 646)						isSpaceWord = false;
HXLINE( 647)						words->push(word);
HXLINE( 648)						wordUtf8 =  ::haxe::Utf8_obj::__new(null());
            					}
HXLINE( 651)					wordUtf8->addChar(charCode);
            				}
            			}
HXLINE( 654)			++c;
            		}
HXLINE( 657)		word = wordUtf8->toString();
HXLINE( 658)		if ((word != HX_("",00,00,00,00))) {
HXLINE( 658)			words->push(word);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(BitmapTextField_obj,splitLineIntoWords,(void))

void BitmapTextField_obj::wrapLineByWord(::Array< ::String > words,::Array< ::String > newLines){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","wrapLineByWord",0xcad6f471,"haxegon.bitmapFont.BitmapTextField.wrapLineByWord","haxegon/bitmapFont/BitmapTextField.hx",668,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(words,"words")
            	HX_STACK_ARG(newLines,"newLines")
HXLINE( 669)		HX_VARI( Int,numWords) = words->length;
HXLINE( 670)		HX_VAR( Int,w);
HXLINE( 671)		HX_VAR( ::String,word);
HXLINE( 672)		HX_VAR( Float,wordWidth);
HXLINE( 673)		HX_VAR( Int,wordLength);
HXLINE( 675)		HX_VARI( Bool,isSpaceWord) = false;
HXLINE( 677)		HX_VAR( Int,charCode);
HXLINE( 678)		HX_VARI( Float,charWidth) = (int)0;
HXLINE( 680)		HX_VARI( ::Array< ::String >,subLines) = ::Array_obj< ::String >::__new(0);
HXLINE( 682)		HX_VAR( ::String,subLine);
HXLINE( 683)		HX_VAR( Float,subLineWidth);
HXLINE( 685)		HX_VARI( Float,spaceWidth) = (this->font->spaceWidth * this->size);
HXLINE( 686)		HX_VARI( Float,tabWidth) = (spaceWidth * this->numSpacesInTab);
HXLINE( 688)		Float _hx_tmp = ::Math_obj::abs(this->font->minOffsetX);
HXDLIN( 688)		HX_VARI( Float,startX) = (_hx_tmp * this->size);
HXLINE( 690)		if ((numWords > (int)0)) {
HXLINE( 692)			w = (int)0;
HXLINE( 693)			subLineWidth = startX;
HXLINE( 694)			subLine = HX_("",00,00,00,00);
HXLINE( 696)			while((w < numWords)){
HXLINE( 698)				wordWidth = (int)0;
HXLINE( 699)				word = words->__get(w);
HXLINE( 700)				wordLength = ::haxe::Utf8_obj::length(word);
HXLINE( 702)				charCode = ::haxe::Utf8_obj::charCodeAt(word,(int)0);
HXLINE( 703)				if ((charCode != (int)32)) {
HXLINE( 703)					isSpaceWord = (charCode == (int)9);
            				}
            				else {
HXLINE( 703)					isSpaceWord = true;
            				}
HXLINE( 705)				{
HXLINE( 705)					HX_VARI( Int,_g1) = (int)0;
HXDLIN( 705)					while((_g1 < wordLength)){
HXLINE( 705)						HX_VARI( Int,c) = _g1++;
HXLINE( 707)						charCode = ::haxe::Utf8_obj::charCodeAt(word,c);
HXLINE( 709)						if ((charCode == (int)32)) {
HXLINE( 711)							charWidth = spaceWidth;
            						}
            						else {
HXLINE( 713)							if ((charCode == (int)9)) {
HXLINE( 715)								charWidth = tabWidth;
            							}
            							else {
HXLINE( 719)								Bool _hx_tmp1 = this->font->glyphs->exists(charCode);
HXDLIN( 719)								if (_hx_tmp1) {
HXLINE( 719)									charWidth = (this->font->glyphs->get(charCode).StaticCast<  ::haxegon::bitmapFont::BitmapGlyphFrame >()->xadvance * this->size);
            								}
            								else {
HXLINE( 719)									charWidth = (int)0;
            								}
            							}
            						}
HXLINE( 722)						hx::AddEq(wordWidth,charWidth);
            					}
            				}
HXLINE( 725)				hx::AddEq(wordWidth,((wordLength - (int)1) * this->letterSpacing));
HXLINE( 727)				Float _hx_tmp2 = (subLineWidth + wordWidth);
HXDLIN( 727)				Int _hx_tmp3 = (this->_fieldWidth - ((int)2 * this->padding));
HXDLIN( 727)				if ((_hx_tmp2 > _hx_tmp3)) {
HXLINE( 729)					if (isSpaceWord) {
HXLINE( 731)						subLines->push(subLine);
HXLINE( 732)						subLine = HX_("",00,00,00,00);
HXLINE( 733)						subLineWidth = startX;
            					}
            					else {
HXLINE( 735)						if ((subLine != HX_("",00,00,00,00))) {
HXLINE( 737)							subLines->push(subLine);
HXLINE( 738)							subLine = word;
HXLINE( 739)							subLineWidth = ((startX + wordWidth) + this->letterSpacing);
            						}
            						else {
HXLINE( 743)							subLine = word;
HXLINE( 744)							subLineWidth = ((startX + wordWidth) + this->letterSpacing);
            						}
            					}
            				}
            				else {
HXLINE( 749)					hx::AddEq(subLine,word);
HXLINE( 750)					hx::AddEq(subLineWidth,(wordWidth + this->letterSpacing));
            				}
HXLINE( 753)				++w;
            			}
HXLINE( 756)			if ((subLine != HX_("",00,00,00,00))) {
HXLINE( 758)				subLines->push(subLine);
            			}
            		}
HXLINE( 762)		{
HXLINE( 762)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 762)			while((_g < subLines->length)){
HXLINE( 762)				HX_VARI( ::String,subline) = subLines->__get(_g);
HXDLIN( 762)				++_g;
HXLINE( 764)				newLines->push(subline);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(BitmapTextField_obj,wrapLineByWord,(void))

void BitmapTextField_obj::wrapLineByCharacter(::Array< ::String > words,::Array< ::String > newLines){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","wrapLineByCharacter",0x5643eba2,"haxegon.bitmapFont.BitmapTextField.wrapLineByCharacter","haxegon/bitmapFont/BitmapTextField.hx",775,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(words,"words")
            	HX_STACK_ARG(newLines,"newLines")
HXLINE( 776)		HX_VARI( Int,numWords) = words->length;
HXLINE( 777)		HX_VAR( Int,w);
HXLINE( 778)		HX_VAR( ::String,word);
HXLINE( 779)		HX_VAR( Int,wordLength);
HXLINE( 781)		HX_VARI( Bool,isSpaceWord) = false;
HXLINE( 784)		HX_VAR( Int,charCode);
HXLINE( 785)		HX_VAR( Int,c);
HXLINE( 786)		HX_VARI( Float,charWidth) = (int)0;
HXLINE( 788)		HX_VARI( ::Array< ::String >,subLines) = ::Array_obj< ::String >::__new(0);
HXLINE( 790)		HX_VAR( ::String,subLine);
HXLINE( 791)		HX_VAR(  ::haxe::Utf8,subLineUtf8);
HXLINE( 792)		HX_VAR( Float,subLineWidth);
HXLINE( 794)		HX_VARI( Float,spaceWidth) = (this->font->spaceWidth * this->size);
HXLINE( 795)		HX_VARI( Float,tabWidth) = (spaceWidth * this->numSpacesInTab);
HXLINE( 797)		Float _hx_tmp = ::Math_obj::abs(this->font->minOffsetX);
HXDLIN( 797)		HX_VARI( Float,startX) = (_hx_tmp * this->size);
HXLINE( 799)		if ((numWords > (int)0)) {
HXLINE( 801)			w = (int)0;
HXLINE( 802)			subLineWidth = startX;
HXLINE( 803)			subLineUtf8 =  ::haxe::Utf8_obj::__new(null());
HXLINE( 805)			while((w < numWords)){
HXLINE( 807)				word = words->__get(w);
HXLINE( 808)				wordLength = ::haxe::Utf8_obj::length(word);
HXLINE( 810)				charCode = ::haxe::Utf8_obj::charCodeAt(word,(int)0);
HXLINE( 811)				if ((charCode != (int)32)) {
HXLINE( 811)					isSpaceWord = (charCode == (int)9);
            				}
            				else {
HXLINE( 811)					isSpaceWord = true;
            				}
HXLINE( 813)				c = (int)0;
HXLINE( 815)				while((c < wordLength)){
HXLINE( 817)					charCode = ::haxe::Utf8_obj::charCodeAt(word,c);
HXLINE( 819)					if ((charCode == (int)32)) {
HXLINE( 821)						charWidth = spaceWidth;
            					}
            					else {
HXLINE( 823)						if ((charCode == (int)9)) {
HXLINE( 825)							charWidth = tabWidth;
            						}
            						else {
HXLINE( 829)							Bool _hx_tmp1 = this->font->glyphs->exists(charCode);
HXDLIN( 829)							if (_hx_tmp1) {
HXLINE( 829)								charWidth = (this->font->glyphs->get(charCode).StaticCast<  ::haxegon::bitmapFont::BitmapGlyphFrame >()->xadvance * this->size);
            							}
            							else {
HXLINE( 829)								charWidth = (int)0;
            							}
            						}
            					}
HXLINE( 832)					Float _hx_tmp2 = (subLineWidth + charWidth);
HXDLIN( 832)					Int _hx_tmp3 = (this->_fieldWidth - ((int)2 * this->padding));
HXDLIN( 832)					if ((_hx_tmp2 > _hx_tmp3)) {
HXLINE( 834)						subLine = subLineUtf8->toString();
HXLINE( 836)						if (isSpaceWord) {
HXLINE( 838)							subLines->push(subLine);
HXLINE( 839)							c = wordLength;
HXLINE( 840)							subLineUtf8 =  ::haxe::Utf8_obj::__new(null());
HXLINE( 841)							subLineWidth = startX;
            						}
            						else {
HXLINE( 843)							if ((subLine != HX_("",00,00,00,00))) {
HXLINE( 845)								subLines->push(subLine);
HXLINE( 846)								subLineUtf8 =  ::haxe::Utf8_obj::__new(null());
HXLINE( 847)								subLineUtf8->addChar(charCode);
HXLINE( 848)								subLineWidth = ((startX + charWidth) + this->letterSpacing);
            							}
            							else {
HXLINE( 852)								subLineUtf8 =  ::haxe::Utf8_obj::__new(null());
HXLINE( 853)								subLineUtf8->addChar(charCode);
HXLINE( 854)								subLineWidth = ((startX + charWidth) + this->letterSpacing);
            							}
            						}
            					}
            					else {
HXLINE( 859)						subLineUtf8->addChar(charCode);
HXLINE( 860)						hx::AddEq(subLineWidth,(charWidth + this->letterSpacing));
            					}
HXLINE( 863)					++c;
            				}
HXLINE( 866)				++w;
            			}
HXLINE( 869)			subLine = subLineUtf8->toString();
HXLINE( 871)			if ((subLine != HX_("",00,00,00,00))) {
HXLINE( 873)				subLines->push(subLine);
            			}
            		}
HXLINE( 877)		{
HXLINE( 877)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 877)			while((_g < subLines->length)){
HXLINE( 877)				HX_VARI( ::String,subline) = subLines->__get(_g);
HXDLIN( 877)				++_g;
HXLINE( 879)				newLines->push(subline);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(BitmapTextField_obj,wrapLineByCharacter,(void))

void BitmapTextField_obj::updateGraphic(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","updateGraphic",0x83459c2d,"haxegon.bitmapFont.BitmapTextField.updateGraphic","haxegon/bitmapFont/BitmapTextField.hx",887,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE( 888)		this->computeTextSize();
HXLINE( 889)		HX_VAR( Int,colorForFill);
HXDLIN( 889)		if (this->background) {
HXLINE( 889)			colorForFill = this->backgroundColor;
            		}
            		else {
HXLINE( 889)			colorForFill = (int)0;
            		}
HXLINE( 891)		Bool _hx_tmp;
HXDLIN( 891)		Bool _hx_tmp1 = hx::IsNotNull( this->_bitmapData );
HXDLIN( 891)		if (_hx_tmp1) {
HXLINE( 891)			if ((this->_fieldWidth == this->_bitmapData->width)) {
HXLINE( 891)				_hx_tmp = (this->_fieldHeight != this->_bitmapData->height);
            			}
            			else {
HXLINE( 891)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 891)			_hx_tmp = true;
            		}
HXDLIN( 891)		if (_hx_tmp) {
HXLINE( 893)			Bool _hx_tmp2 = hx::IsNotNull( this->_bitmapData );
HXDLIN( 893)			if (_hx_tmp2) {
HXLINE( 895)				this->_bitmapData->dispose();
            			}
HXLINE( 898)			this->_bitmapData =  ::openfl::display::BitmapData_obj::__new(this->_fieldWidth,this->_fieldHeight,true,colorForFill);
HXLINE( 899)			this->_bitmap->set_bitmapData(this->_bitmapData);
HXLINE( 900)			this->_bitmap->smoothing = this->smoothing;
            		}
            		else {
HXLINE( 904)			this->_bitmapData->fillRect(this->_bitmapData->rect,colorForFill);
            		}
HXLINE( 922)		Bool _hx_tmp3 = (this->size > (int)0);
HXDLIN( 922)		if (_hx_tmp3) {
HXLINE( 925)			this->_bitmapData->lock();
HXLINE( 928)			HX_VARI( Int,numLines) = this->_lines->length;
HXLINE( 929)			HX_VAR( ::String,line);
HXLINE( 930)			HX_VAR( Float,lineWidth);
HXLINE( 932)			HX_VAR( Int,ox);
HXDLIN( 932)			HX_VAR( Int,oy);
HXLINE( 934)			Float _hx_tmp4 = (this->borderSize * this->borderQuality);
HXDLIN( 934)			HX_VARI( Int,iterations) = ::Std_obj::_hx_int(_hx_tmp4);
HXLINE( 935)			Bool _hx_tmp5 = (iterations <= (int)0);
HXDLIN( 935)			if (_hx_tmp5) {
HXLINE( 935)				iterations = (int)1;
            			}
            			else {
HXLINE( 935)				iterations = iterations;
            			}
HXLINE( 937)			Float _hx_tmp6 = ((Float)this->borderSize / (Float)iterations);
HXDLIN( 937)			HX_VARI( Int,delta) = ::Std_obj::_hx_int(_hx_tmp6);
HXLINE( 939)			HX_VARI( Int,iterationsX) = (int)1;
HXLINE( 940)			HX_VARI( Int,iterationsY) = (int)1;
HXLINE( 941)			HX_VARI( Int,deltaX) = (int)1;
HXLINE( 942)			HX_VARI( Int,deltaY) = (int)1;
HXLINE( 944)			if (hx::IsEq( this->borderStyle,::haxegon::bitmapFont::TextBorderStyle_obj::SHADOW_dyn() )) {
HXLINE( 946)				Float _hx_tmp7 = ::Math_obj::abs(this->shadowOffset->x);
HXDLIN( 946)				Float _hx_tmp8 = (_hx_tmp7 * this->borderQuality);
HXDLIN( 946)				iterationsX = ::Math_obj::round(_hx_tmp8);
HXLINE( 947)				Bool _hx_tmp9 = (iterationsX <= (int)0);
HXDLIN( 947)				if (_hx_tmp9) {
HXLINE( 947)					iterationsX = (int)1;
            				}
            				else {
HXLINE( 947)					iterationsX = iterationsX;
            				}
HXLINE( 949)				Float _hx_tmp10 = ::Math_obj::abs(this->shadowOffset->y);
HXDLIN( 949)				Float _hx_tmp11 = (_hx_tmp10 * this->borderQuality);
HXDLIN( 949)				iterationsY = ::Math_obj::round(_hx_tmp11);
HXLINE( 950)				Bool _hx_tmp12 = (iterationsY <= (int)0);
HXDLIN( 950)				if (_hx_tmp12) {
HXLINE( 950)					iterationsY = (int)1;
            				}
            				else {
HXLINE( 950)					iterationsY = iterationsY;
            				}
HXLINE( 952)				Float _hx_tmp13 = ((Float)this->shadowOffset->x / (Float)iterationsX);
HXDLIN( 952)				deltaX = ::Math_obj::round(_hx_tmp13);
HXLINE( 953)				Float _hx_tmp14 = ((Float)this->shadowOffset->y / (Float)iterationsY);
HXDLIN( 953)				deltaY = ::Math_obj::round(_hx_tmp14);
            			}
HXLINE( 957)			{
HXLINE( 957)				HX_VARI( Int,_g1) = (int)0;
HXDLIN( 957)				while((_g1 < numLines)){
HXLINE( 957)					HX_VARI( Int,i) = _g1++;
HXLINE( 959)					line = this->_lines->__get(i);
HXLINE( 960)					lineWidth = this->_linesWidth->__get(i);
HXLINE( 963)					Float _hx_tmp15 = ::Math_obj::abs(this->font->minOffsetX);
HXDLIN( 963)					Float _hx_tmp16 = (_hx_tmp15 * this->size);
HXDLIN( 963)					ox = ::Std_obj::_hx_int(_hx_tmp16);
HXLINE( 964)					Float _hx_tmp17 = ((this->font->lineHeight * this->size) + this->lineSpacing);
HXDLIN( 964)					Int _hx_tmp18 = ::Std_obj::_hx_int((i * _hx_tmp17));
HXDLIN( 964)					oy = (_hx_tmp18 + this->padding);
HXLINE( 966)					if ((this->alignment == HX_("center",d5,25,db,05))) {
HXLINE( 968)						Float _hx_tmp19 = ((Float)(this->_fieldWidth - lineWidth) / (Float)(int)2);
HXDLIN( 968)						Int _hx_tmp20 = ::Std_obj::_hx_int(_hx_tmp19);
HXDLIN( 968)						hx::AddEq(ox,(_hx_tmp20 - this->padding));
            					}
HXLINE( 970)					if ((this->alignment == HX_("right",dc,0b,64,e9))) {
HXLINE( 972)						Int _hx_tmp21 = this->_fieldWidth;
HXDLIN( 972)						Int _hx_tmp22 = ::Std_obj::_hx_int(lineWidth);
HXDLIN( 972)						hx::AddEq(ox,((_hx_tmp21 - _hx_tmp22) - this->padding));
            					}
            					else {
HXLINE( 976)						hx::AddEq(ox,this->padding);
            					}
HXLINE( 979)					{
HXLINE( 979)						Int _hx_tmp23 = ( ( ::hx::EnumBase)(this->borderStyle) )->_hx_getIndex();
HXDLIN( 979)						switch((int)(_hx_tmp23)){
            							case (int)0: {
            							}
            							break;
            							case (int)1: {
HXLINE( 982)								HX_VARI( Int,_g3) = (int)0;
HXDLIN( 982)								HX_VARI( Int,_g2) = iterationsY;
HXDLIN( 982)								while((_g3 < _g2)){
HXLINE( 982)									HX_VARI( Int,iterY) = _g3++;
HXLINE( 984)									{
HXLINE( 984)										HX_VARI( Int,_g5) = (int)0;
HXDLIN( 984)										HX_VARI( Int,_g4) = iterationsX;
HXDLIN( 984)										while((_g5 < _g4)){
HXLINE( 984)											HX_VARI( Int,iterX) = _g5++;
HXLINE( 987)											this->blitLine(line,this->borderGlyphs,(ox + (deltaX * (iterX + (int)1))),(oy + (deltaY * (iterY + (int)1))));
            										}
            									}
            								}
            							}
            							break;
            							case (int)2: {
HXLINE( 996)								HX_VARI( Int,itd) = (int)0;
HXLINE( 997)								{
HXLINE( 997)									HX_VARI_NAME( Int,_g31,"_g3") = (int)0;
HXDLIN( 997)									HX_VARI_NAME( Int,_g21,"_g2") = iterations;
HXDLIN( 997)									while((_g31 < _g21)){
HXLINE( 997)										HX_VARI( Int,iter) = _g31++;
HXLINE( 999)										itd = (delta * (iter + (int)1));
HXLINE(1002)										this->blitLine(line,this->borderGlyphs,(ox - itd),(oy - itd));
HXLINE(1004)										this->blitLine(line,this->borderGlyphs,ox,(oy - itd));
HXLINE(1006)										this->blitLine(line,this->borderGlyphs,(ox + itd),(oy - itd));
HXLINE(1008)										this->blitLine(line,this->borderGlyphs,(ox - itd),oy);
HXLINE(1010)										this->blitLine(line,this->borderGlyphs,(ox + itd),oy);
HXLINE(1012)										this->blitLine(line,this->borderGlyphs,(ox - itd),(oy + itd));
HXLINE(1014)										this->blitLine(line,this->borderGlyphs,ox,(oy + itd));
HXLINE(1016)										this->blitLine(line,this->borderGlyphs,(ox + itd),(oy + itd));
            									}
            								}
            							}
            							break;
            							case (int)3: {
HXLINE(1040)								HX_VARI_NAME( Int,itd1,"itd") = (int)0;
HXLINE(1041)								{
HXLINE(1041)									HX_VARI_NAME( Int,_g32,"_g3") = (int)0;
HXDLIN(1041)									HX_VARI_NAME( Int,_g22,"_g2") = iterations;
HXDLIN(1041)									while((_g32 < _g22)){
HXLINE(1041)										HX_VARI_NAME( Int,iter1,"iter") = _g32++;
HXLINE(1043)										itd1 = (delta * (iter1 + (int)1));
HXLINE(1046)										this->blitLine(line,this->borderGlyphs,(ox - itd1),(oy - itd1));
HXLINE(1048)										this->blitLine(line,this->borderGlyphs,(ox + itd1),(oy - itd1));
HXLINE(1050)										this->blitLine(line,this->borderGlyphs,(ox - itd1),(oy + itd1));
HXLINE(1052)										this->blitLine(line,this->borderGlyphs,(ox + itd1),(oy + itd1));
            									}
            								}
            							}
            							break;
            						}
            					}
            				}
            			}
HXLINE(1069)			{
HXLINE(1069)				HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN(1069)				while((_g11 < numLines)){
HXLINE(1069)					HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE(1071)					line = this->_lines->__get(i1);
HXLINE(1072)					lineWidth = this->_linesWidth->__get(i1);
HXLINE(1075)					Float _hx_tmp24 = ::Math_obj::abs(this->font->minOffsetX);
HXDLIN(1075)					Float _hx_tmp25 = (_hx_tmp24 * this->size);
HXDLIN(1075)					ox = ::Std_obj::_hx_int(_hx_tmp25);
HXLINE(1076)					Float _hx_tmp26 = ((this->font->lineHeight * this->size) + this->lineSpacing);
HXDLIN(1076)					Int _hx_tmp27 = ::Std_obj::_hx_int((i1 * _hx_tmp26));
HXDLIN(1076)					oy = (_hx_tmp27 + this->padding);
HXLINE(1078)					if ((this->alignment == HX_("center",d5,25,db,05))) {
HXLINE(1080)						Float _hx_tmp28 = ((Float)(this->_fieldWidth - lineWidth) / (Float)(int)2);
HXDLIN(1080)						Int _hx_tmp29 = ::Std_obj::_hx_int(_hx_tmp28);
HXDLIN(1080)						hx::AddEq(ox,(_hx_tmp29 - this->padding));
            					}
HXLINE(1082)					if ((this->alignment == HX_("right",dc,0b,64,e9))) {
HXLINE(1084)						Int _hx_tmp30 = this->_fieldWidth;
HXDLIN(1084)						Int _hx_tmp31 = ::Std_obj::_hx_int(lineWidth);
HXDLIN(1084)						hx::AddEq(ox,((_hx_tmp30 - _hx_tmp31) - this->padding));
            					}
            					else {
HXLINE(1088)						hx::AddEq(ox,this->padding);
            					}
HXLINE(1091)					this->blitLine(line,this->textGlyphs,ox,oy);
            				}
            			}
HXLINE(1094)			this->_bitmapData->unlock(null());
            		}
HXLINE(1097)		this->_pendingGraphicChange = false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,updateGraphic,(void))

void BitmapTextField_obj::blitLine(::String line, ::haxegon::bitmapFont::BitmapGlyphCollection glyphs,Int startX,Int startY){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","blitLine",0xc9f7a8fb,"haxegon.bitmapFont.BitmapTextField.blitLine","haxegon/bitmapFont/BitmapTextField.hx",1102,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(line,"line")
            	HX_STACK_ARG(glyphs,"glyphs")
            	HX_STACK_ARG(startX,"startX")
            	HX_STACK_ARG(startY,"startY")
HXLINE(1103)		Bool _hx_tmp = hx::IsNull( glyphs );
HXDLIN(1103)		if (_hx_tmp) {
HXLINE(1103)			return;
            		}
HXLINE(1105)		HX_VAR(  ::haxegon::bitmapFont::BitmapGlyph,glyph);
HXLINE(1106)		HX_VAR( Int,charCode);
HXLINE(1107)		HX_VARI( Int,curX) = startX;
HXLINE(1110)		Float _hx_tmp1 = (this->font->spaceWidth * this->size);
HXDLIN(1110)		HX_VARI( Int,spaceWidth) = ::Std_obj::_hx_int(_hx_tmp1);
HXLINE(1111)		Int _hx_tmp2 = (spaceWidth * this->numSpacesInTab);
HXDLIN(1111)		HX_VARI( Int,tabWidth) = ::Std_obj::_hx_int(_hx_tmp2);
HXLINE(1113)		HX_VARI( Int,lineLength) = ::haxe::Utf8_obj::length(line);
HXLINE(1115)		{
HXLINE(1115)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(1115)			while((_g1 < lineLength)){
HXLINE(1115)				HX_VARI( Int,i) = _g1++;
HXLINE(1117)				charCode = ::haxe::Utf8_obj::charCodeAt(line,i);
HXLINE(1119)				if ((charCode == (int)32)) {
HXLINE(1121)					hx::AddEq(curX,spaceWidth);
            				}
            				else {
HXLINE(1123)					if ((charCode == (int)9)) {
HXLINE(1125)						hx::AddEq(curX,tabWidth);
            					}
            					else {
HXLINE(1129)						glyph = glyphs->glyphMap->get(charCode).StaticCast<  ::haxegon::bitmapFont::BitmapGlyph >();
HXLINE(1130)						Bool _hx_tmp3 = hx::IsNotNull( glyph );
HXDLIN(1130)						if (_hx_tmp3) {
HXLINE(1132)							this->_point->x = (curX + glyph->offsetX);
HXLINE(1133)							this->_point->y = (startY + glyph->offsetY);
HXLINE(1134)							this->_bitmapData->copyPixels(glyph->bitmap,glyph->rect,this->_point,null(),null(),true);
HXLINE(1135)							hx::AddEq(curX,glyph->xAdvance);
            						}
            					}
            				}
HXLINE(1139)				hx::AddEq(curX,this->letterSpacing);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(BitmapTextField_obj,blitLine,(void))

void BitmapTextField_obj::setBorderStyle(::hx::EnumBase Style,hx::Null< Int >  __o_Color,hx::Null< Float >  __o_Size,hx::Null< Float >  __o_Quality){
Int Color = __o_Color.Default(-1);
Float Size = __o_Size.Default(1);
Float Quality = __o_Quality.Default(1);
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","setBorderStyle",0xca65cbd5,"haxegon.bitmapFont.BitmapTextField.setBorderStyle","haxegon/bitmapFont/BitmapTextField.hx",1209,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Style,"Style")
            	HX_STACK_ARG(Color,"Color")
            	HX_STACK_ARG(Size,"Size")
            	HX_STACK_ARG(Quality,"Quality")
HXLINE(1210)		this->set_borderStyle(Style);
HXLINE(1211)		this->set_borderColor(Color);
HXLINE(1212)		this->set_borderSize(Size);
HXLINE(1213)		this->set_borderQuality(Quality);
HXLINE(1214)		if (hx::IsEq( this->borderStyle,::haxegon::bitmapFont::TextBorderStyle_obj::SHADOW_dyn() )) {
HXLINE(1216)			this->shadowOffset->setTo(this->borderSize,this->borderSize);
            		}
HXLINE(1218)		this->_pendingGraphicChange = true;
HXLINE(1219)		Bool _hx_tmp = this->updateImmediately;
HXDLIN(1219)		if (_hx_tmp) {
HXLINE(1219)			Bool _hx_tmp1 = this->_pendingTextGlyphsChange;
HXDLIN(1219)			if (_hx_tmp1) {
HXLINE(1219)				this->updateTextGlyphs();
            			}
HXDLIN(1219)			Bool _hx_tmp2 = this->_pendingBorderGlyphsChange;
HXDLIN(1219)			if (_hx_tmp2) {
HXLINE(1219)				this->updateBorderGlyphs();
            			}
HXDLIN(1219)			Bool _hx_tmp3 = this->_pendingTextChange;
HXDLIN(1219)			if (_hx_tmp3) {
HXLINE(1219)				this->updateText();
HXDLIN(1219)				this->_pendingGraphicChange = true;
            			}
HXDLIN(1219)			Bool _hx_tmp4 = this->_pendingGraphicChange;
HXDLIN(1219)			if (_hx_tmp4) {
HXLINE(1219)				this->updateGraphic();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(BitmapTextField_obj,setBorderStyle,(void))

Float BitmapTextField_obj::set_width(Float value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_width",0x8683fbf7,"haxegon.bitmapFont.BitmapTextField.set_width","haxegon/bitmapFont/BitmapTextField.hx",1230,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1231)		value = ::Std_obj::_hx_int(value);
HXLINE(1232)		value = ::Math_obj::max((int)1,value);
HXLINE(1234)		Float _hx_tmp = this->get_width();
HXDLIN(1234)		if ((value != _hx_tmp)) {
HXLINE(1236)			Int _hx_tmp1;
HXDLIN(1236)			if ((value == (int)0)) {
HXLINE(1236)				_hx_tmp1 = (int)1;
            			}
            			else {
HXLINE(1236)				_hx_tmp1 = ::Std_obj::_hx_int(value);
            			}
HXDLIN(1236)			this->_fieldWidth = _hx_tmp1;
HXLINE(1237)			this->_pendingTextChange = true;
HXLINE(1238)			Bool _hx_tmp2 = this->updateImmediately;
HXDLIN(1238)			if (_hx_tmp2) {
HXLINE(1238)				Bool _hx_tmp3 = this->_pendingTextGlyphsChange;
HXDLIN(1238)				if (_hx_tmp3) {
HXLINE(1238)					this->updateTextGlyphs();
            				}
HXDLIN(1238)				Bool _hx_tmp4 = this->_pendingBorderGlyphsChange;
HXDLIN(1238)				if (_hx_tmp4) {
HXLINE(1238)					this->updateBorderGlyphs();
            				}
HXDLIN(1238)				Bool _hx_tmp5 = this->_pendingTextChange;
HXDLIN(1238)				if (_hx_tmp5) {
HXLINE(1238)					this->updateText();
HXDLIN(1238)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1238)				Bool _hx_tmp6 = this->_pendingGraphicChange;
HXDLIN(1238)				if (_hx_tmp6) {
HXLINE(1238)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1241)		return value;
            	}


::String BitmapTextField_obj::set_alignment(::String value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_alignment",0x34777554,"haxegon.bitmapFont.BitmapTextField.set_alignment","haxegon/bitmapFont/BitmapTextField.hx",1246,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1247)		if ((this->alignment != value)) {
HXLINE(1249)			this->alignment = value;
HXLINE(1250)			this->_pendingGraphicChange = true;
HXLINE(1251)			Bool _hx_tmp = this->updateImmediately;
HXDLIN(1251)			if (_hx_tmp) {
HXLINE(1251)				Bool _hx_tmp1 = this->_pendingTextGlyphsChange;
HXDLIN(1251)				if (_hx_tmp1) {
HXLINE(1251)					this->updateTextGlyphs();
            				}
HXDLIN(1251)				Bool _hx_tmp2 = this->_pendingBorderGlyphsChange;
HXDLIN(1251)				if (_hx_tmp2) {
HXLINE(1251)					this->updateBorderGlyphs();
            				}
HXDLIN(1251)				Bool _hx_tmp3 = this->_pendingTextChange;
HXDLIN(1251)				if (_hx_tmp3) {
HXLINE(1251)					this->updateText();
HXDLIN(1251)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1251)				Bool _hx_tmp4 = this->_pendingGraphicChange;
HXDLIN(1251)				if (_hx_tmp4) {
HXLINE(1251)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1254)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_alignment,return )

Bool BitmapTextField_obj::set_multiLine(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_multiLine",0xd324917e,"haxegon.bitmapFont.BitmapTextField.set_multiLine","haxegon/bitmapFont/BitmapTextField.hx",1258,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1259)		Bool _hx_tmp = (this->multiLine != value);
HXDLIN(1259)		if (_hx_tmp) {
HXLINE(1261)			this->multiLine = value;
HXLINE(1262)			this->_pendingTextChange = true;
HXLINE(1263)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1263)			if (_hx_tmp1) {
HXLINE(1263)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1263)				if (_hx_tmp2) {
HXLINE(1263)					this->updateTextGlyphs();
            				}
HXDLIN(1263)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1263)				if (_hx_tmp3) {
HXLINE(1263)					this->updateBorderGlyphs();
            				}
HXDLIN(1263)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1263)				if (_hx_tmp4) {
HXLINE(1263)					this->updateText();
HXDLIN(1263)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1263)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1263)				if (_hx_tmp5) {
HXLINE(1263)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1266)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_multiLine,return )

 ::haxegon::bitmapFont::BitmapFont BitmapTextField_obj::set_font( ::haxegon::bitmapFont::BitmapFont value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_font",0xd2f1e0fe,"haxegon.bitmapFont.BitmapTextField.set_font","haxegon/bitmapFont/BitmapTextField.hx",1270,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1271)		Bool _hx_tmp;
HXDLIN(1271)		if (hx::IsNotEq( this->font,value )) {
HXLINE(1271)			_hx_tmp = hx::IsNotNull( value );
            		}
            		else {
HXLINE(1271)			_hx_tmp = false;
            		}
HXDLIN(1271)		if (_hx_tmp) {
HXLINE(1273)			this->font = value;
HXLINE(1274)			this->_pendingTextChange = true;
HXLINE(1275)			this->_pendingBorderGlyphsChange = true;
HXLINE(1276)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1276)			if (_hx_tmp1) {
HXLINE(1276)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1276)				if (_hx_tmp2) {
HXLINE(1276)					this->updateTextGlyphs();
            				}
HXDLIN(1276)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1276)				if (_hx_tmp3) {
HXLINE(1276)					this->updateBorderGlyphs();
            				}
HXDLIN(1276)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1276)				if (_hx_tmp4) {
HXLINE(1276)					this->updateText();
HXDLIN(1276)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1276)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1276)				if (_hx_tmp5) {
HXLINE(1276)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1279)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_font,return )

Int BitmapTextField_obj::set_lineSpacing(Int value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_lineSpacing",0x49a6baa0,"haxegon.bitmapFont.BitmapTextField.set_lineSpacing","haxegon/bitmapFont/BitmapTextField.hx",1283,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1284)		Bool _hx_tmp = (this->lineSpacing != value);
HXDLIN(1284)		if (_hx_tmp) {
HXLINE(1286)			Float _hx_tmp1 = ::Math_obj::abs(value);
HXDLIN(1286)			this->lineSpacing = ::Std_obj::_hx_int(_hx_tmp1);
HXLINE(1287)			this->_pendingGraphicChange = true;
HXLINE(1288)			Bool _hx_tmp2 = this->updateImmediately;
HXDLIN(1288)			if (_hx_tmp2) {
HXLINE(1288)				Bool _hx_tmp3 = this->_pendingTextGlyphsChange;
HXDLIN(1288)				if (_hx_tmp3) {
HXLINE(1288)					this->updateTextGlyphs();
            				}
HXDLIN(1288)				Bool _hx_tmp4 = this->_pendingBorderGlyphsChange;
HXDLIN(1288)				if (_hx_tmp4) {
HXLINE(1288)					this->updateBorderGlyphs();
            				}
HXDLIN(1288)				Bool _hx_tmp5 = this->_pendingTextChange;
HXDLIN(1288)				if (_hx_tmp5) {
HXLINE(1288)					this->updateText();
HXDLIN(1288)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1288)				Bool _hx_tmp6 = this->_pendingGraphicChange;
HXDLIN(1288)				if (_hx_tmp6) {
HXLINE(1288)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1291)		return this->lineSpacing;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_lineSpacing,return )

Int BitmapTextField_obj::set_letterSpacing(Int value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_letterSpacing",0xe0b5d62e,"haxegon.bitmapFont.BitmapTextField.set_letterSpacing","haxegon/bitmapFont/BitmapTextField.hx",1295,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1296)		Float _hx_tmp = ::Math_obj::abs(value);
HXDLIN(1296)		HX_VARI( Int,tmp) = ::Std_obj::_hx_int(_hx_tmp);
HXLINE(1298)		Bool _hx_tmp1 = (tmp != this->letterSpacing);
HXDLIN(1298)		if (_hx_tmp1) {
HXLINE(1300)			this->letterSpacing = tmp;
HXLINE(1301)			this->_pendingTextChange = true;
HXLINE(1302)			Bool _hx_tmp2 = this->updateImmediately;
HXDLIN(1302)			if (_hx_tmp2) {
HXLINE(1302)				Bool _hx_tmp3 = this->_pendingTextGlyphsChange;
HXDLIN(1302)				if (_hx_tmp3) {
HXLINE(1302)					this->updateTextGlyphs();
            				}
HXDLIN(1302)				Bool _hx_tmp4 = this->_pendingBorderGlyphsChange;
HXDLIN(1302)				if (_hx_tmp4) {
HXLINE(1302)					this->updateBorderGlyphs();
            				}
HXDLIN(1302)				Bool _hx_tmp5 = this->_pendingTextChange;
HXDLIN(1302)				if (_hx_tmp5) {
HXLINE(1302)					this->updateText();
HXDLIN(1302)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1302)				Bool _hx_tmp6 = this->_pendingGraphicChange;
HXDLIN(1302)				if (_hx_tmp6) {
HXLINE(1302)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1305)		return this->letterSpacing;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_letterSpacing,return )

Bool BitmapTextField_obj::set_autoUpperCase(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_autoUpperCase",0x9f1bf6b4,"haxegon.bitmapFont.BitmapTextField.set_autoUpperCase","haxegon/bitmapFont/BitmapTextField.hx",1309,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1310)		Bool _hx_tmp = (this->autoUpperCase != value);
HXDLIN(1310)		if (_hx_tmp) {
HXLINE(1312)			this->autoUpperCase = value;
HXLINE(1313)			this->_pendingTextChange = true;
HXLINE(1314)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1314)			if (_hx_tmp1) {
HXLINE(1314)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1314)				if (_hx_tmp2) {
HXLINE(1314)					this->updateTextGlyphs();
            				}
HXDLIN(1314)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1314)				if (_hx_tmp3) {
HXLINE(1314)					this->updateBorderGlyphs();
            				}
HXDLIN(1314)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1314)				if (_hx_tmp4) {
HXLINE(1314)					this->updateText();
HXDLIN(1314)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1314)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1314)				if (_hx_tmp5) {
HXLINE(1314)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1317)		return this->autoUpperCase;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_autoUpperCase,return )

Bool BitmapTextField_obj::set_wordWrap(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_wordWrap",0x0a5f5b63,"haxegon.bitmapFont.BitmapTextField.set_wordWrap","haxegon/bitmapFont/BitmapTextField.hx",1321,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1322)		Bool _hx_tmp = (this->wordWrap != value);
HXDLIN(1322)		if (_hx_tmp) {
HXLINE(1324)			this->wordWrap = value;
HXLINE(1325)			this->_pendingTextChange = true;
HXLINE(1326)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1326)			if (_hx_tmp1) {
HXLINE(1326)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1326)				if (_hx_tmp2) {
HXLINE(1326)					this->updateTextGlyphs();
            				}
HXDLIN(1326)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1326)				if (_hx_tmp3) {
HXLINE(1326)					this->updateBorderGlyphs();
            				}
HXDLIN(1326)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1326)				if (_hx_tmp4) {
HXLINE(1326)					this->updateText();
HXDLIN(1326)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1326)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1326)				if (_hx_tmp5) {
HXLINE(1326)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1329)		return this->wordWrap;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_wordWrap,return )

Bool BitmapTextField_obj::set_wrapByWord(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_wrapByWord",0x20a66d1a,"haxegon.bitmapFont.BitmapTextField.set_wrapByWord","haxegon/bitmapFont/BitmapTextField.hx",1333,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1334)		Bool _hx_tmp = (this->wrapByWord != value);
HXDLIN(1334)		if (_hx_tmp) {
HXLINE(1336)			this->wrapByWord = value;
HXLINE(1337)			this->_pendingTextChange = true;
HXLINE(1338)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1338)			if (_hx_tmp1) {
HXLINE(1338)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1338)				if (_hx_tmp2) {
HXLINE(1338)					this->updateTextGlyphs();
            				}
HXDLIN(1338)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1338)				if (_hx_tmp3) {
HXLINE(1338)					this->updateBorderGlyphs();
            				}
HXDLIN(1338)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1338)				if (_hx_tmp4) {
HXLINE(1338)					this->updateText();
HXDLIN(1338)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1338)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1338)				if (_hx_tmp5) {
HXLINE(1338)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1341)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_wrapByWord,return )

Bool BitmapTextField_obj::set_autoSize(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_autoSize",0x38fdd67f,"haxegon.bitmapFont.BitmapTextField.set_autoSize","haxegon/bitmapFont/BitmapTextField.hx",1345,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1346)		Bool _hx_tmp = (this->autoSize != value);
HXDLIN(1346)		if (_hx_tmp) {
HXLINE(1348)			this->autoSize = value;
HXLINE(1349)			this->_pendingTextChange = true;
HXLINE(1350)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1350)			if (_hx_tmp1) {
HXLINE(1350)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1350)				if (_hx_tmp2) {
HXLINE(1350)					this->updateTextGlyphs();
            				}
HXDLIN(1350)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1350)				if (_hx_tmp3) {
HXLINE(1350)					this->updateBorderGlyphs();
            				}
HXDLIN(1350)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1350)				if (_hx_tmp4) {
HXLINE(1350)					this->updateText();
HXDLIN(1350)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1350)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1350)				if (_hx_tmp5) {
HXLINE(1350)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1353)		return this->autoSize;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_autoSize,return )

Float BitmapTextField_obj::set_size(Float value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_size",0xdb8523f0,"haxegon.bitmapFont.BitmapTextField.set_size","haxegon/bitmapFont/BitmapTextField.hx",1357,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1358)		HX_VARI( Float,tmp) = ::Math_obj::abs(value);
HXLINE(1360)		Bool _hx_tmp = (tmp != this->size);
HXDLIN(1360)		if (_hx_tmp) {
HXLINE(1362)			this->size = tmp;
HXLINE(1363)			this->_pendingTextGlyphsChange = true;
HXLINE(1364)			this->_pendingBorderGlyphsChange = true;
HXLINE(1365)			this->_pendingTextChange = true;
HXLINE(1366)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1366)			if (_hx_tmp1) {
HXLINE(1366)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1366)				if (_hx_tmp2) {
HXLINE(1366)					this->updateTextGlyphs();
            				}
HXDLIN(1366)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1366)				if (_hx_tmp3) {
HXLINE(1366)					this->updateBorderGlyphs();
            				}
HXDLIN(1366)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1366)				if (_hx_tmp4) {
HXLINE(1366)					this->updateText();
HXDLIN(1366)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1366)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1366)				if (_hx_tmp5) {
HXLINE(1366)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1369)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_size,return )

Int BitmapTextField_obj::set_padding(Int value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_padding",0xcbf0be02,"haxegon.bitmapFont.BitmapTextField.set_padding","haxegon/bitmapFont/BitmapTextField.hx",1373,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1374)		Bool _hx_tmp = (value != this->padding);
HXDLIN(1374)		if (_hx_tmp) {
HXLINE(1376)			this->padding = value;
HXLINE(1377)			this->_pendingTextChange = true;
HXLINE(1378)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1378)			if (_hx_tmp1) {
HXLINE(1378)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1378)				if (_hx_tmp2) {
HXLINE(1378)					this->updateTextGlyphs();
            				}
HXDLIN(1378)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1378)				if (_hx_tmp3) {
HXLINE(1378)					this->updateBorderGlyphs();
            				}
HXDLIN(1378)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1378)				if (_hx_tmp4) {
HXLINE(1378)					this->updateText();
HXDLIN(1378)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1378)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1378)				if (_hx_tmp5) {
HXLINE(1378)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1381)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_padding,return )

Int BitmapTextField_obj::set_numSpacesInTab(Int value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_numSpacesInTab",0x7f022e8c,"haxegon.bitmapFont.BitmapTextField.set_numSpacesInTab","haxegon/bitmapFont/BitmapTextField.hx",1385,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1386)		Bool _hx_tmp;
HXDLIN(1386)		if ((this->numSpacesInTab != value)) {
HXLINE(1386)			_hx_tmp = (value > (int)0);
            		}
            		else {
HXLINE(1386)			_hx_tmp = false;
            		}
HXDLIN(1386)		if (_hx_tmp) {
HXLINE(1388)			this->numSpacesInTab = value;
HXLINE(1389)			this->_tabSpaces = HX_("",00,00,00,00);
HXLINE(1391)			{
HXLINE(1391)				HX_VARI( Int,_g1) = (int)0;
HXDLIN(1391)				while((_g1 < value)){
HXLINE(1391)					++_g1;
HXLINE(1393)					hx::AddEq(this->_tabSpaces,HX_(" ",20,00,00,00));
            				}
            			}
HXLINE(1396)			this->_pendingTextChange = true;
HXLINE(1397)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1397)			if (_hx_tmp1) {
HXLINE(1397)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1397)				if (_hx_tmp2) {
HXLINE(1397)					this->updateTextGlyphs();
            				}
HXDLIN(1397)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1397)				if (_hx_tmp3) {
HXLINE(1397)					this->updateBorderGlyphs();
            				}
HXDLIN(1397)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1397)				if (_hx_tmp4) {
HXLINE(1397)					this->updateText();
HXDLIN(1397)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1397)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1397)				if (_hx_tmp5) {
HXLINE(1397)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1400)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_numSpacesInTab,return )

Bool BitmapTextField_obj::set_background(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_background",0xce44245d,"haxegon.bitmapFont.BitmapTextField.set_background","haxegon/bitmapFont/BitmapTextField.hx",1404,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1405)		Bool _hx_tmp = (this->background != value);
HXDLIN(1405)		if (_hx_tmp) {
HXLINE(1407)			this->background = value;
HXLINE(1408)			this->_pendingGraphicChange = true;
HXLINE(1409)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1409)			if (_hx_tmp1) {
HXLINE(1409)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1409)				if (_hx_tmp2) {
HXLINE(1409)					this->updateTextGlyphs();
            				}
HXDLIN(1409)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1409)				if (_hx_tmp3) {
HXLINE(1409)					this->updateBorderGlyphs();
            				}
HXDLIN(1409)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1409)				if (_hx_tmp4) {
HXLINE(1409)					this->updateText();
HXDLIN(1409)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1409)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1409)				if (_hx_tmp5) {
HXLINE(1409)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1412)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_background,return )

Int BitmapTextField_obj::set_backgroundColor(Int value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_backgroundColor",0xe0f3cbc6,"haxegon.bitmapFont.BitmapTextField.set_backgroundColor","haxegon/bitmapFont/BitmapTextField.hx",1416,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1417)		Bool _hx_tmp = (this->backgroundColor != value);
HXDLIN(1417)		if (_hx_tmp) {
HXLINE(1419)			this->backgroundColor = value;
HXLINE(1420)			this->_pendingGraphicChange = true;
HXLINE(1421)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1421)			if (_hx_tmp1) {
HXLINE(1421)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1421)				if (_hx_tmp2) {
HXLINE(1421)					this->updateTextGlyphs();
            				}
HXDLIN(1421)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1421)				if (_hx_tmp3) {
HXLINE(1421)					this->updateBorderGlyphs();
            				}
HXDLIN(1421)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1421)				if (_hx_tmp4) {
HXLINE(1421)					this->updateText();
HXDLIN(1421)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1421)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1421)				if (_hx_tmp5) {
HXLINE(1421)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1424)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_backgroundColor,return )

::hx::EnumBase BitmapTextField_obj::set_borderStyle(::hx::EnumBase style){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_borderStyle",0x8a2e4156,"haxegon.bitmapFont.BitmapTextField.set_borderStyle","haxegon/bitmapFont/BitmapTextField.hx",1428,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(style,"style")
HXLINE(1429)		if (hx::IsNotEq( style,this->borderStyle )) {
HXLINE(1431)			this->borderStyle = style;
HXLINE(1432)			this->_pendingBorderGlyphsChange = true;
HXLINE(1433)			Bool _hx_tmp = this->updateImmediately;
HXDLIN(1433)			if (_hx_tmp) {
HXLINE(1433)				Bool _hx_tmp1 = this->_pendingTextGlyphsChange;
HXDLIN(1433)				if (_hx_tmp1) {
HXLINE(1433)					this->updateTextGlyphs();
            				}
HXDLIN(1433)				Bool _hx_tmp2 = this->_pendingBorderGlyphsChange;
HXDLIN(1433)				if (_hx_tmp2) {
HXLINE(1433)					this->updateBorderGlyphs();
            				}
HXDLIN(1433)				Bool _hx_tmp3 = this->_pendingTextChange;
HXDLIN(1433)				if (_hx_tmp3) {
HXLINE(1433)					this->updateText();
HXDLIN(1433)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1433)				Bool _hx_tmp4 = this->_pendingGraphicChange;
HXDLIN(1433)				if (_hx_tmp4) {
HXLINE(1433)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1436)		return this->borderStyle;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_borderStyle,return )

Int BitmapTextField_obj::set_borderColor(Int value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_borderColor",0x506d0d88,"haxegon.bitmapFont.BitmapTextField.set_borderColor","haxegon/bitmapFont/BitmapTextField.hx",1440,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1441)		Bool _hx_tmp = (this->borderColor != value);
HXDLIN(1441)		if (_hx_tmp) {
HXLINE(1443)			this->borderColor = value;
HXLINE(1444)			this->_pendingBorderGlyphsChange = true;
HXLINE(1445)			Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1445)			if (_hx_tmp1) {
HXLINE(1445)				Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1445)				if (_hx_tmp2) {
HXLINE(1445)					this->updateTextGlyphs();
            				}
HXDLIN(1445)				Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1445)				if (_hx_tmp3) {
HXLINE(1445)					this->updateBorderGlyphs();
            				}
HXDLIN(1445)				Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1445)				if (_hx_tmp4) {
HXLINE(1445)					this->updateText();
HXDLIN(1445)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1445)				Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1445)				if (_hx_tmp5) {
HXLINE(1445)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1448)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_borderColor,return )

Float BitmapTextField_obj::set_borderSize(Float value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_borderSize",0xaf14903c,"haxegon.bitmapFont.BitmapTextField.set_borderSize","haxegon/bitmapFont/BitmapTextField.hx",1452,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1453)		Bool _hx_tmp = (value != this->borderSize);
HXDLIN(1453)		if (_hx_tmp) {
HXLINE(1455)			this->borderSize = value;
HXLINE(1457)			if (hx::IsNotEq( this->borderStyle,::haxegon::bitmapFont::TextBorderStyle_obj::NONE_dyn() )) {
HXLINE(1459)				this->_pendingGraphicChange = true;
HXLINE(1460)				Bool _hx_tmp1 = this->updateImmediately;
HXDLIN(1460)				if (_hx_tmp1) {
HXLINE(1460)					Bool _hx_tmp2 = this->_pendingTextGlyphsChange;
HXDLIN(1460)					if (_hx_tmp2) {
HXLINE(1460)						this->updateTextGlyphs();
            					}
HXDLIN(1460)					Bool _hx_tmp3 = this->_pendingBorderGlyphsChange;
HXDLIN(1460)					if (_hx_tmp3) {
HXLINE(1460)						this->updateBorderGlyphs();
            					}
HXDLIN(1460)					Bool _hx_tmp4 = this->_pendingTextChange;
HXDLIN(1460)					if (_hx_tmp4) {
HXLINE(1460)						this->updateText();
HXDLIN(1460)						this->_pendingGraphicChange = true;
            					}
HXDLIN(1460)					Bool _hx_tmp5 = this->_pendingGraphicChange;
HXDLIN(1460)					if (_hx_tmp5) {
HXLINE(1460)						this->updateGraphic();
            					}
            				}
            			}
            		}
HXLINE(1464)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_borderSize,return )

Float BitmapTextField_obj::set_borderQuality(Float value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_borderQuality",0x64d7b424,"haxegon.bitmapFont.BitmapTextField.set_borderQuality","haxegon/bitmapFont/BitmapTextField.hx",1468,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1469)		Float _hx_tmp = ::Math_obj::max((int)0,value);
HXDLIN(1469)		value = ::Math_obj::min((int)1,_hx_tmp);
HXLINE(1471)		Bool _hx_tmp1 = (value != this->borderQuality);
HXDLIN(1471)		if (_hx_tmp1) {
HXLINE(1473)			this->borderQuality = value;
HXLINE(1475)			if (hx::IsNotEq( this->borderStyle,::haxegon::bitmapFont::TextBorderStyle_obj::NONE_dyn() )) {
HXLINE(1477)				this->_pendingGraphicChange = true;
HXLINE(1478)				Bool _hx_tmp2 = this->updateImmediately;
HXDLIN(1478)				if (_hx_tmp2) {
HXLINE(1478)					Bool _hx_tmp3 = this->_pendingTextGlyphsChange;
HXDLIN(1478)					if (_hx_tmp3) {
HXLINE(1478)						this->updateTextGlyphs();
            					}
HXDLIN(1478)					Bool _hx_tmp4 = this->_pendingBorderGlyphsChange;
HXDLIN(1478)					if (_hx_tmp4) {
HXLINE(1478)						this->updateBorderGlyphs();
            					}
HXDLIN(1478)					Bool _hx_tmp5 = this->_pendingTextChange;
HXDLIN(1478)					if (_hx_tmp5) {
HXLINE(1478)						this->updateText();
HXDLIN(1478)						this->_pendingGraphicChange = true;
            					}
HXDLIN(1478)					Bool _hx_tmp6 = this->_pendingGraphicChange;
HXDLIN(1478)					if (_hx_tmp6) {
HXLINE(1478)						this->updateGraphic();
            					}
            				}
            			}
            		}
HXLINE(1482)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_borderQuality,return )

Int BitmapTextField_obj::get_numLines(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","get_numLines",0x269d1514,"haxegon.bitmapFont.BitmapTextField.get_numLines","haxegon/bitmapFont/BitmapTextField.hx",1487,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE(1487)		return this->_lines->length;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,get_numLines,return )

Float BitmapTextField_obj::get_textWidth(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","get_textWidth",0x6883f67e,"haxegon.bitmapFont.BitmapTextField.get_textWidth","haxegon/bitmapFont/BitmapTextField.hx",1496,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE(1497)		HX_VARI( Float,max) = (int)0;
HXLINE(1498)		HX_VARI( Int,numLines) = this->_lines->length;
HXLINE(1499)		HX_VAR( Float,lineWidth);
HXLINE(1500)		this->_linesWidth = ::Array_obj< Float >::__new(0);
HXLINE(1502)		{
HXLINE(1502)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(1502)			while((_g1 < numLines)){
HXLINE(1502)				HX_VARI( Int,i) = _g1++;
HXLINE(1504)				lineWidth = this->getLineWidth(i);
HXLINE(1505)				this->_linesWidth[i] = lineWidth;
HXLINE(1506)				max = ::Math_obj::max(max,lineWidth);
            			}
            		}
HXLINE(1509)		return max;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,get_textWidth,return )

Float BitmapTextField_obj::get_textHeight(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","get_textHeight",0xc143306f,"haxegon.bitmapFont.BitmapTextField.get_textHeight","haxegon/bitmapFont/BitmapTextField.hx",1514,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE(1514)		Float _hx_tmp = this->get_lineHeight();
HXDLIN(1514)		return (((_hx_tmp + this->lineSpacing) * this->_lines->length) - this->lineSpacing);
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,get_textHeight,return )

Float BitmapTextField_obj::get_lineHeight(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","get_lineHeight",0x5efaaaf6,"haxegon.bitmapFont.BitmapTextField.get_lineHeight","haxegon/bitmapFont/BitmapTextField.hx",1519,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE(1519)		return (this->font->lineHeight * this->size);
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,get_lineHeight,return )

Bool BitmapTextField_obj::set_updateImmediately(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_updateImmediately",0x5767a8a6,"haxegon.bitmapFont.BitmapTextField.set_updateImmediately","haxegon/bitmapFont/BitmapTextField.hx",1523,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1524)		Bool _hx_tmp = (this->updateImmediately != value);
HXDLIN(1524)		if (_hx_tmp) {
HXLINE(1526)			this->updateImmediately = value;
HXLINE(1527)			if (value) {
HXLINE(1529)				Bool _hx_tmp1 = this->_pendingTextGlyphsChange;
HXDLIN(1529)				if (_hx_tmp1) {
HXLINE(1529)					this->updateTextGlyphs();
            				}
HXDLIN(1529)				Bool _hx_tmp2 = this->_pendingBorderGlyphsChange;
HXDLIN(1529)				if (_hx_tmp2) {
HXLINE(1529)					this->updateBorderGlyphs();
            				}
HXDLIN(1529)				Bool _hx_tmp3 = this->_pendingTextChange;
HXDLIN(1529)				if (_hx_tmp3) {
HXLINE(1529)					this->updateText();
HXDLIN(1529)					this->_pendingGraphicChange = true;
            				}
HXDLIN(1529)				Bool _hx_tmp4 = this->_pendingGraphicChange;
HXDLIN(1529)				if (_hx_tmp4) {
HXLINE(1529)					this->updateGraphic();
            				}
            			}
            		}
HXLINE(1533)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_updateImmediately,return )

Bool BitmapTextField_obj::set_smoothing(Bool value){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","set_smoothing",0xe01b67e5,"haxegon.bitmapFont.BitmapTextField.set_smoothing","haxegon/bitmapFont/BitmapTextField.hx",1537,0xab2b8d62)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1539)		this->_bitmap->smoothing = value;
HXLINE(1548)		return (this->smoothing = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(BitmapTextField_obj,set_smoothing,return )

void BitmapTextField_obj::updateTextGlyphs(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","updateTextGlyphs",0xbf93396f,"haxegon.bitmapFont.BitmapTextField.updateTextGlyphs","haxegon/bitmapFont/BitmapTextField.hx",1552,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE(1554)		Bool _hx_tmp = hx::IsNull( this->font );
HXDLIN(1554)		if (_hx_tmp) {
HXLINE(1554)			return;
            		}
HXLINE(1556)		Bool _hx_tmp1 = hx::IsNotNull( this->textGlyphs );
HXDLIN(1556)		if (_hx_tmp1) {
HXLINE(1558)			this->textGlyphs->dispose();
            		}
HXLINE(1560)		this->textGlyphs = this->font->prepareGlyphs(this->size,this->textColor,this->useTextColor,this->smoothing);
HXLINE(1563)		this->_pendingTextGlyphsChange = false;
HXLINE(1564)		this->_pendingGraphicChange = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,updateTextGlyphs,(void))

void BitmapTextField_obj::updateBorderGlyphs(){
            	HX_STACK_FRAME("haxegon.bitmapFont.BitmapTextField","updateBorderGlyphs",0x5b7f4fae,"haxegon.bitmapFont.BitmapTextField.updateBorderGlyphs","haxegon/bitmapFont/BitmapTextField.hx",1568,0xab2b8d62)
            	HX_STACK_THIS(this)
HXLINE(1570)		Bool _hx_tmp;
HXDLIN(1570)		Bool _hx_tmp1 = hx::IsNotNull( this->font );
HXDLIN(1570)		if (_hx_tmp1) {
HXLINE(1570)			Bool _hx_tmp2;
HXDLIN(1570)			Bool _hx_tmp3;
HXDLIN(1570)			Bool _hx_tmp4 = hx::IsNotNull( this->borderGlyphs );
HXDLIN(1570)			if (_hx_tmp4) {
HXLINE(1570)				_hx_tmp3 = (this->borderColor != this->borderGlyphs->color);
            			}
            			else {
HXLINE(1570)				_hx_tmp3 = true;
            			}
HXDLIN(1570)			if (!(_hx_tmp3)) {
HXLINE(1570)				_hx_tmp2 = (this->size != this->borderGlyphs->scale);
            			}
            			else {
HXLINE(1570)				_hx_tmp2 = true;
            			}
HXDLIN(1570)			if (!(_hx_tmp2)) {
HXLINE(1570)				_hx_tmp = hx::IsNotEq( this->font,this->borderGlyphs->font );
            			}
            			else {
HXLINE(1570)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE(1570)			_hx_tmp = false;
            		}
HXDLIN(1570)		if (_hx_tmp) {
HXLINE(1572)			Bool _hx_tmp5 = hx::IsNotNull( this->borderGlyphs );
HXDLIN(1572)			if (_hx_tmp5) {
HXLINE(1574)				this->borderGlyphs->dispose();
            			}
HXLINE(1576)			this->borderGlyphs = this->font->prepareGlyphs(this->size,this->borderColor,true,this->smoothing);
            		}
HXLINE(1580)		this->_pendingBorderGlyphsChange = false;
HXLINE(1581)		this->_pendingGraphicChange = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(BitmapTextField_obj,updateBorderGlyphs,(void))


BitmapTextField_obj::BitmapTextField_obj()
{
}

void BitmapTextField_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BitmapTextField);
	HX_MARK_MEMBER_NAME(font,"font");
	HX_MARK_MEMBER_NAME(text,"text");
	HX_MARK_MEMBER_NAME(_lines,"_lines");
	HX_MARK_MEMBER_NAME(_linesWidth,"_linesWidth");
	HX_MARK_MEMBER_NAME(alignment,"alignment");
	HX_MARK_MEMBER_NAME(lineSpacing,"lineSpacing");
	HX_MARK_MEMBER_NAME(letterSpacing,"letterSpacing");
	HX_MARK_MEMBER_NAME(autoUpperCase,"autoUpperCase");
	HX_MARK_MEMBER_NAME(wordWrap,"wordWrap");
	HX_MARK_MEMBER_NAME(wrapByWord,"wrapByWord");
	HX_MARK_MEMBER_NAME(autoSize,"autoSize");
	HX_MARK_MEMBER_NAME(padding,"padding");
	HX_MARK_MEMBER_NAME(textWidth,"textWidth");
	HX_MARK_MEMBER_NAME(textHeight,"textHeight");
	HX_MARK_MEMBER_NAME(lineHeight,"lineHeight");
	HX_MARK_MEMBER_NAME(numSpacesInTab,"numSpacesInTab");
	HX_MARK_MEMBER_NAME(_tabSpaces,"_tabSpaces");
	HX_MARK_MEMBER_NAME(textColor,"textColor");
	HX_MARK_MEMBER_NAME(useTextColor,"useTextColor");
	HX_MARK_MEMBER_NAME(borderStyle,"borderStyle");
	HX_MARK_MEMBER_NAME(borderColor,"borderColor");
	HX_MARK_MEMBER_NAME(borderSize,"borderSize");
	HX_MARK_MEMBER_NAME(borderQuality,"borderQuality");
	HX_MARK_MEMBER_NAME(shadowOffset,"shadowOffset");
	HX_MARK_MEMBER_NAME(background,"background");
	HX_MARK_MEMBER_NAME(backgroundColor,"backgroundColor");
	HX_MARK_MEMBER_NAME(multiLine,"multiLine");
	HX_MARK_MEMBER_NAME(numLines,"numLines");
	HX_MARK_MEMBER_NAME(size,"size");
	HX_MARK_MEMBER_NAME(smoothing,"smoothing");
	HX_MARK_MEMBER_NAME(updateImmediately,"updateImmediately");
	HX_MARK_MEMBER_NAME(_pendingTextChange,"_pendingTextChange");
	HX_MARK_MEMBER_NAME(_pendingGraphicChange,"_pendingGraphicChange");
	HX_MARK_MEMBER_NAME(_pendingTextGlyphsChange,"_pendingTextGlyphsChange");
	HX_MARK_MEMBER_NAME(_pendingBorderGlyphsChange,"_pendingBorderGlyphsChange");
	HX_MARK_MEMBER_NAME(_fieldWidth,"_fieldWidth");
	HX_MARK_MEMBER_NAME(_fieldHeight,"_fieldHeight");
	HX_MARK_MEMBER_NAME(_bitmap,"_bitmap");
	HX_MARK_MEMBER_NAME(_bitmapData,"_bitmapData");
	HX_MARK_MEMBER_NAME(textGlyphs,"textGlyphs");
	HX_MARK_MEMBER_NAME(borderGlyphs,"borderGlyphs");
	HX_MARK_MEMBER_NAME(_point,"_point");
	 ::openfl::display::Sprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void BitmapTextField_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(font,"font");
	HX_VISIT_MEMBER_NAME(text,"text");
	HX_VISIT_MEMBER_NAME(_lines,"_lines");
	HX_VISIT_MEMBER_NAME(_linesWidth,"_linesWidth");
	HX_VISIT_MEMBER_NAME(alignment,"alignment");
	HX_VISIT_MEMBER_NAME(lineSpacing,"lineSpacing");
	HX_VISIT_MEMBER_NAME(letterSpacing,"letterSpacing");
	HX_VISIT_MEMBER_NAME(autoUpperCase,"autoUpperCase");
	HX_VISIT_MEMBER_NAME(wordWrap,"wordWrap");
	HX_VISIT_MEMBER_NAME(wrapByWord,"wrapByWord");
	HX_VISIT_MEMBER_NAME(autoSize,"autoSize");
	HX_VISIT_MEMBER_NAME(padding,"padding");
	HX_VISIT_MEMBER_NAME(textWidth,"textWidth");
	HX_VISIT_MEMBER_NAME(textHeight,"textHeight");
	HX_VISIT_MEMBER_NAME(lineHeight,"lineHeight");
	HX_VISIT_MEMBER_NAME(numSpacesInTab,"numSpacesInTab");
	HX_VISIT_MEMBER_NAME(_tabSpaces,"_tabSpaces");
	HX_VISIT_MEMBER_NAME(textColor,"textColor");
	HX_VISIT_MEMBER_NAME(useTextColor,"useTextColor");
	HX_VISIT_MEMBER_NAME(borderStyle,"borderStyle");
	HX_VISIT_MEMBER_NAME(borderColor,"borderColor");
	HX_VISIT_MEMBER_NAME(borderSize,"borderSize");
	HX_VISIT_MEMBER_NAME(borderQuality,"borderQuality");
	HX_VISIT_MEMBER_NAME(shadowOffset,"shadowOffset");
	HX_VISIT_MEMBER_NAME(background,"background");
	HX_VISIT_MEMBER_NAME(backgroundColor,"backgroundColor");
	HX_VISIT_MEMBER_NAME(multiLine,"multiLine");
	HX_VISIT_MEMBER_NAME(numLines,"numLines");
	HX_VISIT_MEMBER_NAME(size,"size");
	HX_VISIT_MEMBER_NAME(smoothing,"smoothing");
	HX_VISIT_MEMBER_NAME(updateImmediately,"updateImmediately");
	HX_VISIT_MEMBER_NAME(_pendingTextChange,"_pendingTextChange");
	HX_VISIT_MEMBER_NAME(_pendingGraphicChange,"_pendingGraphicChange");
	HX_VISIT_MEMBER_NAME(_pendingTextGlyphsChange,"_pendingTextGlyphsChange");
	HX_VISIT_MEMBER_NAME(_pendingBorderGlyphsChange,"_pendingBorderGlyphsChange");
	HX_VISIT_MEMBER_NAME(_fieldWidth,"_fieldWidth");
	HX_VISIT_MEMBER_NAME(_fieldHeight,"_fieldHeight");
	HX_VISIT_MEMBER_NAME(_bitmap,"_bitmap");
	HX_VISIT_MEMBER_NAME(_bitmapData,"_bitmapData");
	HX_VISIT_MEMBER_NAME(textGlyphs,"textGlyphs");
	HX_VISIT_MEMBER_NAME(borderGlyphs,"borderGlyphs");
	HX_VISIT_MEMBER_NAME(_point,"_point");
	 ::openfl::display::Sprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val BitmapTextField_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { return hx::Val( font); }
		if (HX_FIELD_EQ(inName,"text") ) { return hx::Val( text); }
		if (HX_FIELD_EQ(inName,"size") ) { return hx::Val( size); }
		if (HX_FIELD_EQ(inName,"wrap") ) { return hx::Val( wrap_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_lines") ) { return hx::Val( _lines); }
		if (HX_FIELD_EQ(inName,"_point") ) { return hx::Val( _point); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"padding") ) { return hx::Val( padding); }
		if (HX_FIELD_EQ(inName,"_bitmap") ) { return hx::Val( _bitmap); }
		if (HX_FIELD_EQ(inName,"dispose") ) { return hx::Val( dispose_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"wordWrap") ) { return hx::Val( wordWrap); }
		if (HX_FIELD_EQ(inName,"autoSize") ) { return hx::Val( autoSize); }
		if (HX_FIELD_EQ(inName,"numLines") ) { return hx::Val( inCallProp == hx::paccAlways ? get_numLines() : numLines); }
		if (HX_FIELD_EQ(inName,"set_text") ) { return hx::Val( set_text_dyn()); }
		if (HX_FIELD_EQ(inName,"cutLines") ) { return hx::Val( cutLines_dyn()); }
		if (HX_FIELD_EQ(inName,"blitLine") ) { return hx::Val( blitLine_dyn()); }
		if (HX_FIELD_EQ(inName,"set_font") ) { return hx::Val( set_font_dyn()); }
		if (HX_FIELD_EQ(inName,"set_size") ) { return hx::Val( set_size_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"alignment") ) { return hx::Val( alignment); }
		if (HX_FIELD_EQ(inName,"textWidth") ) { return hx::Val( inCallProp == hx::paccAlways ? get_textWidth() : textWidth); }
		if (HX_FIELD_EQ(inName,"textColor") ) { return hx::Val( textColor); }
		if (HX_FIELD_EQ(inName,"multiLine") ) { return hx::Val( multiLine); }
		if (HX_FIELD_EQ(inName,"smoothing") ) { return hx::Val( smoothing); }
		if (HX_FIELD_EQ(inName,"set_width") ) { return hx::Val( set_width_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"wrapByWord") ) { return hx::Val( wrapByWord); }
		if (HX_FIELD_EQ(inName,"textHeight") ) { return hx::Val( inCallProp == hx::paccAlways ? get_textHeight() : textHeight); }
		if (HX_FIELD_EQ(inName,"lineHeight") ) { return hx::Val( inCallProp == hx::paccAlways ? get_lineHeight() : lineHeight); }
		if (HX_FIELD_EQ(inName,"_tabSpaces") ) { return hx::Val( _tabSpaces); }
		if (HX_FIELD_EQ(inName,"borderSize") ) { return hx::Val( borderSize); }
		if (HX_FIELD_EQ(inName,"background") ) { return hx::Val( background); }
		if (HX_FIELD_EQ(inName,"textGlyphs") ) { return hx::Val( textGlyphs); }
		if (HX_FIELD_EQ(inName,"updateText") ) { return hx::Val( updateText_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_linesWidth") ) { return hx::Val( _linesWidth); }
		if (HX_FIELD_EQ(inName,"lineSpacing") ) { return hx::Val( lineSpacing); }
		if (HX_FIELD_EQ(inName,"borderStyle") ) { return hx::Val( borderStyle); }
		if (HX_FIELD_EQ(inName,"borderColor") ) { return hx::Val( borderColor); }
		if (HX_FIELD_EQ(inName,"_fieldWidth") ) { return hx::Val( _fieldWidth); }
		if (HX_FIELD_EQ(inName,"_bitmapData") ) { return hx::Val( _bitmapData); }
		if (HX_FIELD_EQ(inName,"set_padding") ) { return hx::Val( set_padding_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"useTextColor") ) { return hx::Val( useTextColor); }
		if (HX_FIELD_EQ(inName,"shadowOffset") ) { return hx::Val( shadowOffset); }
		if (HX_FIELD_EQ(inName,"_fieldHeight") ) { return hx::Val( _fieldHeight); }
		if (HX_FIELD_EQ(inName,"borderGlyphs") ) { return hx::Val( borderGlyphs); }
		if (HX_FIELD_EQ(inName,"getLineWidth") ) { return hx::Val( getLineWidth_dyn()); }
		if (HX_FIELD_EQ(inName,"set_wordWrap") ) { return hx::Val( set_wordWrap_dyn()); }
		if (HX_FIELD_EQ(inName,"set_autoSize") ) { return hx::Val( set_autoSize_dyn()); }
		if (HX_FIELD_EQ(inName,"get_numLines") ) { return hx::Val( get_numLines_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"letterSpacing") ) { return hx::Val( letterSpacing); }
		if (HX_FIELD_EQ(inName,"autoUpperCase") ) { return hx::Val( autoUpperCase); }
		if (HX_FIELD_EQ(inName,"borderQuality") ) { return hx::Val( borderQuality); }
		if (HX_FIELD_EQ(inName,"set_textColor") ) { return hx::Val( set_textColor_dyn()); }
		if (HX_FIELD_EQ(inName,"updateGraphic") ) { return hx::Val( updateGraphic_dyn()); }
		if (HX_FIELD_EQ(inName,"set_alignment") ) { return hx::Val( set_alignment_dyn()); }
		if (HX_FIELD_EQ(inName,"set_multiLine") ) { return hx::Val( set_multiLine_dyn()); }
		if (HX_FIELD_EQ(inName,"get_textWidth") ) { return hx::Val( get_textWidth_dyn()); }
		if (HX_FIELD_EQ(inName,"set_smoothing") ) { return hx::Val( set_smoothing_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"numSpacesInTab") ) { return hx::Val( numSpacesInTab); }
		if (HX_FIELD_EQ(inName,"getStringWidth") ) { return hx::Val( getStringWidth_dyn()); }
		if (HX_FIELD_EQ(inName,"wrapLineByWord") ) { return hx::Val( wrapLineByWord_dyn()); }
		if (HX_FIELD_EQ(inName,"setBorderStyle") ) { return hx::Val( setBorderStyle_dyn()); }
		if (HX_FIELD_EQ(inName,"set_wrapByWord") ) { return hx::Val( set_wrapByWord_dyn()); }
		if (HX_FIELD_EQ(inName,"set_background") ) { return hx::Val( set_background_dyn()); }
		if (HX_FIELD_EQ(inName,"set_borderSize") ) { return hx::Val( set_borderSize_dyn()); }
		if (HX_FIELD_EQ(inName,"get_textHeight") ) { return hx::Val( get_textHeight_dyn()); }
		if (HX_FIELD_EQ(inName,"get_lineHeight") ) { return hx::Val( get_lineHeight_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"backgroundColor") ) { return hx::Val( backgroundColor); }
		if (HX_FIELD_EQ(inName,"computeTextSize") ) { return hx::Val( computeTextSize_dyn()); }
		if (HX_FIELD_EQ(inName,"set_lineSpacing") ) { return hx::Val( set_lineSpacing_dyn()); }
		if (HX_FIELD_EQ(inName,"set_borderStyle") ) { return hx::Val( set_borderStyle_dyn()); }
		if (HX_FIELD_EQ(inName,"set_borderColor") ) { return hx::Val( set_borderColor_dyn()); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"set_useTextColor") ) { return hx::Val( set_useTextColor_dyn()); }
		if (HX_FIELD_EQ(inName,"updateTextGlyphs") ) { return hx::Val( updateTextGlyphs_dyn()); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"updateImmediately") ) { return hx::Val( updateImmediately); }
		if (HX_FIELD_EQ(inName,"set_letterSpacing") ) { return hx::Val( set_letterSpacing_dyn()); }
		if (HX_FIELD_EQ(inName,"set_autoUpperCase") ) { return hx::Val( set_autoUpperCase_dyn()); }
		if (HX_FIELD_EQ(inName,"set_borderQuality") ) { return hx::Val( set_borderQuality_dyn()); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_pendingTextChange") ) { return hx::Val( _pendingTextChange); }
		if (HX_FIELD_EQ(inName,"forceGraphicUpdate") ) { return hx::Val( forceGraphicUpdate_dyn()); }
		if (HX_FIELD_EQ(inName,"splitLineIntoWords") ) { return hx::Val( splitLineIntoWords_dyn()); }
		if (HX_FIELD_EQ(inName,"set_numSpacesInTab") ) { return hx::Val( set_numSpacesInTab_dyn()); }
		if (HX_FIELD_EQ(inName,"updateBorderGlyphs") ) { return hx::Val( updateBorderGlyphs_dyn()); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"checkPendingChanges") ) { return hx::Val( checkPendingChanges_dyn()); }
		if (HX_FIELD_EQ(inName,"wrapLineByCharacter") ) { return hx::Val( wrapLineByCharacter_dyn()); }
		if (HX_FIELD_EQ(inName,"set_backgroundColor") ) { return hx::Val( set_backgroundColor_dyn()); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_pendingGraphicChange") ) { return hx::Val( _pendingGraphicChange); }
		if (HX_FIELD_EQ(inName,"checkImmediateChanges") ) { return hx::Val( checkImmediateChanges_dyn()); }
		if (HX_FIELD_EQ(inName,"set_updateImmediately") ) { return hx::Val( set_updateImmediately_dyn()); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"_pendingTextGlyphsChange") ) { return hx::Val( _pendingTextGlyphsChange); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"_pendingBorderGlyphsChange") ) { return hx::Val( _pendingBorderGlyphsChange); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val BitmapTextField_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"font") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_font(inValue) );font=inValue.Cast<  ::haxegon::bitmapFont::BitmapFont >(); return inValue; }
		if (HX_FIELD_EQ(inName,"text") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_text(inValue) );text=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"size") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_size(inValue) );size=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_lines") ) { _lines=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_point") ) { _point=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"padding") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_padding(inValue) );padding=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_bitmap") ) { _bitmap=inValue.Cast<  ::openfl::display::Bitmap >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"wordWrap") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_wordWrap(inValue) );wordWrap=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"autoSize") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_autoSize(inValue) );autoSize=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numLines") ) { numLines=inValue.Cast< Int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"alignment") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_alignment(inValue) );alignment=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textWidth") ) { textWidth=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_textColor(inValue) );textColor=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"multiLine") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_multiLine(inValue) );multiLine=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"smoothing") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_smoothing(inValue) );smoothing=inValue.Cast< Bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"wrapByWord") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_wrapByWord(inValue) );wrapByWord=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textHeight") ) { textHeight=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lineHeight") ) { lineHeight=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_tabSpaces") ) { _tabSpaces=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderSize") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderSize(inValue) );borderSize=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"background") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_background(inValue) );background=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textGlyphs") ) { textGlyphs=inValue.Cast<  ::haxegon::bitmapFont::BitmapGlyphCollection >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_linesWidth") ) { _linesWidth=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lineSpacing") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_lineSpacing(inValue) );lineSpacing=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderStyle") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderStyle(inValue) );borderStyle=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderColor(inValue) );borderColor=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_fieldWidth") ) { _fieldWidth=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_bitmapData") ) { _bitmapData=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"useTextColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_useTextColor(inValue) );useTextColor=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shadowOffset") ) { shadowOffset=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_fieldHeight") ) { _fieldHeight=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderGlyphs") ) { borderGlyphs=inValue.Cast<  ::haxegon::bitmapFont::BitmapGlyphCollection >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"letterSpacing") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_letterSpacing(inValue) );letterSpacing=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"autoUpperCase") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_autoUpperCase(inValue) );autoUpperCase=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"borderQuality") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_borderQuality(inValue) );borderQuality=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"numSpacesInTab") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_numSpacesInTab(inValue) );numSpacesInTab=inValue.Cast< Int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"backgroundColor") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_backgroundColor(inValue) );backgroundColor=inValue.Cast< Int >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"updateImmediately") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_updateImmediately(inValue) );updateImmediately=inValue.Cast< Bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_pendingTextChange") ) { _pendingTextChange=inValue.Cast< Bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_pendingGraphicChange") ) { _pendingGraphicChange=inValue.Cast< Bool >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"_pendingTextGlyphsChange") ) { _pendingTextGlyphsChange=inValue.Cast< Bool >(); return inValue; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"_pendingBorderGlyphsChange") ) { _pendingBorderGlyphsChange=inValue.Cast< Bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BitmapTextField_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"));
	outFields->push(HX_HCSTRING("text","\xad","\xcc","\xf9","\x4c"));
	outFields->push(HX_HCSTRING("_lines","\x40","\x25","\xe9","\x70"));
	outFields->push(HX_HCSTRING("_linesWidth","\xa6","\xf8","\x37","\xcb"));
	outFields->push(HX_HCSTRING("alignment","\xe3","\xe2","\x3d","\xea"));
	outFields->push(HX_HCSTRING("lineSpacing","\xef","\xe9","\x0e","\xd0"));
	outFields->push(HX_HCSTRING("letterSpacing","\x3d","\xb7","\x03","\xf5"));
	outFields->push(HX_HCSTRING("autoUpperCase","\xc3","\xd7","\x69","\xb3"));
	outFields->push(HX_HCSTRING("wordWrap","\xb4","\x14","\xdb","\x00"));
	outFields->push(HX_HCSTRING("wrapByWord","\xab","\xdc","\x7f","\x78"));
	outFields->push(HX_HCSTRING("autoSize","\xd0","\x8f","\x79","\x2f"));
	outFields->push(HX_HCSTRING("padding","\xd1","\x59","\x7d","\xd0"));
	outFields->push(HX_HCSTRING("textWidth","\x19","\x46","\x50","\x63"));
	outFields->push(HX_HCSTRING("textHeight","\x74","\x88","\x3c","\x39"));
	outFields->push(HX_HCSTRING("lineHeight","\xfb","\x02","\xf4","\xd6"));
	outFields->push(HX_HCSTRING("numSpacesInTab","\x9d","\x3a","\xd9","\x2e"));
	outFields->push(HX_HCSTRING("_tabSpaces","\xe3","\xd8","\x43","\x75"));
	outFields->push(HX_HCSTRING("textColor","\x76","\x01","\x4a","\xe3"));
	outFields->push(HX_HCSTRING("useTextColor","\x2f","\x74","\xe5","\x52"));
	outFields->push(HX_HCSTRING("borderStyle","\xa5","\x70","\x96","\x10"));
	outFields->push(HX_HCSTRING("borderColor","\xd7","\x3c","\xd5","\xd6"));
	outFields->push(HX_HCSTRING("borderSize","\xcd","\xff","\xed","\x06"));
	outFields->push(HX_HCSTRING("borderQuality","\x33","\x95","\x25","\x79"));
	outFields->push(HX_HCSTRING("shadowOffset","\x93","\xfb","\x0b","\xdc"));
	outFields->push(HX_HCSTRING("background","\xee","\x93","\x1d","\x26"));
	outFields->push(HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d"));
	outFields->push(HX_HCSTRING("multiLine","\x0d","\xff","\xea","\x88"));
	outFields->push(HX_HCSTRING("numLines","\xd9","\xf1","\x11","\x32"));
	outFields->push(HX_HCSTRING("size","\xc1","\xa0","\x53","\x4c"));
	outFields->push(HX_HCSTRING("smoothing","\x74","\xd5","\xe1","\x95"));
	outFields->push(HX_HCSTRING("updateImmediately","\x35","\xbd","\xbc","\xe1"));
	outFields->push(HX_HCSTRING("_pendingTextChange","\xf5","\xc5","\x5a","\x5e"));
	outFields->push(HX_HCSTRING("_pendingGraphicChange","\x40","\xe5","\xaa","\x0e"));
	outFields->push(HX_HCSTRING("_pendingTextGlyphsChange","\x5c","\x94","\x02","\x91"));
	outFields->push(HX_HCSTRING("_pendingBorderGlyphsChange","\x1b","\x65","\x77","\x18"));
	outFields->push(HX_HCSTRING("_fieldWidth","\x0b","\xfc","\x6e","\x6a"));
	outFields->push(HX_HCSTRING("_fieldHeight","\x42","\x06","\xfd","\x6c"));
	outFields->push(HX_HCSTRING("_bitmap","\x8e","\x21","\x83","\x5f"));
	outFields->push(HX_HCSTRING("_bitmapData","\xd8","\x82","\x4a","\x06"));
	outFields->push(HX_HCSTRING("textGlyphs","\xd4","\x79","\x49","\xe5"));
	outFields->push(HX_HCSTRING("borderGlyphs","\x53","\x33","\x92","\x0b"));
	outFields->push(HX_HCSTRING("_point","\x91","\xfb","\x76","\xc2"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo BitmapTextField_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::haxegon::bitmapFont::BitmapFont*/ ,(int)offsetof(BitmapTextField_obj,font),HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43")},
	{hx::fsString,(int)offsetof(BitmapTextField_obj,text),HX_HCSTRING("text","\xad","\xcc","\xf9","\x4c")},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(BitmapTextField_obj,_lines),HX_HCSTRING("_lines","\x40","\x25","\xe9","\x70")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(BitmapTextField_obj,_linesWidth),HX_HCSTRING("_linesWidth","\xa6","\xf8","\x37","\xcb")},
	{hx::fsString,(int)offsetof(BitmapTextField_obj,alignment),HX_HCSTRING("alignment","\xe3","\xe2","\x3d","\xea")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,lineSpacing),HX_HCSTRING("lineSpacing","\xef","\xe9","\x0e","\xd0")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,letterSpacing),HX_HCSTRING("letterSpacing","\x3d","\xb7","\x03","\xf5")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,autoUpperCase),HX_HCSTRING("autoUpperCase","\xc3","\xd7","\x69","\xb3")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,wordWrap),HX_HCSTRING("wordWrap","\xb4","\x14","\xdb","\x00")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,wrapByWord),HX_HCSTRING("wrapByWord","\xab","\xdc","\x7f","\x78")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,autoSize),HX_HCSTRING("autoSize","\xd0","\x8f","\x79","\x2f")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,padding),HX_HCSTRING("padding","\xd1","\x59","\x7d","\xd0")},
	{hx::fsFloat,(int)offsetof(BitmapTextField_obj,textWidth),HX_HCSTRING("textWidth","\x19","\x46","\x50","\x63")},
	{hx::fsFloat,(int)offsetof(BitmapTextField_obj,textHeight),HX_HCSTRING("textHeight","\x74","\x88","\x3c","\x39")},
	{hx::fsFloat,(int)offsetof(BitmapTextField_obj,lineHeight),HX_HCSTRING("lineHeight","\xfb","\x02","\xf4","\xd6")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,numSpacesInTab),HX_HCSTRING("numSpacesInTab","\x9d","\x3a","\xd9","\x2e")},
	{hx::fsString,(int)offsetof(BitmapTextField_obj,_tabSpaces),HX_HCSTRING("_tabSpaces","\xe3","\xd8","\x43","\x75")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,textColor),HX_HCSTRING("textColor","\x76","\x01","\x4a","\xe3")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,useTextColor),HX_HCSTRING("useTextColor","\x2f","\x74","\xe5","\x52")},
	{hx::fsObject /*::haxegon::bitmapFont::TextBorderStyle*/ ,(int)offsetof(BitmapTextField_obj,borderStyle),HX_HCSTRING("borderStyle","\xa5","\x70","\x96","\x10")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,borderColor),HX_HCSTRING("borderColor","\xd7","\x3c","\xd5","\xd6")},
	{hx::fsFloat,(int)offsetof(BitmapTextField_obj,borderSize),HX_HCSTRING("borderSize","\xcd","\xff","\xed","\x06")},
	{hx::fsFloat,(int)offsetof(BitmapTextField_obj,borderQuality),HX_HCSTRING("borderQuality","\x33","\x95","\x25","\x79")},
	{hx::fsObject /*::openfl::geom::Point*/ ,(int)offsetof(BitmapTextField_obj,shadowOffset),HX_HCSTRING("shadowOffset","\x93","\xfb","\x0b","\xdc")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,background),HX_HCSTRING("background","\xee","\x93","\x1d","\x26")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,backgroundColor),HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,multiLine),HX_HCSTRING("multiLine","\x0d","\xff","\xea","\x88")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,numLines),HX_HCSTRING("numLines","\xd9","\xf1","\x11","\x32")},
	{hx::fsFloat,(int)offsetof(BitmapTextField_obj,size),HX_HCSTRING("size","\xc1","\xa0","\x53","\x4c")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,smoothing),HX_HCSTRING("smoothing","\x74","\xd5","\xe1","\x95")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,updateImmediately),HX_HCSTRING("updateImmediately","\x35","\xbd","\xbc","\xe1")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,_pendingTextChange),HX_HCSTRING("_pendingTextChange","\xf5","\xc5","\x5a","\x5e")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,_pendingGraphicChange),HX_HCSTRING("_pendingGraphicChange","\x40","\xe5","\xaa","\x0e")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,_pendingTextGlyphsChange),HX_HCSTRING("_pendingTextGlyphsChange","\x5c","\x94","\x02","\x91")},
	{hx::fsBool,(int)offsetof(BitmapTextField_obj,_pendingBorderGlyphsChange),HX_HCSTRING("_pendingBorderGlyphsChange","\x1b","\x65","\x77","\x18")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,_fieldWidth),HX_HCSTRING("_fieldWidth","\x0b","\xfc","\x6e","\x6a")},
	{hx::fsInt,(int)offsetof(BitmapTextField_obj,_fieldHeight),HX_HCSTRING("_fieldHeight","\x42","\x06","\xfd","\x6c")},
	{hx::fsObject /*::openfl::display::Bitmap*/ ,(int)offsetof(BitmapTextField_obj,_bitmap),HX_HCSTRING("_bitmap","\x8e","\x21","\x83","\x5f")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(int)offsetof(BitmapTextField_obj,_bitmapData),HX_HCSTRING("_bitmapData","\xd8","\x82","\x4a","\x06")},
	{hx::fsObject /*::haxegon::bitmapFont::BitmapGlyphCollection*/ ,(int)offsetof(BitmapTextField_obj,textGlyphs),HX_HCSTRING("textGlyphs","\xd4","\x79","\x49","\xe5")},
	{hx::fsObject /*::haxegon::bitmapFont::BitmapGlyphCollection*/ ,(int)offsetof(BitmapTextField_obj,borderGlyphs),HX_HCSTRING("borderGlyphs","\x53","\x33","\x92","\x0b")},
	{hx::fsObject /*::openfl::geom::Point*/ ,(int)offsetof(BitmapTextField_obj,_point),HX_HCSTRING("_point","\x91","\xfb","\x76","\xc2")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *BitmapTextField_obj_sStaticStorageInfo = 0;
#endif

static ::String BitmapTextField_obj_sMemberFields[] = {
	HX_HCSTRING("font","\xcf","\x5d","\xc0","\x43"),
	HX_HCSTRING("text","\xad","\xcc","\xf9","\x4c"),
	HX_HCSTRING("_lines","\x40","\x25","\xe9","\x70"),
	HX_HCSTRING("_linesWidth","\xa6","\xf8","\x37","\xcb"),
	HX_HCSTRING("alignment","\xe3","\xe2","\x3d","\xea"),
	HX_HCSTRING("lineSpacing","\xef","\xe9","\x0e","\xd0"),
	HX_HCSTRING("letterSpacing","\x3d","\xb7","\x03","\xf5"),
	HX_HCSTRING("autoUpperCase","\xc3","\xd7","\x69","\xb3"),
	HX_HCSTRING("wordWrap","\xb4","\x14","\xdb","\x00"),
	HX_HCSTRING("wrapByWord","\xab","\xdc","\x7f","\x78"),
	HX_HCSTRING("autoSize","\xd0","\x8f","\x79","\x2f"),
	HX_HCSTRING("padding","\xd1","\x59","\x7d","\xd0"),
	HX_HCSTRING("textWidth","\x19","\x46","\x50","\x63"),
	HX_HCSTRING("textHeight","\x74","\x88","\x3c","\x39"),
	HX_HCSTRING("lineHeight","\xfb","\x02","\xf4","\xd6"),
	HX_HCSTRING("numSpacesInTab","\x9d","\x3a","\xd9","\x2e"),
	HX_HCSTRING("_tabSpaces","\xe3","\xd8","\x43","\x75"),
	HX_HCSTRING("textColor","\x76","\x01","\x4a","\xe3"),
	HX_HCSTRING("useTextColor","\x2f","\x74","\xe5","\x52"),
	HX_HCSTRING("borderStyle","\xa5","\x70","\x96","\x10"),
	HX_HCSTRING("borderColor","\xd7","\x3c","\xd5","\xd6"),
	HX_HCSTRING("borderSize","\xcd","\xff","\xed","\x06"),
	HX_HCSTRING("borderQuality","\x33","\x95","\x25","\x79"),
	HX_HCSTRING("shadowOffset","\x93","\xfb","\x0b","\xdc"),
	HX_HCSTRING("background","\xee","\x93","\x1d","\x26"),
	HX_HCSTRING("backgroundColor","\x95","\x4e","\x47","\x0d"),
	HX_HCSTRING("multiLine","\x0d","\xff","\xea","\x88"),
	HX_HCSTRING("numLines","\xd9","\xf1","\x11","\x32"),
	HX_HCSTRING("size","\xc1","\xa0","\x53","\x4c"),
	HX_HCSTRING("smoothing","\x74","\xd5","\xe1","\x95"),
	HX_HCSTRING("updateImmediately","\x35","\xbd","\xbc","\xe1"),
	HX_HCSTRING("_pendingTextChange","\xf5","\xc5","\x5a","\x5e"),
	HX_HCSTRING("_pendingGraphicChange","\x40","\xe5","\xaa","\x0e"),
	HX_HCSTRING("_pendingTextGlyphsChange","\x5c","\x94","\x02","\x91"),
	HX_HCSTRING("_pendingBorderGlyphsChange","\x1b","\x65","\x77","\x18"),
	HX_HCSTRING("_fieldWidth","\x0b","\xfc","\x6e","\x6a"),
	HX_HCSTRING("_fieldHeight","\x42","\x06","\xfd","\x6c"),
	HX_HCSTRING("_bitmap","\x8e","\x21","\x83","\x5f"),
	HX_HCSTRING("_bitmapData","\xd8","\x82","\x4a","\x06"),
	HX_HCSTRING("textGlyphs","\xd4","\x79","\x49","\xe5"),
	HX_HCSTRING("borderGlyphs","\x53","\x33","\x92","\x0b"),
	HX_HCSTRING("_point","\x91","\xfb","\x76","\xc2"),
	HX_HCSTRING("dispose","\x9f","\x80","\x4c","\xbb"),
	HX_HCSTRING("forceGraphicUpdate","\xe6","\x49","\x53","\xc7"),
	HX_HCSTRING("checkImmediateChanges","\xfa","\x19","\x20","\x70"),
	HX_HCSTRING("checkPendingChanges","\x54","\x04","\x94","\x75"),
	HX_HCSTRING("set_textColor","\x59","\xb7","\xb3","\xe9"),
	HX_HCSTRING("set_useTextColor","\x2c","\x4e","\xc6","\xad"),
	HX_HCSTRING("set_text","\xaa","\xe1","\x11","\x7b"),
	HX_HCSTRING("updateText","\x56","\xb7","\xae","\x05"),
	HX_HCSTRING("computeTextSize","\xa5","\xc6","\xcf","\xe6"),
	HX_HCSTRING("getLineWidth","\xfc","\x55","\xb4","\x20"),
	HX_HCSTRING("getStringWidth","\x7f","\xba","\x03","\x5d"),
	HX_HCSTRING("cutLines","\x1d","\x91","\x66","\x89"),
	HX_HCSTRING("wrap","\xca","\x39","\xff","\x4e"),
	HX_HCSTRING("splitLineIntoWords","\xdb","\x44","\xa9","\x26"),
	HX_HCSTRING("wrapLineByWord","\xbf","\xd4","\xc5","\xb8"),
	HX_HCSTRING("wrapLineByCharacter","\x94","\x30","\x3f","\x4a"),
	HX_HCSTRING("updateGraphic","\x9f","\xbf","\x75","\x3f"),
	HX_HCSTRING("blitLine","\xc9","\x3a","\xde","\x68"),
	HX_HCSTRING("setBorderStyle","\x23","\xac","\x54","\xb8"),
	HX_HCSTRING("set_width","\x69","\xfe","\x5c","\xf1"),
	HX_HCSTRING("set_alignment","\xc6","\x98","\xa7","\xf0"),
	HX_HCSTRING("set_multiLine","\xf0","\xb4","\x54","\x8f"),
	HX_HCSTRING("set_font","\xcc","\x72","\xd8","\x71"),
	HX_HCSTRING("set_lineSpacing","\x92","\x1e","\xbc","\x8c"),
	HX_HCSTRING("set_letterSpacing","\xa0","\x9a","\xe1","\x1e"),
	HX_HCSTRING("set_autoUpperCase","\x26","\xbb","\x47","\xdd"),
	HX_HCSTRING("set_wordWrap","\x31","\xec","\xed","\xca"),
	HX_HCSTRING("set_wrapByWord","\x68","\x4d","\x95","\x0e"),
	HX_HCSTRING("set_autoSize","\x4d","\x67","\x8c","\xf9"),
	HX_HCSTRING("set_size","\xbe","\xb5","\x6b","\x7a"),
	HX_HCSTRING("set_padding","\xf4","\xc0","\xe4","\x60"),
	HX_HCSTRING("set_numSpacesInTab","\xda","\x4d","\x22","\xa7"),
	HX_HCSTRING("set_background","\xab","\x04","\x33","\xbc"),
	HX_HCSTRING("set_backgroundColor","\xb8","\x10","\xef","\xd4"),
	HX_HCSTRING("set_borderStyle","\x48","\xa5","\x43","\xcd"),
	HX_HCSTRING("set_borderColor","\x7a","\x71","\x82","\x93"),
	HX_HCSTRING("set_borderSize","\x8a","\x70","\x03","\x9d"),
	HX_HCSTRING("set_borderQuality","\x96","\x78","\x03","\xa3"),
	HX_HCSTRING("get_numLines","\xe2","\xa5","\x2b","\xe7"),
	HX_HCSTRING("get_textWidth","\xf0","\x19","\xb4","\x24"),
	HX_HCSTRING("get_textHeight","\xbd","\x10","\x32","\xaf"),
	HX_HCSTRING("get_lineHeight","\x44","\x8b","\xe9","\x4c"),
	HX_HCSTRING("set_updateImmediately","\x18","\x8e","\x73","\xb4"),
	HX_HCSTRING("set_smoothing","\x57","\x8b","\x4b","\x9c"),
	HX_HCSTRING("updateTextGlyphs","\x3d","\x49","\x35","\x2f"),
	HX_HCSTRING("updateBorderGlyphs","\xfc","\x6e","\x9f","\x83"),
	::String(null()) };

static void BitmapTextField_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(BitmapTextField_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void BitmapTextField_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(BitmapTextField_obj::__mClass,"__mClass");
};

#endif

hx::Class BitmapTextField_obj::__mClass;

void BitmapTextField_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.bitmapFont.BitmapTextField","\x7c","\x80","\x29","\xf9");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = BitmapTextField_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(BitmapTextField_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< BitmapTextField_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = BitmapTextField_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BitmapTextField_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BitmapTextField_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxegon
} // end namespace bitmapFont
