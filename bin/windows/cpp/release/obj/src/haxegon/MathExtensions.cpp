// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxegon_Data
#include <haxegon/Data.h>
#endif
#ifndef INCLUDED_haxegon_MathExtensions
#include <haxegon/MathExtensions.h>
#endif

namespace haxegon{

void MathExtensions_obj::__construct() { }

Dynamic MathExtensions_obj::__CreateEmpty() { return new MathExtensions_obj; }

hx::ObjectPtr< MathExtensions_obj > MathExtensions_obj::__new()
{
	hx::ObjectPtr< MathExtensions_obj > _hx_result = new MathExtensions_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic MathExtensions_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< MathExtensions_obj > _hx_result = new MathExtensions_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::Dynamic MathExtensions_obj::project_circle(hx::Class math,Float x,Float y,Float r, ::Dynamic axis){
            	HX_STACK_FRAME("haxegon.MathExtensions","project_circle",0x6ac179fa,"haxegon.MathExtensions.project_circle","haxegon/MathExtensions.hx",8,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(r,"r")
            	HX_STACK_ARG(axis,"axis")
HXLINE(   9)		HX_VARI( Float,dot) = ::haxegon::MathExtensions_obj::dot(null(),x,y, ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  10)		return  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),(dot - r))
            			->setFixed(1,HX_("y",79,00,00,00),(dot + r)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,project_circle,return )

 ::Dynamic MathExtensions_obj::project_triangle(hx::Class math,::Array< Float > tri, ::Dynamic axis){
            	HX_STACK_FRAME("haxegon.MathExtensions","project_triangle",0x3d7b1532,"haxegon.MathExtensions.project_triangle","haxegon/MathExtensions.hx",13,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(tri,"tri")
            	HX_STACK_ARG(axis,"axis")
HXLINE(  14)		HX_VARI( Float,dot1) = ::haxegon::MathExtensions_obj::dot(null(),tri->__get((int)0),tri->__get((int)1), ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  15)		HX_VARI( Float,dot2) = ::haxegon::MathExtensions_obj::dot(null(),tri->__get((int)2),tri->__get((int)3), ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  16)		HX_VARI( Float,dot3) = ::haxegon::MathExtensions_obj::dot(null(),tri->__get((int)4),tri->__get((int)5), ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  17)		Float _hx_tmp = ::haxegon::MathExtensions_obj::min3(null(),dot1,dot2,dot3);
HXDLIN(  17)		Float _hx_tmp1 = ::haxegon::MathExtensions_obj::max3(null(),dot1,dot2,dot3);
HXDLIN(  17)		return  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),_hx_tmp)
            			->setFixed(1,HX_("y",79,00,00,00),_hx_tmp1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathExtensions_obj,project_triangle,return )

 ::Dynamic MathExtensions_obj::project_rectangle(hx::Class math,Float x,Float y,Float width,Float height, ::Dynamic axis){
            	HX_STACK_FRAME("haxegon.MathExtensions","project_rectangle",0x28731a85,"haxegon.MathExtensions.project_rectangle","haxegon/MathExtensions.hx",20,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(width,"width")
            	HX_STACK_ARG(height,"height")
            	HX_STACK_ARG(axis,"axis")
HXLINE(  21)		HX_VARI( Float,dot1) = ::haxegon::MathExtensions_obj::dot(null(),x,y, ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  22)		HX_VARI( Float,dot2) = ::haxegon::MathExtensions_obj::dot(null(),(x + width),y, ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  23)		HX_VARI( Float,dot3) = ::haxegon::MathExtensions_obj::dot(null(),x,(y + height), ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  24)		HX_VARI( Float,dot4) = ::haxegon::MathExtensions_obj::dot(null(),(x + width),(y + height), ::Dynamic(axis->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(axis->__Field(HX_("y",79,00,00,00),hx::paccDynamic)));
HXLINE(  25)		Float _hx_tmp = ::haxegon::MathExtensions_obj::min4(null(),dot1,dot2,dot3,dot4);
HXDLIN(  25)		Float _hx_tmp1 = ::haxegon::MathExtensions_obj::max4(null(),dot1,dot2,dot3,dot4);
HXDLIN(  25)		return  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),_hx_tmp)
            			->setFixed(1,HX_("y",79,00,00,00),_hx_tmp1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(MathExtensions_obj,project_rectangle,return )

::String MathExtensions_obj::fixed_float(hx::Class math,Float x,Int precision){
            	HX_STACK_FRAME("haxegon.MathExtensions","fixed_float",0xf5dd9ecd,"haxegon.MathExtensions.fixed_float","haxegon/MathExtensions.hx",28,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(precision,"precision")
HXLINE(  29)		HX_VARI( ::String,string) = (HX_("",00,00,00,00) + x);
HXLINE(  30)		HX_VARI( Int,dot) = string.indexOf(HX_(".",2e,00,00,00),null());
HXLINE(  31)		Bool _hx_tmp = (dot == (int)-1);
HXDLIN(  31)		if (_hx_tmp) {
HXLINE(  32)			hx::AddEq(string,HX_(".",2e,00,00,00));
HXLINE(  33)			dot = (string.length - (int)1);
            		}
HXLINE(  35)		{
HXLINE(  35)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  35)			HX_VARI( Int,_g) = ((precision - (string.length - dot)) + (int)1);
HXDLIN(  35)			while((_g1 < _g)){
HXLINE(  35)				++_g1;
HXLINE(  36)				hx::AddEq(string,HX_("0",30,00,00,00));
            			}
            		}
HXLINE(  38)		return string.substr((int)0,((dot + precision) + (int)1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathExtensions_obj,fixed_float,return )

Float MathExtensions_obj::collision_1d(hx::Class math,Float a1,Float a2,Float b1,Float b2){
            	HX_STACK_FRAME("haxegon.MathExtensions","collision_1d",0x77662f04,"haxegon.MathExtensions.collision_1d","haxegon/MathExtensions.hx",43,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(a1,"a1")
            	HX_STACK_ARG(a2,"a2")
            	HX_STACK_ARG(b1,"b1")
            	HX_STACK_ARG(b2,"b2")
HXLINE(  43)		Bool _hx_tmp;
HXDLIN(  43)		if ((a1 < b1)) {
HXLINE(  43)			_hx_tmp = (b2 < a2);
            		}
            		else {
HXLINE(  43)			_hx_tmp = false;
            		}
HXDLIN(  43)		if (_hx_tmp) {
HXLINE(  44)			if (((b2 - a1) < (a2 - b1))) {
HXLINE(  45)				return (b2 - a1);
            			}
            			else {
HXLINE(  47)				return (b1 - a2);
            			}
            		}
            		else {
HXLINE(  49)			Bool _hx_tmp1;
HXDLIN(  49)			if ((b1 < a1)) {
HXLINE(  49)				_hx_tmp1 = (a2 < b2);
            			}
            			else {
HXLINE(  49)				_hx_tmp1 = false;
            			}
HXDLIN(  49)			if (_hx_tmp1) {
HXLINE(  50)				if (((a2 - b1) < (b2 - a1))) {
HXLINE(  51)					return (b1 - a2);
            				}
            				else {
HXLINE(  53)					return (b2 - a1);
            				}
            			}
            			else {
HXLINE(  55)				Bool _hx_tmp2;
HXDLIN(  55)				if ((b1 < a1)) {
HXLINE(  55)					_hx_tmp2 = (a1 < b2);
            				}
            				else {
HXLINE(  55)					_hx_tmp2 = false;
            				}
HXDLIN(  55)				if (_hx_tmp2) {
HXLINE(  56)					return (b2 - a1);
            				}
            				else {
HXLINE(  57)					Bool _hx_tmp3;
HXDLIN(  57)					if ((b1 < a2)) {
HXLINE(  57)						_hx_tmp3 = (a2 < b2);
            					}
            					else {
HXLINE(  57)						_hx_tmp3 = false;
            					}
HXDLIN(  57)					if (_hx_tmp3) {
HXLINE(  58)						return (b1 - a2);
            					}
            					else {
HXLINE(  59)						Bool _hx_tmp4;
HXDLIN(  59)						if ((a1 == b1)) {
HXLINE(  59)							_hx_tmp4 = (a2 == b2);
            						}
            						else {
HXLINE(  59)							_hx_tmp4 = false;
            						}
HXDLIN(  59)						if (_hx_tmp4) {
HXLINE(  60)							return (a2 - a1);
            						}
            						else {
HXLINE(  62)							return (int)0;
            						}
            					}
            				}
            			}
            		}
HXLINE(  43)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,collision_1d,return )

Float MathExtensions_obj::max3(hx::Class math,Float x1,Float x2,Float x3){
            	HX_STACK_FRAME("haxegon.MathExtensions","max3",0x9f3ee413,"haxegon.MathExtensions.max3","haxegon/MathExtensions.hx",67,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(x3,"x3")
HXLINE(  67)		Float _hx_tmp = ::Math_obj::max(x1,x2);
HXDLIN(  67)		return ::Math_obj::max(_hx_tmp,x3);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,max3,return )

Float MathExtensions_obj::max4(hx::Class math,Float x1,Float x2,Float x3,Float x4){
            	HX_STACK_FRAME("haxegon.MathExtensions","max4",0x9f3ee414,"haxegon.MathExtensions.max4","haxegon/MathExtensions.hx",70,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(x3,"x3")
            	HX_STACK_ARG(x4,"x4")
HXLINE(  70)		Float _hx_tmp = ::Math_obj::max(x1,x2);
HXDLIN(  70)		Float _hx_tmp1 = ::Math_obj::max(_hx_tmp,x3);
HXDLIN(  70)		return ::Math_obj::max(_hx_tmp1,x4);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,max4,return )

Float MathExtensions_obj::min3(hx::Class math,Float x1,Float x2,Float x3){
            	HX_STACK_FRAME("haxegon.MathExtensions","min3",0x9f44ed65,"haxegon.MathExtensions.min3","haxegon/MathExtensions.hx",73,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(x3,"x3")
HXLINE(  73)		Float _hx_tmp = ::Math_obj::min(x1,x2);
HXDLIN(  73)		return ::Math_obj::min(_hx_tmp,x3);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,min3,return )

Float MathExtensions_obj::min4(hx::Class math,Float x1,Float x2,Float x3,Float x4){
            	HX_STACK_FRAME("haxegon.MathExtensions","min4",0x9f44ed66,"haxegon.MathExtensions.min4","haxegon/MathExtensions.hx",76,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(x3,"x3")
            	HX_STACK_ARG(x4,"x4")
HXLINE(  76)		Float _hx_tmp = ::Math_obj::min(x1,x2);
HXDLIN(  76)		Float _hx_tmp1 = ::Math_obj::min(_hx_tmp,x3);
HXDLIN(  76)		return ::Math_obj::min(_hx_tmp1,x4);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,min4,return )

void MathExtensions_obj::scale_vertices(hx::Class math,::Array< Float > vertices,Float scale, ::Dynamic x, ::Dynamic y){
            	HX_STACK_FRAME("haxegon.MathExtensions","scale_vertices",0x74b6d392,"haxegon.MathExtensions.scale_vertices","haxegon/MathExtensions.hx",79,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(vertices,"vertices")
            	HX_STACK_ARG(scale,"scale")
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
HXLINE(  80)		Bool _hx_tmp;
HXDLIN(  80)		Bool _hx_tmp1 = hx::IsNotNull( x );
HXDLIN(  80)		if (_hx_tmp1) {
HXLINE(  80)			_hx_tmp = hx::IsNull( y );
            		}
            		else {
HXLINE(  80)			_hx_tmp = true;
            		}
HXDLIN(  80)		if (_hx_tmp) {
HXLINE(  81)			HX_VARI(  ::Dynamic,centroid) = ::haxegon::MathExtensions_obj::poly_centroid(null(),vertices);
HXLINE(  82)			x = ( (Float)(centroid->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) );
HXLINE(  83)			y = ( (Float)(centroid->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) );
            		}
HXLINE(  85)		{
HXLINE(  85)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  85)			Float _hx_tmp2 = ((Float)vertices->length / (Float)(int)2);
HXDLIN(  85)			HX_VARI( Int,_g) = ::Std_obj::_hx_int(_hx_tmp2);
HXDLIN(  85)			while((_g1 < _g)){
HXLINE(  85)				HX_VARI( Int,i) = _g1++;
HXLINE(  86)				Int _hx_tmp3 = (i * (int)2);
HXDLIN(  86)				Float _hx_tmp4 = ((vertices->__get((i * (int)2)) - x) * scale);
HXDLIN(  86)				vertices[_hx_tmp3] = (x + _hx_tmp4);
HXLINE(  87)				Int _hx_tmp5 = ((i * (int)2) + (int)1);
HXDLIN(  87)				Float _hx_tmp6 = (vertices->__get(((i * (int)2) + (int)1)) - y);
HXDLIN(  87)				vertices[_hx_tmp5] = (y + (_hx_tmp6 * scale));
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,scale_vertices,(void))

void MathExtensions_obj::translate_vertices(hx::Class math,::Array< Float > vertices,Float dx,Float dy){
            	HX_STACK_FRAME("haxegon.MathExtensions","translate_vertices",0x1ab8e44e,"haxegon.MathExtensions.translate_vertices","haxegon/MathExtensions.hx",92,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(vertices,"vertices")
            	HX_STACK_ARG(dx,"dx")
            	HX_STACK_ARG(dy,"dy")
HXLINE(  92)		HX_VARI( Int,_g1) = (int)0;
HXDLIN(  92)		Float _hx_tmp = ((Float)vertices->length / (Float)(int)2);
HXDLIN(  92)		HX_VARI( Int,_g) = ::Std_obj::_hx_int(_hx_tmp);
HXDLIN(  92)		while((_g1 < _g)){
HXLINE(  92)			HX_VARI( Int,i) = _g1++;
HXLINE(  93)			hx::AddEq(vertices[(i * (int)2)],dx);
HXLINE(  94)			hx::AddEq(vertices[((i * (int)2) + (int)1)],dy);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,translate_vertices,(void))

::Array< Float > MathExtensions_obj::rotate_vertices(hx::Class math,::Array< Float > vertices,Float origin_x,Float origin_y,Float angle){
            	HX_STACK_FRAME("haxegon.MathExtensions","rotate_vertices",0xe7f6c519,"haxegon.MathExtensions.rotate_vertices","haxegon/MathExtensions.hx",98,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(vertices,"vertices")
            	HX_STACK_ARG(origin_x,"origin_x")
            	HX_STACK_ARG(origin_y,"origin_y")
            	HX_STACK_ARG(angle,"angle")
HXLINE(  99)		HX_VARI(  ::Dynamic,rotated) =  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),((Float)0.0))
            			->setFixed(1,HX_("y",79,00,00,00),((Float)0.0)));
HXLINE( 100)		{
HXLINE( 100)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 100)			Float _hx_tmp = ((Float)vertices->length / (Float)(int)2);
HXDLIN( 100)			HX_VARI( Int,_g) = ::Std_obj::_hx_int(_hx_tmp);
HXDLIN( 100)			while((_g1 < _g)){
HXLINE( 100)				HX_VARI( Int,i) = _g1++;
HXLINE( 101)				rotated->__SetField(HX_("x",78,00,00,00),vertices->__get((i * (int)2)),hx::paccDynamic);
HXLINE( 102)				rotated->__SetField(HX_("y",79,00,00,00),vertices->__get(((i * (int)2) + (int)1)),hx::paccDynamic);
HXLINE( 103)				::haxegon::MathExtensions_obj::rotate_vector(null(),rotated,origin_x,origin_y,angle);
HXLINE( 104)				vertices[(i * (int)2)] = ( (Float)(rotated->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) );
HXLINE( 105)				vertices[((i * (int)2) + (int)1)] = ( (Float)(rotated->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) );
            			}
            		}
HXLINE( 107)		return vertices;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,rotate_vertices,return )

void MathExtensions_obj::rotate_vector(hx::Class math, ::Dynamic point,Float origin_x,Float origin_y,Float angle){
            	HX_STACK_FRAME("haxegon.MathExtensions","rotate_vector",0xcc8d2de3,"haxegon.MathExtensions.rotate_vector","haxegon/MathExtensions.hx",110,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(point,"point")
            	HX_STACK_ARG(origin_x,"origin_x")
            	HX_STACK_ARG(origin_y,"origin_y")
            	HX_STACK_ARG(angle,"angle")
HXLINE( 111)		Float _hx_tmp = ::haxegon::MathExtensions_obj::deg_to_rad(null(),angle);
HXDLIN( 111)		HX_VARI( Float,cos) = ::Math_obj::cos(_hx_tmp);
HXLINE( 112)		Float _hx_tmp1 = ::haxegon::MathExtensions_obj::deg_to_rad(null(),angle);
HXDLIN( 112)		HX_VARI( Float,sin) = ::Math_obj::sin(_hx_tmp1);
HXLINE( 113)		hx::SubEq(hx::FieldRef((point).mPtr,HX_("x",78,00,00,00)),origin_x);
HXLINE( 114)		hx::SubEq(hx::FieldRef((point).mPtr,HX_("y",79,00,00,00)),origin_y);
HXLINE( 115)		HX_VARI( Float,temp_x) = ( (Float)(point->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) );
HXLINE( 116)		HX_VARI( Float,temp_y) = ( (Float)(point->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) );
HXLINE( 117)		point->__SetField(HX_("x",78,00,00,00),((temp_x * cos) - (temp_y * sin)),hx::paccDynamic);
HXLINE( 118)		point->__SetField(HX_("y",79,00,00,00),((temp_x * sin) + (temp_y * cos)),hx::paccDynamic);
HXLINE( 119)		hx::AddEq(hx::FieldRef((point).mPtr,HX_("x",78,00,00,00)),origin_x);
HXLINE( 120)		hx::AddEq(hx::FieldRef((point).mPtr,HX_("y",79,00,00,00)),origin_y);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,rotate_vector,(void))

Float MathExtensions_obj::dot(hx::Class math,Float ux,Float uy,Float vx,Float vy){
            	HX_STACK_FRAME("haxegon.MathExtensions","dot",0x7cab7005,"haxegon.MathExtensions.dot","haxegon/MathExtensions.hx",124,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(ux,"ux")
            	HX_STACK_ARG(uy,"uy")
            	HX_STACK_ARG(vx,"vx")
            	HX_STACK_ARG(vy,"vy")
HXLINE( 124)		return ((ux * vx) + (uy * vy));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,dot,return )

 ::Dynamic MathExtensions_obj::normalize(hx::Class math, ::Dynamic v){
            	HX_STACK_FRAME("haxegon.MathExtensions","normalize",0xa385aa09,"haxegon.MathExtensions.normalize","haxegon/MathExtensions.hx",127,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(v,"v")
HXLINE( 128)		Float _hx_tmp = ((( (Float)(v->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) ) * ( (Float)(v->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) )) + (( (Float)(v->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) ) * ( (Float)(v->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) )));
HXDLIN( 128)		HX_VARI( Float,length) = ::Math_obj::sqrt(_hx_tmp);
HXLINE( 129)		hx::DivEq(hx::FieldRef((v).mPtr,HX_("x",78,00,00,00)),length);
HXLINE( 130)		hx::DivEq(hx::FieldRef((v).mPtr,HX_("y",79,00,00,00)),length);
HXLINE( 131)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,normalize,return )

 ::Dynamic MathExtensions_obj::project(hx::Class math,Float ux,Float uy,Float vx,Float vy){
            	HX_STACK_FRAME("haxegon.MathExtensions","project",0xfb94ae55,"haxegon.MathExtensions.project","haxegon/MathExtensions.hx",134,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(ux,"ux")
            	HX_STACK_ARG(uy,"uy")
            	HX_STACK_ARG(vx,"vx")
            	HX_STACK_ARG(vy,"vy")
HXLINE( 135)		HX_VARI( Float,dp) = ::haxegon::MathExtensions_obj::dot(null(),ux,uy,vx,vy);
HXLINE( 140)		return  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),(((Float)dp / (Float)((vx * vx) + (vy * vy))) * ux))
            			->setFixed(1,HX_("y",79,00,00,00),(((Float)dp / (Float)((vx * vx) + (vy * vy))) * uy)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,project,return )

Float MathExtensions_obj::line_point_sign(hx::Class math,Float px,Float py,Float lx1,Float ly1,Float lx2,Float ly2){
            	HX_STACK_FRAME("haxegon.MathExtensions","line_point_sign",0x69255ef3,"haxegon.MathExtensions.line_point_sign","haxegon/MathExtensions.hx",144,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(px,"px")
            	HX_STACK_ARG(py,"py")
            	HX_STACK_ARG(lx1,"lx1")
            	HX_STACK_ARG(ly1,"ly1")
            	HX_STACK_ARG(lx2,"lx2")
            	HX_STACK_ARG(ly2,"ly2")
HXLINE( 144)		return (((px - lx2) * (ly1 - ly2)) - ((lx1 - lx2) * (py - ly2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(MathExtensions_obj,line_point_sign,return )

 ::Dynamic MathExtensions_obj::poly_centroid(hx::Class math,::Array< Float > poly){
            	HX_STACK_FRAME("haxegon.MathExtensions","poly_centroid",0xf470904f,"haxegon.MathExtensions.poly_centroid","haxegon/MathExtensions.hx",147,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(poly,"poly")
HXLINE( 147)		HX_VARI( Float,off_x) = poly->__get((int)0);
HXDLIN( 147)		HX_VARI( Float,off_y) = poly->__get((int)1);
HXLINE( 149)		HX_VARI( Float,twicearea) = ((Float)0.0);
HXLINE( 150)		HX_VARI( Float,x) = ((Float)0.0);
HXLINE( 151)		HX_VARI( Float,y) = ((Float)0.0);
HXLINE( 152)		HX_VAR(  ::Dynamic,p1);
HXLINE( 153)		HX_VAR(  ::Dynamic,p2);
HXLINE( 154)		HX_VAR( Float,f);
HXLINE( 155)		HX_VARI( Int,i) = (int)0;
HXLINE( 156)		Float _hx_tmp = (((Float)poly->length / (Float)(int)2) - (int)1);
HXDLIN( 156)		HX_VARI( Int,j) = ::Std_obj::_hx_int(_hx_tmp);
HXLINE( 157)		while((i < ((Float)poly->length / (Float)(int)2))){
HXLINE( 158)			p1 =  ::Dynamic(hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("x",78,00,00,00),poly->__get((i * (int)2)))
            				->setFixed(1,HX_("y",79,00,00,00),poly->__get(((i * (int)2) + (int)1))));
HXLINE( 159)			p2 =  ::Dynamic(hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("x",78,00,00,00),poly->__get((j * (int)2)))
            				->setFixed(1,HX_("y",79,00,00,00),poly->__get(((j * (int)2) + (int)1))));
HXLINE( 160)			f = (((( (Float)(p1->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) ) - off_x) * (( (Float)(p2->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) ) - off_y)) - ((( (Float)(p2->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) ) - off_x) * (( (Float)(p1->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) ) - off_y)));
HXLINE( 161)			hx::AddEq(twicearea,f);
HXLINE( 162)			hx::AddEq(x,(((( (Float)(p1->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) ) + ( (Float)(p2->__Field(HX_("x",78,00,00,00),hx::paccDynamic)) )) - ((int)2 * off_x)) * f));
HXLINE( 163)			hx::AddEq(y,(((( (Float)(p1->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) ) + ( (Float)(p2->__Field(HX_("y",79,00,00,00),hx::paccDynamic)) )) - ((int)2 * off_y)) * f));
HXLINE( 164)			j = i++;
            		}
HXLINE( 167)		f = (twicearea * (int)3);
HXLINE( 169)		return  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),(((Float)x / (Float)f) + off_x))
            			->setFixed(1,HX_("y",79,00,00,00),(((Float)y / (Float)f) + off_y)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,poly_centroid,return )

Bool MathExtensions_obj::line_line_intersect(hx::Class math,Float p0_x,Float p0_y,Float p1_x,Float p1_y,Float p2_x,Float p2_y,Float p3_x,Float p3_y, ::Dynamic intersection){
            	HX_STACK_FRAME("haxegon.MathExtensions","line_line_intersect",0xf834b63b,"haxegon.MathExtensions.line_line_intersect","haxegon/MathExtensions.hx",175,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(p0_x,"p0_x")
            	HX_STACK_ARG(p0_y,"p0_y")
            	HX_STACK_ARG(p1_x,"p1_x")
            	HX_STACK_ARG(p1_y,"p1_y")
            	HX_STACK_ARG(p2_x,"p2_x")
            	HX_STACK_ARG(p2_y,"p2_y")
            	HX_STACK_ARG(p3_x,"p3_x")
            	HX_STACK_ARG(p3_y,"p3_y")
            	HX_STACK_ARG(intersection,"intersection")
HXLINE( 176)		HX_VARI( Float,s1_x) = (p1_x - p0_x);
HXLINE( 177)		HX_VARI( Float,s1_y) = (p1_y - p0_y);
HXLINE( 178)		HX_VARI( Float,s2_x) = (p3_x - p2_x);
HXLINE( 179)		HX_VARI( Float,s2_y) = (p3_y - p2_y);
HXLINE( 181)		HX_VARI( Float,s) = ((Float)((-(s1_y) * (p0_x - p2_x)) + (s1_x * (p0_y - p2_y))) / (Float)((-(s2_x) * s1_y) + (s1_x * s2_y)));
HXLINE( 182)		HX_VARI( Float,t) = ((Float)((s2_x * (p0_y - p2_y)) - (s2_y * (p0_x - p2_x))) / (Float)((-(s2_x) * s1_y) + (s1_x * s2_y)));
HXLINE( 184)		Bool _hx_tmp;
HXDLIN( 184)		Bool _hx_tmp1;
HXDLIN( 184)		Bool _hx_tmp2;
HXDLIN( 184)		if ((s >= (int)0)) {
HXLINE( 184)			_hx_tmp2 = (s <= (int)1);
            		}
            		else {
HXLINE( 184)			_hx_tmp2 = false;
            		}
HXDLIN( 184)		if (_hx_tmp2) {
HXLINE( 184)			_hx_tmp1 = (t >= (int)0);
            		}
            		else {
HXLINE( 184)			_hx_tmp1 = false;
            		}
HXDLIN( 184)		if (_hx_tmp1) {
HXLINE( 184)			_hx_tmp = (t <= (int)1);
            		}
            		else {
HXLINE( 184)			_hx_tmp = false;
            		}
HXDLIN( 184)		if (_hx_tmp) {
HXLINE( 185)			Bool _hx_tmp3 = hx::IsNotNull( intersection );
HXDLIN( 185)			if (_hx_tmp3) {
HXLINE( 186)				intersection->__SetField(HX_("x",78,00,00,00),(p0_x + (t * s1_x)),hx::paccDynamic);
HXLINE( 187)				intersection->__SetField(HX_("y",79,00,00,00),(p0_y + (t * s1_y)),hx::paccDynamic);
            			}
HXLINE( 189)			return true;
            		}
            		else {
HXLINE( 191)			return false;
            		}
HXLINE( 184)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(MathExtensions_obj,line_line_intersect,return )

Bool MathExtensions_obj::point_box_intersect(hx::Class math,Float point_x,Float point_y,Float box_x,Float box_y,Float box_width,Float box_height){
            	HX_STACK_FRAME("haxegon.MathExtensions","point_box_intersect",0x2c83cc78,"haxegon.MathExtensions.point_box_intersect","haxegon/MathExtensions.hx",196,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(point_x,"point_x")
            	HX_STACK_ARG(point_y,"point_y")
            	HX_STACK_ARG(box_x,"box_x")
            	HX_STACK_ARG(box_y,"box_y")
            	HX_STACK_ARG(box_width,"box_width")
            	HX_STACK_ARG(box_height,"box_height")
HXLINE( 196)		Bool _hx_tmp;
HXDLIN( 196)		Bool _hx_tmp1;
HXDLIN( 196)		if ((point_x > box_x)) {
HXLINE( 196)			_hx_tmp1 = (point_x < (box_x + box_width));
            		}
            		else {
HXLINE( 196)			_hx_tmp1 = false;
            		}
HXDLIN( 196)		if (_hx_tmp1) {
HXLINE( 196)			_hx_tmp = (point_y > box_y);
            		}
            		else {
HXLINE( 196)			_hx_tmp = false;
            		}
HXDLIN( 196)		if (_hx_tmp) {
HXLINE( 196)			return (point_y < (box_y + box_height));
            		}
            		else {
HXLINE( 196)			return false;
            		}
HXDLIN( 196)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(MathExtensions_obj,point_box_intersect,return )

Bool MathExtensions_obj::box_box_intersect(hx::Class math,Float x1,Float y1,Float width1,Float height1,Float x2,Float y2,Float width2,Float height2){
            	HX_STACK_FRAME("haxegon.MathExtensions","box_box_intersect",0xf91cb073,"haxegon.MathExtensions.box_box_intersect","haxegon/MathExtensions.hx",202,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(width1,"width1")
            	HX_STACK_ARG(height1,"height1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
            	HX_STACK_ARG(width2,"width2")
            	HX_STACK_ARG(height2,"height2")
HXLINE( 202)		Bool _hx_tmp;
HXDLIN( 202)		Bool _hx_tmp1;
HXDLIN( 202)		if ((x1 < (x2 + width2))) {
HXLINE( 202)			_hx_tmp1 = ((x1 + width1) > x2);
            		}
            		else {
HXLINE( 202)			_hx_tmp1 = false;
            		}
HXDLIN( 202)		if (_hx_tmp1) {
HXLINE( 202)			_hx_tmp = (y1 < (y2 + height2));
            		}
            		else {
HXLINE( 202)			_hx_tmp = false;
            		}
HXDLIN( 202)		if (_hx_tmp) {
HXLINE( 202)			return ((y1 + height1) > y2);
            		}
            		else {
HXLINE( 202)			return false;
            		}
HXDLIN( 202)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(MathExtensions_obj,box_box_intersect,return )

Bool MathExtensions_obj::circle_circle_intersect(hx::Class math,Float x1,Float y1,Float r1,Float x2,Float y2,Float r2){
            	HX_STACK_FRAME("haxegon.MathExtensions","circle_circle_intersect",0x0063a07b,"haxegon.MathExtensions.circle_circle_intersect","haxegon/MathExtensions.hx",206,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(r1,"r1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
            	HX_STACK_ARG(r2,"r2")
HXLINE( 206)		Float _hx_tmp = ::haxegon::MathExtensions_obj::dst2(null(),x1,y1,x2,y2);
HXDLIN( 206)		return (_hx_tmp < ((r1 * r1) + (r2 * r2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(MathExtensions_obj,circle_circle_intersect,return )

Bool MathExtensions_obj::circle_polygon_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,::Array< Float > polygon){
            	HX_STACK_FRAME("haxegon.MathExtensions","circle_polygon_intersect",0x6136af6f,"haxegon.MathExtensions.circle_polygon_intersect","haxegon/MathExtensions.hx",209,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(circle_x,"circle_x")
            	HX_STACK_ARG(circle_y,"circle_y")
            	HX_STACK_ARG(circle_radius,"circle_radius")
            	HX_STACK_ARG(polygon,"polygon")
HXLINE( 210)		{
HXLINE( 210)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 210)			Float _hx_tmp = (((Float)polygon->length / (Float)(int)2) - (int)1);
HXDLIN( 210)			HX_VARI( Int,_g) = ::Std_obj::_hx_int(_hx_tmp);
HXDLIN( 210)			while((_g1 < _g)){
HXLINE( 210)				HX_VARI( Int,i) = _g1++;
HXLINE( 211)				Float _hx_tmp1 = polygon->__get((i * (int)2));
HXDLIN( 211)				Float _hx_tmp2 = polygon->__get(((i * (int)2) + (int)1));
HXDLIN( 211)				Float _hx_tmp3 = polygon->__get(((i * (int)2) + (int)2));
HXDLIN( 211)				Float _hx_tmp4 = polygon->__get(((i * (int)2) + (int)3));
HXDLIN( 211)				Bool _hx_tmp5 = ::haxegon::MathExtensions_obj::circle_line_intersect(null(),circle_x,circle_y,circle_radius,_hx_tmp1,_hx_tmp2,_hx_tmp3,_hx_tmp4);
HXDLIN( 211)				if (_hx_tmp5) {
HXLINE( 212)					return true;
            				}
            			}
            		}
HXLINE( 215)		Float _hx_tmp6 = polygon->__get((polygon->length - (int)2));
HXDLIN( 215)		Float _hx_tmp7 = polygon->__get((polygon->length - (int)1));
HXDLIN( 215)		Float _hx_tmp8 = polygon->__get((int)0);
HXDLIN( 215)		Float _hx_tmp9 = polygon->__get((int)1);
HXDLIN( 215)		Bool _hx_tmp10 = ::haxegon::MathExtensions_obj::circle_line_intersect(null(),circle_x,circle_y,circle_radius,_hx_tmp6,_hx_tmp7,_hx_tmp8,_hx_tmp9);
HXDLIN( 215)		if (_hx_tmp10) {
HXLINE( 216)			return true;
            		}
            		else {
HXLINE( 218)			return false;
            		}
HXLINE( 215)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,circle_polygon_intersect,return )

Bool MathExtensions_obj::circle_tri_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,::Array< Float > tri){
            	HX_STACK_FRAME("haxegon.MathExtensions","circle_tri_intersect",0x0bebeee0,"haxegon.MathExtensions.circle_tri_intersect","haxegon/MathExtensions.hx",223,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(circle_x,"circle_x")
            	HX_STACK_ARG(circle_y,"circle_y")
            	HX_STACK_ARG(circle_radius,"circle_radius")
            	HX_STACK_ARG(tri,"tri")
HXLINE( 223)		Bool _hx_tmp;
HXDLIN( 223)		Float _hx_tmp1 = tri->__get((int)0);
HXDLIN( 223)		Float _hx_tmp2 = tri->__get((int)1);
HXDLIN( 223)		Float _hx_tmp3 = tri->__get((int)2);
HXDLIN( 223)		Float _hx_tmp4 = tri->__get((int)3);
HXDLIN( 223)		Bool _hx_tmp5 = !(::haxegon::MathExtensions_obj::circle_line_intersect(null(),circle_x,circle_y,circle_radius,_hx_tmp1,_hx_tmp2,_hx_tmp3,_hx_tmp4));
HXDLIN( 223)		if (_hx_tmp5) {
HXLINE( 224)			Float _hx_tmp6 = tri->__get((int)2);
HXDLIN( 224)			Float _hx_tmp7 = tri->__get((int)3);
HXDLIN( 224)			Float _hx_tmp8 = tri->__get((int)4);
HXDLIN( 224)			Float _hx_tmp9 = tri->__get((int)5);
HXLINE( 223)			_hx_tmp = ::haxegon::MathExtensions_obj::circle_line_intersect(null(),circle_x,circle_y,circle_radius,_hx_tmp6,_hx_tmp7,_hx_tmp8,_hx_tmp9);
            		}
            		else {
HXLINE( 223)			_hx_tmp = true;
            		}
HXDLIN( 223)		if (!(_hx_tmp)) {
HXLINE( 225)			Float _hx_tmp10 = tri->__get((int)4);
HXDLIN( 225)			Float _hx_tmp11 = tri->__get((int)5);
HXDLIN( 225)			Float _hx_tmp12 = tri->__get((int)0);
HXDLIN( 225)			Float _hx_tmp13 = tri->__get((int)1);
HXLINE( 223)			return ::haxegon::MathExtensions_obj::circle_line_intersect(null(),circle_x,circle_y,circle_radius,_hx_tmp10,_hx_tmp11,_hx_tmp12,_hx_tmp13);
            		}
            		else {
HXLINE( 223)			return true;
            		}
HXDLIN( 223)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,circle_tri_intersect,return )

Bool MathExtensions_obj::circle_line_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,Float line_x1,Float line_y1,Float line_x2,Float line_y2){
            	HX_STACK_FRAME("haxegon.MathExtensions","circle_line_intersect",0xe175729f,"haxegon.MathExtensions.circle_line_intersect","haxegon/MathExtensions.hx",229,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(circle_x,"circle_x")
            	HX_STACK_ARG(circle_y,"circle_y")
            	HX_STACK_ARG(circle_radius,"circle_radius")
            	HX_STACK_ARG(line_x1,"line_x1")
            	HX_STACK_ARG(line_y1,"line_y1")
            	HX_STACK_ARG(line_x2,"line_x2")
            	HX_STACK_ARG(line_y2,"line_y2")
HXLINE( 229)		Float _hx_tmp = ::haxegon::MathExtensions_obj::point_line_dst(null(),circle_x,circle_y,line_x1,line_y1,line_x2,line_y2);
HXDLIN( 229)		return (_hx_tmp < circle_radius);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(MathExtensions_obj,circle_line_intersect,return )

Bool MathExtensions_obj::circle_point_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,Float point_x,Float point_y){
            	HX_STACK_FRAME("haxegon.MathExtensions","circle_point_intersect",0x88b03985,"haxegon.MathExtensions.circle_point_intersect","haxegon/MathExtensions.hx",233,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(circle_x,"circle_x")
            	HX_STACK_ARG(circle_y,"circle_y")
            	HX_STACK_ARG(circle_radius,"circle_radius")
            	HX_STACK_ARG(point_x,"point_x")
            	HX_STACK_ARG(point_y,"point_y")
HXLINE( 233)		Float _hx_tmp = ::haxegon::MathExtensions_obj::dst2(null(),circle_x,circle_y,point_x,point_y);
HXDLIN( 233)		return (_hx_tmp < (circle_radius * circle_radius));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(MathExtensions_obj,circle_point_intersect,return )

Float MathExtensions_obj::point_line_dst2(hx::Class math,Float point_x,Float point_y,Float line_x1,Float line_y1,Float line_x2,Float line_y2){
            	HX_STACK_FRAME("haxegon.MathExtensions","point_line_dst2",0x8b57d985,"haxegon.MathExtensions.point_line_dst2","haxegon/MathExtensions.hx",236,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(point_x,"point_x")
            	HX_STACK_ARG(point_y,"point_y")
            	HX_STACK_ARG(line_x1,"line_x1")
            	HX_STACK_ARG(line_y1,"line_y1")
            	HX_STACK_ARG(line_x2,"line_x2")
            	HX_STACK_ARG(line_y2,"line_y2")
HXLINE( 237)		HX_VARI( Float,line_length2) = ::haxegon::MathExtensions_obj::dst2(null(),line_x1,line_y1,line_x2,line_y2);
HXLINE( 238)		if ((line_length2 == (int)0)) {
HXLINE( 239)			return ::haxegon::MathExtensions_obj::dst(null(),point_x,point_y,line_x1,line_y1);
            		}
HXLINE( 242)		HX_VARI( Float,t) = ((Float)(((point_x - line_x1) * (line_x2 - line_x1)) + ((point_y - line_y1) * (line_y2 - line_y1))) / (Float)line_length2);
HXLINE( 243)		Float _hx_tmp = ::Math_obj::min((int)1,t);
HXDLIN( 243)		t = ::Math_obj::max((int)0,_hx_tmp);
HXLINE( 244)		return ::haxegon::MathExtensions_obj::dst2(null(),point_x,point_y,(line_x1 + (t * (line_x2 - line_x1))),(line_y1 + (t * (line_y2 - line_y1))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(MathExtensions_obj,point_line_dst2,return )

Float MathExtensions_obj::point_line_dst(hx::Class math,Float point_x,Float point_y,Float line_x1,Float line_y1,Float line_x2,Float line_y2){
            	HX_STACK_FRAME("haxegon.MathExtensions","point_line_dst",0xed1bf20d,"haxegon.MathExtensions.point_line_dst","haxegon/MathExtensions.hx",247,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(point_x,"point_x")
            	HX_STACK_ARG(point_y,"point_y")
            	HX_STACK_ARG(line_x1,"line_x1")
            	HX_STACK_ARG(line_y1,"line_y1")
            	HX_STACK_ARG(line_x2,"line_x2")
            	HX_STACK_ARG(line_y2,"line_y2")
HXLINE( 248)		HX_VARI( Float,line_length2) = ::haxegon::MathExtensions_obj::dst2(null(),line_x1,line_y1,line_x2,line_y2);
HXLINE( 249)		if ((line_length2 == (int)0)) {
HXLINE( 250)			return ::haxegon::MathExtensions_obj::dst(null(),point_x,point_y,line_x1,line_y1);
            		}
HXLINE( 253)		HX_VARI( Float,t) = ((Float)(((point_x - line_x1) * (line_x2 - line_x1)) + ((point_y - line_y1) * (line_y2 - line_y1))) / (Float)line_length2);
HXLINE( 254)		Float _hx_tmp = ::Math_obj::min((int)1,t);
HXDLIN( 254)		t = ::Math_obj::max((int)0,_hx_tmp);
HXLINE( 255)		return ::haxegon::MathExtensions_obj::dst(null(),point_x,point_y,(line_x1 + (t * (line_x2 - line_x1))),(line_y1 + (t * (line_y2 - line_y1))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(MathExtensions_obj,point_line_dst,return )

Float MathExtensions_obj::point_line_dst_3d(hx::Class math,Float point_x,Float point_y,Float point_z,Float line_x1,Float line_y1,Float line_z1,Float line_x2,Float line_y2,Float line_z2){
            	HX_STACK_FRAME("haxegon.MathExtensions","point_line_dst_3d",0xf4475703,"haxegon.MathExtensions.point_line_dst_3d","haxegon/MathExtensions.hx",261,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(point_x,"point_x")
            	HX_STACK_ARG(point_y,"point_y")
            	HX_STACK_ARG(point_z,"point_z")
            	HX_STACK_ARG(line_x1,"line_x1")
            	HX_STACK_ARG(line_y1,"line_y1")
            	HX_STACK_ARG(line_z1,"line_z1")
            	HX_STACK_ARG(line_x2,"line_x2")
            	HX_STACK_ARG(line_y2,"line_y2")
            	HX_STACK_ARG(line_z2,"line_z2")
HXLINE( 263)		HX_VARI( Float,line_length2) = ::haxegon::MathExtensions_obj::dst3d2(null(),line_x1,line_y1,line_z1,line_x2,line_y2,line_z2);
HXLINE( 264)		if ((line_length2 == (int)0)) {
HXLINE( 265)			return ::haxegon::MathExtensions_obj::dst3d(null(),point_x,point_y,point_z,line_x1,line_y1,line_z1);
            		}
HXLINE( 268)		HX_VARI( Float,t) = ((Float)((((point_x - line_x1) * (line_x2 - line_x1)) + ((point_y - line_y1) * (line_y2 - line_y1))) + ((point_z - line_z1) * (line_z2 - line_z1))) / (Float)line_length2);
HXLINE( 269)		Float _hx_tmp = ::Math_obj::min((int)1,t);
HXDLIN( 269)		t = ::Math_obj::max((int)0,_hx_tmp);
HXLINE( 270)		return ::haxegon::MathExtensions_obj::dst3d(null(),point_x,point_y,point_z,(line_x1 + (t * (line_x2 - line_x1))),(line_y1 + (t * (line_y2 - line_y1))),(line_z1 + (t * (line_z2 - line_z1))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC10(MathExtensions_obj,point_line_dst_3d,return )

Float MathExtensions_obj::dst(hx::Class math,Float x1,Float y1,Float x2,Float y2){
            	HX_STACK_FRAME("haxegon.MathExtensions","dst",0x7cab7381,"haxegon.MathExtensions.dst","haxegon/MathExtensions.hx",277,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
HXLINE( 277)		Float _hx_tmp = ::haxegon::MathExtensions_obj::dst2(null(),x1,y1,x2,y2);
HXDLIN( 277)		return ::Math_obj::sqrt(_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,dst,return )

Float MathExtensions_obj::dst2(hx::Class math,Float x1,Float y1,Float x2,Float y2){
            	HX_STACK_FRAME("haxegon.MathExtensions","dst2",0x99599d91,"haxegon.MathExtensions.dst2","haxegon/MathExtensions.hx",281,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
HXLINE( 281)		return (((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(MathExtensions_obj,dst2,return )

Float MathExtensions_obj::dst3d(hx::Class math,Float x1,Float y1,Float z1,Float x2,Float y2,Float z2){
            	HX_STACK_FRAME("haxegon.MathExtensions","dst3d",0x95104292,"haxegon.MathExtensions.dst3d","haxegon/MathExtensions.hx",285,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(z1,"z1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
            	HX_STACK_ARG(z2,"z2")
HXLINE( 285)		Float _hx_tmp = ::haxegon::MathExtensions_obj::dst3d2(null(),x1,y1,z1,x2,y2,z2);
HXDLIN( 285)		return ::Math_obj::sqrt(_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(MathExtensions_obj,dst3d,return )

Float MathExtensions_obj::dst3d2(hx::Class math,Float x1,Float y1,Float z1,Float x2,Float y2,Float z2){
            	HX_STACK_FRAME("haxegon.MathExtensions","dst3d2",0xd929fd60,"haxegon.MathExtensions.dst3d2","haxegon/MathExtensions.hx",289,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(y1,"y1")
            	HX_STACK_ARG(z1,"z1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(y2,"y2")
            	HX_STACK_ARG(z2,"z2")
HXLINE( 289)		return ((((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2))) + ((z1 - z2) * (z1 - z2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(MathExtensions_obj,dst3d2,return )

Float MathExtensions_obj::rad_to_deg(hx::Class math,Float angle){
            	HX_STACK_FRAME("haxegon.MathExtensions","rad_to_deg",0xcec54830,"haxegon.MathExtensions.rad_to_deg","haxegon/MathExtensions.hx",293,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(angle,"angle")
HXLINE( 293)		return (angle * ((Float)57.2958));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,rad_to_deg,return )

Float MathExtensions_obj::deg_to_rad(hx::Class math,Float angle){
            	HX_STACK_FRAME("haxegon.MathExtensions","deg_to_rad",0x421a506e,"haxegon.MathExtensions.deg_to_rad","haxegon/MathExtensions.hx",297,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(angle,"angle")
HXLINE( 297)		return ((Float)angle / (Float)((Float)57.2958));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,deg_to_rad,return )

Int MathExtensions_obj::sign(hx::Class math,Float x){
            	HX_STACK_FRAME("haxegon.MathExtensions","sign",0xa33c2f41,"haxegon.MathExtensions.sign","haxegon/MathExtensions.hx",301,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x,"x")
HXLINE( 301)		if ((x > (int)0)) {
HXLINE( 302)			return (int)1;
            		}
            		else {
HXLINE( 303)			if ((x < (int)0)) {
HXLINE( 304)				return (int)-1;
            			}
            			else {
HXLINE( 306)				return (int)0;
            			}
            		}
HXLINE( 301)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,sign,return )

Float MathExtensions_obj::lerp(hx::Class math,Float x1,Float x2,Float a){
            	HX_STACK_FRAME("haxegon.MathExtensions","lerp",0x9e98b17b,"haxegon.MathExtensions.lerp","haxegon/MathExtensions.hx",311,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(x1,"x1")
            	HX_STACK_ARG(x2,"x2")
            	HX_STACK_ARG(a,"a")
HXLINE( 311)		return (x1 + ((x2 - x1) * a));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,lerp,return )

Float MathExtensions_obj::mean(hx::Class math,::Array< Float > v){
            	HX_STACK_FRAME("haxegon.MathExtensions","mean",0x9f41d949,"haxegon.MathExtensions.mean","haxegon/MathExtensions.hx",314,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(v,"v")
HXLINE( 315)		HX_VARI( Float,mean) = ((Float)0.0);
HXLINE( 316)		{
HXLINE( 316)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 316)			HX_VARI( Int,_g) = v->length;
HXDLIN( 316)			while((_g1 < _g)){
HXLINE( 316)				HX_VARI( Int,i) = _g1++;
HXLINE( 317)				hx::AddEq(mean,( (Float)(_hx_array_unsafe_get(v,i)) ));
            			}
            		}
HXLINE( 319)		hx::DivEq(mean,v->length);
HXLINE( 320)		return mean;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,mean,return )

Float MathExtensions_obj::std_dev(hx::Class math,::Array< Float > v){
            	HX_STACK_FRAME("haxegon.MathExtensions","std_dev",0xe85d5075,"haxegon.MathExtensions.std_dev","haxegon/MathExtensions.hx",323,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(v,"v")
HXLINE( 324)		HX_VARI( Float,mean) = ::haxegon::MathExtensions_obj::mean(null(),v);
HXLINE( 325)		HX_VARI( Float,std_dev) = ((Float)0.0);
HXLINE( 326)		{
HXLINE( 326)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 326)			HX_VARI( Int,_g) = v->length;
HXDLIN( 326)			while((_g1 < _g)){
HXLINE( 326)				HX_VARI( Int,i) = _g1++;
HXLINE( 327)				Float _hx_tmp = (( (Float)(_hx_array_unsafe_get(v,i)) ) - mean);
HXDLIN( 327)				Float _hx_tmp1 = (( (Float)(_hx_array_unsafe_get(v,i)) ) - mean);
HXDLIN( 327)				hx::AddEq(std_dev,(_hx_tmp * _hx_tmp1));
            			}
            		}
HXLINE( 329)		Float _hx_tmp2 = ((Float)std_dev / (Float)v->length);
HXDLIN( 329)		std_dev = ::Math_obj::sqrt(_hx_tmp2);
HXLINE( 330)		return std_dev;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,std_dev,return )

Float MathExtensions_obj::inner_product(hx::Class math,::Array< Float > m1,::Array< Float > m2){
            	HX_STACK_FRAME("haxegon.MathExtensions","inner_product",0x021660c2,"haxegon.MathExtensions.inner_product","haxegon/MathExtensions.hx",333,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(m1,"m1")
            	HX_STACK_ARG(m2,"m2")
HXLINE( 334)		HX_VARI( Float,out) = ((Float)0.0);
HXLINE( 335)		{
HXLINE( 335)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 335)			HX_VARI( Int,_g) = m1->length;
HXDLIN( 335)			while((_g1 < _g)){
HXLINE( 335)				HX_VARI( Int,i) = _g1++;
HXLINE( 336)				Float _hx_tmp = ( (Float)(_hx_array_unsafe_get(m1,i)) );
HXDLIN( 336)				Float _hx_tmp1 = (_hx_tmp * ( (Float)(_hx_array_unsafe_get(m2,i)) ));
HXDLIN( 336)				hx::AddEq(out,_hx_tmp1);
            			}
            		}
HXLINE( 338)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathExtensions_obj,inner_product,return )

::Array< ::Dynamic> MathExtensions_obj::outer_product(hx::Class math,::Array< Float > v1,::Array< Float > v2,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","outer_product",0x760bd4a7,"haxegon.MathExtensions.outer_product","haxegon/MathExtensions.hx",341,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(v1,"v1")
            	HX_STACK_ARG(v2,"v2")
            	HX_STACK_ARG(out,"out")
HXLINE( 342)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 342)		if (_hx_tmp) {
HXLINE( 343)			out = ::haxegon::Data_obj::float_2dvector(v1->length,v2->length);
            		}
HXLINE( 345)		{
HXLINE( 345)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 345)			HX_VARI( Int,_g) = out->length;
HXDLIN( 345)			while((_g1 < _g)){
HXLINE( 345)				HX_VARI( Int,i) = _g1++;
HXLINE( 346)				{
HXLINE( 346)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 346)					::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 346)					HX_VARI( Int,_g2) = this1->length;
HXDLIN( 346)					while((_g3 < _g2)){
HXLINE( 346)						HX_VARI( Int,j) = _g3++;
HXLINE( 347)						{
HXLINE( 347)							::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 347)							Float _hx_tmp1 = ( (Float)(_hx_array_unsafe_get(v1,i)) );
HXDLIN( 347)							Float val = (_hx_tmp1 * ( (Float)(_hx_array_unsafe_get(v2,j)) ));
HXDLIN( 347)							this2->__unsafe_set(j,val);
            						}
            					}
            				}
            			}
            		}
HXLINE( 350)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,outer_product,return )

::Array< ::Dynamic> MathExtensions_obj::mat_transpose(hx::Class math,::Array< ::Dynamic> m,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","mat_transpose",0x76cdbf56,"haxegon.MathExtensions.mat_transpose","haxegon/MathExtensions.hx",353,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(m,"m")
            	HX_STACK_ARG(out,"out")
HXLINE( 354)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 354)		if (_hx_tmp) {
HXLINE( 355)			::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(m,(int)0)) );
HXDLIN( 355)			Int _hx_tmp1 = this1->length;
HXDLIN( 355)			out = ::haxegon::Data_obj::float_2dvector(_hx_tmp1,m->length);
            		}
HXLINE( 357)		{
HXLINE( 357)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 357)			HX_VARI( Int,_g) = out->length;
HXDLIN( 357)			while((_g1 < _g)){
HXLINE( 357)				HX_VARI( Int,i) = _g1++;
HXLINE( 358)				{
HXLINE( 358)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 358)					::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 358)					HX_VARI( Int,_g2) = this2->length;
HXDLIN( 358)					while((_g3 < _g2)){
HXLINE( 358)						HX_VARI( Int,j) = _g3++;
HXLINE( 359)						{
HXLINE( 359)							::Array< Float > this3 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 359)							::Array< Float > this4 = ( (::Array< Float >)(_hx_array_unsafe_get(m,j)) );
HXDLIN( 359)							Float val = ( (Float)(_hx_array_unsafe_get(this4,i)) );
HXDLIN( 359)							this3->__unsafe_set(j,val);
            						}
            					}
            				}
            			}
            		}
HXLINE( 362)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathExtensions_obj,mat_transpose,return )

::Array< ::Dynamic> MathExtensions_obj::mat_add(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","mat_add",0x8c7bad3e,"haxegon.MathExtensions.mat_add","haxegon/MathExtensions.hx",365,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(m1,"m1")
            	HX_STACK_ARG(m2,"m2")
            	HX_STACK_ARG(out,"out")
HXLINE( 366)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 366)		if (_hx_tmp) {
HXLINE( 367)			Int _hx_tmp1 = m1->length;
HXDLIN( 367)			::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,(int)0)) );
HXDLIN( 367)			Int _hx_tmp2 = this1->length;
HXDLIN( 367)			out = ::haxegon::Data_obj::float_2dvector(_hx_tmp1,_hx_tmp2);
            		}
HXLINE( 369)		{
HXLINE( 369)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 369)			HX_VARI( Int,_g) = out->length;
HXDLIN( 369)			while((_g1 < _g)){
HXLINE( 369)				HX_VARI( Int,i) = _g1++;
HXLINE( 370)				{
HXLINE( 370)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 370)					::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 370)					HX_VARI( Int,_g2) = this2->length;
HXDLIN( 370)					while((_g3 < _g2)){
HXLINE( 370)						HX_VARI( Int,j) = _g3++;
HXLINE( 371)						{
HXLINE( 371)							::Array< Float > this3 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 371)							::Array< Float > this4 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,i)) );
HXDLIN( 371)							Float _hx_tmp3 = ( (Float)(_hx_array_unsafe_get(this4,j)) );
HXDLIN( 371)							::Array< Float > this5 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,i)) );
HXDLIN( 371)							Float _hx_tmp4 = ( (Float)(_hx_array_unsafe_get(this5,j)) );
HXDLIN( 371)							this3->__unsafe_set(j,(_hx_tmp3 + _hx_tmp4));
            						}
            					}
            				}
            			}
            		}
HXLINE( 374)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,mat_add,return )

::Array< ::Dynamic> MathExtensions_obj::mat_dot(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","mat_dot",0x8c7dfda6,"haxegon.MathExtensions.mat_dot","haxegon/MathExtensions.hx",377,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(m1,"m1")
            	HX_STACK_ARG(m2,"m2")
            	HX_STACK_ARG(out,"out")
HXLINE( 378)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 378)		if (_hx_tmp) {
HXLINE( 379)			Int _hx_tmp1 = m1->length;
HXDLIN( 379)			::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,(int)0)) );
HXDLIN( 379)			Int _hx_tmp2 = this1->length;
HXDLIN( 379)			out = ::haxegon::Data_obj::float_2dvector(_hx_tmp1,_hx_tmp2);
            		}
HXLINE( 381)		HX_VAR( Float,sum);
HXLINE( 382)		{
HXLINE( 382)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 382)			HX_VARI( Int,_g) = m1->length;
HXDLIN( 382)			while((_g1 < _g)){
HXLINE( 382)				HX_VARI( Int,i) = _g1++;
HXLINE( 383)				{
HXLINE( 383)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 383)					::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,(int)0)) );
HXDLIN( 383)					HX_VARI( Int,_g2) = this2->length;
HXDLIN( 383)					while((_g3 < _g2)){
HXLINE( 383)						HX_VARI( Int,j) = _g3++;
HXLINE( 384)						sum = (int)0;
HXLINE( 385)						{
HXLINE( 385)							HX_VARI( Int,_g5) = (int)0;
HXDLIN( 385)							::Array< Float > this3 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,(int)0)) );
HXDLIN( 385)							HX_VARI( Int,_g4) = this3->length;
HXDLIN( 385)							while((_g5 < _g4)){
HXLINE( 385)								HX_VARI( Int,k) = _g5++;
HXLINE( 386)								::Array< Float > this4 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,i)) );
HXDLIN( 386)								Float _hx_tmp3 = ( (Float)(_hx_array_unsafe_get(this4,k)) );
HXDLIN( 386)								::Array< Float > this5 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,k)) );
HXDLIN( 386)								Float _hx_tmp4 = ( (Float)(_hx_array_unsafe_get(this5,j)) );
HXDLIN( 386)								hx::AddEq(sum,(_hx_tmp3 * _hx_tmp4));
            							}
            						}
HXLINE( 388)						{
HXLINE( 388)							::Array< Float > this6 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 388)							this6->__unsafe_set(j,sum);
            						}
            					}
            				}
            			}
            		}
HXLINE( 391)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,mat_dot,return )

::Array< ::Dynamic> MathExtensions_obj::mat_scalar_mult(hx::Class math,::Array< ::Dynamic> m,Float s,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","mat_scalar_mult",0x837cbd40,"haxegon.MathExtensions.mat_scalar_mult","haxegon/MathExtensions.hx",394,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(m,"m")
            	HX_STACK_ARG(s,"s")
            	HX_STACK_ARG(out,"out")
HXLINE( 395)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 395)		if (_hx_tmp) {
HXLINE( 396)			Int _hx_tmp1 = m->length;
HXDLIN( 396)			::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(m,(int)0)) );
HXDLIN( 396)			Int _hx_tmp2 = this1->length;
HXDLIN( 396)			out = ::haxegon::Data_obj::float_2dvector(_hx_tmp1,_hx_tmp2);
            		}
HXLINE( 398)		{
HXLINE( 398)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 398)			HX_VARI( Int,_g) = m->length;
HXDLIN( 398)			while((_g1 < _g)){
HXLINE( 398)				HX_VARI( Int,i) = _g1++;
HXLINE( 399)				{
HXLINE( 399)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 399)					::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(m,i)) );
HXDLIN( 399)					HX_VARI( Int,_g2) = this2->length;
HXDLIN( 399)					while((_g3 < _g2)){
HXLINE( 399)						HX_VARI( Int,j) = _g3++;
HXLINE( 400)						{
HXLINE( 400)							::Array< Float > this3 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 400)							::Array< Float > this4 = ( (::Array< Float >)(_hx_array_unsafe_get(m,i)) );
HXDLIN( 400)							Float _hx_tmp3 = ( (Float)(_hx_array_unsafe_get(this4,j)) );
HXDLIN( 400)							this3->__unsafe_set(j,(_hx_tmp3 * s));
            						}
            					}
            				}
            			}
            		}
HXLINE( 403)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,mat_scalar_mult,return )

::Array< ::Dynamic> MathExtensions_obj::hadamard_product(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","hadamard_product",0x96606f70,"haxegon.MathExtensions.hadamard_product","haxegon/MathExtensions.hx",406,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(m1,"m1")
            	HX_STACK_ARG(m2,"m2")
            	HX_STACK_ARG(out,"out")
HXLINE( 407)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 407)		if (_hx_tmp) {
HXLINE( 408)			Int _hx_tmp1 = m1->length;
HXDLIN( 408)			::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,(int)0)) );
HXDLIN( 408)			Int _hx_tmp2 = this1->length;
HXDLIN( 408)			out = ::haxegon::Data_obj::float_2dvector(_hx_tmp1,_hx_tmp2);
            		}
HXLINE( 410)		{
HXLINE( 410)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 410)			HX_VARI( Int,_g) = m1->length;
HXDLIN( 410)			while((_g1 < _g)){
HXLINE( 410)				HX_VARI( Int,i) = _g1++;
HXLINE( 411)				{
HXLINE( 411)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 411)					::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,(int)0)) );
HXDLIN( 411)					HX_VARI( Int,_g2) = this2->length;
HXDLIN( 411)					while((_g3 < _g2)){
HXLINE( 411)						HX_VARI( Int,j) = _g3++;
HXLINE( 412)						{
HXLINE( 412)							::Array< Float > this3 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 412)							::Array< Float > this4 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,i)) );
HXDLIN( 412)							Float _hx_tmp3 = ( (Float)(_hx_array_unsafe_get(this4,j)) );
HXDLIN( 412)							::Array< Float > this5 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,i)) );
HXDLIN( 412)							Float _hx_tmp4 = ( (Float)(_hx_array_unsafe_get(this5,j)) );
HXDLIN( 412)							this3->__unsafe_set(j,(_hx_tmp3 * _hx_tmp4));
            						}
            					}
            				}
            			}
            		}
HXLINE( 415)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,hadamard_product,return )

::Array< ::Dynamic> MathExtensions_obj::kronecker_product(hx::Class math,::Array< Float > v1,::Array< Float > v2,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","kronecker_product",0xa00e8ee0,"haxegon.MathExtensions.kronecker_product","haxegon/MathExtensions.hx",418,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(v1,"v1")
            	HX_STACK_ARG(v2,"v2")
            	HX_STACK_ARG(out,"out")
HXLINE( 419)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 419)		if (_hx_tmp) {
HXLINE( 420)			Int _hx_tmp1 = (v1->length * v2->length);
HXDLIN( 420)			Int _hx_tmp2 = (v1->length * v2->length);
HXDLIN( 420)			out = ::haxegon::Data_obj::float_2dvector(_hx_tmp1,_hx_tmp2);
            		}
HXLINE( 422)		{
HXLINE( 422)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 422)			HX_VARI( Int,_g) = v1->length;
HXDLIN( 422)			while((_g1 < _g)){
HXLINE( 422)				HX_VARI( Int,i) = _g1++;
HXLINE( 423)				{
HXLINE( 423)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 423)					HX_VARI( Int,_g2) = v1->length;
HXDLIN( 423)					while((_g3 < _g2)){
HXLINE( 423)						HX_VARI( Int,j) = _g3++;
HXLINE( 424)						{
HXLINE( 424)							::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 424)							Float _hx_tmp3 = ( (Float)(_hx_array_unsafe_get(v1,i)) );
HXDLIN( 424)							Float val = (_hx_tmp3 * ( (Float)(_hx_array_unsafe_get(v2,j)) ));
HXDLIN( 424)							this1->__unsafe_set(j,val);
            						}
            					}
            				}
            			}
            		}
HXLINE( 427)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,kronecker_product,return )

::Array< ::Dynamic> MathExtensions_obj::mat_concat_horizontal(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out){
            	HX_STACK_FRAME("haxegon.MathExtensions","mat_concat_horizontal",0x3e71054c,"haxegon.MathExtensions.mat_concat_horizontal","haxegon/MathExtensions.hx",430,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(m1,"m1")
            	HX_STACK_ARG(m2,"m2")
            	HX_STACK_ARG(out,"out")
HXLINE( 431)		Bool _hx_tmp = hx::IsNull( out );
HXDLIN( 431)		if (_hx_tmp) {
HXLINE( 432)			Int _hx_tmp1 = m1->length;
HXDLIN( 432)			::Array< Float > this1 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,(int)0)) );
HXDLIN( 432)			Int _hx_tmp2 = this1->length;
HXDLIN( 432)			::Array< Float > this2 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,(int)0)) );
HXDLIN( 432)			Int _hx_tmp3 = (_hx_tmp2 + this2->length);
HXDLIN( 432)			out = ::haxegon::Data_obj::float_2dvector(_hx_tmp1,_hx_tmp3);
            		}
HXLINE( 434)		::Array< Float > this3 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,(int)0)) );
HXDLIN( 434)		HX_VARI( Int,m1Width) = this3->length;
HXLINE( 435)		{
HXLINE( 435)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 435)			HX_VARI( Int,_g) = out->length;
HXDLIN( 435)			while((_g1 < _g)){
HXLINE( 435)				HX_VARI( Int,i) = _g1++;
HXLINE( 436)				{
HXLINE( 436)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 436)					::Array< Float > this4 = ( (::Array< Float >)(_hx_array_unsafe_get(out,(int)0)) );
HXDLIN( 436)					HX_VARI( Int,_g2) = this4->length;
HXDLIN( 436)					while((_g3 < _g2)){
HXLINE( 436)						HX_VARI( Int,j) = _g3++;
HXLINE( 437)						if ((j < m1Width)) {
HXLINE( 438)							::Array< Float > this5 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 438)							::Array< Float > this6 = ( (::Array< Float >)(_hx_array_unsafe_get(m1,i)) );
HXDLIN( 438)							Float val = ( (Float)(_hx_array_unsafe_get(this6,j)) );
HXDLIN( 438)							this5->__unsafe_set(j,val);
            						}
            						else {
HXLINE( 440)							::Array< Float > this7 = ( (::Array< Float >)(_hx_array_unsafe_get(out,i)) );
HXDLIN( 440)							::Array< Float > this8 = ( (::Array< Float >)(_hx_array_unsafe_get(m2,i)) );
HXDLIN( 440)							Float val1 = ( (Float)(_hx_array_unsafe_get(this8,(j - m1Width))) );
HXDLIN( 440)							this7->__unsafe_set(j,val1);
            						}
            					}
            				}
            			}
            		}
HXLINE( 444)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(MathExtensions_obj,mat_concat_horizontal,return )

Int MathExtensions_obj::CONCAVE;

Int MathExtensions_obj::TANGENTIAL;

Int MathExtensions_obj::CONVEX;

::Array< Int > MathExtensions_obj::triangulate(hx::Class math,::Array< Float > vertices){
            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0,::Array< Int >,vertex_count) HXARGC(1)
            		Int _hx_run(Int index){
            			HX_STACK_FRAME("haxegon.MathExtensions","triangulate",0xf9606ea8,"haxegon.MathExtensions.triangulate","haxegon/MathExtensions.hx",488,0xa3985ff3)
            			HX_STACK_ARG(index,"index")
HXLINE( 488)			if ((index == (int)0)) {
HXLINE( 489)				return (vertex_count->__get((int)0) - (int)1);
            			}
            			else {
HXLINE( 491)				return (index - (int)1);
            			}
HXLINE( 488)			return (int)0;
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_1,::Array< Int >,vertex_count) HXARGC(1)
            		Int _hx_run(Int index1){
            			HX_STACK_FRAME("haxegon.MathExtensions","triangulate",0xf9606ea8,"haxegon.MathExtensions.triangulate","haxegon/MathExtensions.hx",495,0xa3985ff3)
            			HX_STACK_ARG(index1,"index1")
HXLINE( 495)			return hx::Mod((index1 + (int)1),vertex_count->__get((int)0));
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_2) HXARGC(6)
            		Int _hx_run(Float p1x1,Float p1y1,Float p2x1,Float p2y1,Float p3x,Float p3y){
            			HX_STACK_FRAME("haxegon.MathExtensions","triangulate",0xf9606ea8,"haxegon.MathExtensions.triangulate","haxegon/MathExtensions.hx",499,0xa3985ff3)
            			HX_STACK_ARG(p1x1,"p1x1")
            			HX_STACK_ARG(p1y1,"p1y1")
            			HX_STACK_ARG(p2x1,"p2x1")
            			HX_STACK_ARG(p2y1,"p2y1")
            			HX_STACK_ARG(p3x,"p3x")
            			HX_STACK_ARG(p3y,"p3y")
HXLINE( 499)			return ::haxegon::MathExtensions_obj::sign(null(),(((p1x1 * (p3y - p2y1)) + (p2x1 * (p1y1 - p3y))) + (p3x * (p2y1 - p1y1))));
            		}
            		HX_END_LOCAL_FUNC6(return)

            		HX_BEGIN_LOCAL_FUNC_S5(hx::LocalFunc,_hx_Closure_3,::Array< Float >,vertices, ::Dynamic,compute_spanned_area_sign, ::Dynamic,get_next_index,::Array< Int >,indices, ::Dynamic,get_previous_index) HXARGC(1)
            		Int _hx_run(Int index2){
            			HX_STACK_FRAME("haxegon.MathExtensions","triangulate",0xf9606ea8,"haxegon.MathExtensions.triangulate","haxegon/MathExtensions.hx",501,0xa3985ff3)
            			HX_STACK_ARG(index2,"index2")
HXLINE( 502)			Int _hx_tmp3 = ( (Int)(get_previous_index(index2)) );
HXDLIN( 502)			HX_VARI( Int,previous) = (indices->__get(_hx_tmp3) * (int)2);
HXLINE( 503)			HX_VARI( Int,current) = (indices->__get(index2) * (int)2);
HXLINE( 504)			Int _hx_tmp4 = ( (Int)(get_next_index(index2)) );
HXDLIN( 504)			HX_VARI( Int,next) = (indices->__get(_hx_tmp4) * (int)2);
HXLINE( 506)			Float _hx_tmp5 = vertices->__get(previous);
HXDLIN( 506)			Float _hx_tmp6 = vertices->__get((previous + (int)1));
HXLINE( 507)			Float _hx_tmp7 = vertices->__get(current);
HXDLIN( 507)			Float _hx_tmp8 = vertices->__get((current + (int)1));
HXLINE( 508)			Float _hx_tmp9 = vertices->__get(next);
HXDLIN( 508)			Float _hx_tmp10 = vertices->__get((next + (int)1));
HXLINE( 505)			return ( (Int)(compute_spanned_area_sign(_hx_tmp5,_hx_tmp6,_hx_tmp7,_hx_tmp8,_hx_tmp9,_hx_tmp10)) );
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S6(hx::LocalFunc,_hx_Closure_4,::Array< Int >,vertex_types,::Array< Float >,vertices, ::Dynamic,compute_spanned_area_sign,::Array< Int >,indices, ::Dynamic,get_next_index, ::Dynamic,get_previous_index) HXARGC(1)
            		Bool _hx_run(Int index3){
            			HX_STACK_FRAME("haxegon.MathExtensions","triangulate",0xf9606ea8,"haxegon.MathExtensions.triangulate","haxegon/MathExtensions.hx",515,0xa3985ff3)
            			HX_STACK_ARG(index3,"index3")
HXLINE( 516)			if ((vertex_types->__get(index3) == (int)-1)) {
HXLINE( 517)				return false;
            			}
HXLINE( 520)			HX_VARI( Int,previous_index) = ( (Int)(get_previous_index(index3)) );
HXLINE( 521)			HX_VARI( Int,next_index) = ( (Int)(get_next_index(index3)) );
HXLINE( 522)			HX_VARI( Int,p1) = (indices->__get(previous_index) * (int)2);
HXLINE( 523)			HX_VARI( Int,p2) = (indices->__get(index3) * (int)2);
HXLINE( 524)			HX_VARI( Int,p3) = (indices->__get(next_index) * (int)2);
HXLINE( 525)			HX_VARI_NAME( Float,p1x2,"p1x") = vertices->__get(p1);
HXLINE( 526)			HX_VARI_NAME( Float,p1y2,"p1y") = vertices->__get((p1 + (int)1));
HXLINE( 527)			HX_VARI_NAME( Float,p2x2,"p2x") = vertices->__get(p2);
HXLINE( 528)			HX_VARI_NAME( Float,p2y2,"p2y") = vertices->__get((p2 + (int)1));
HXLINE( 529)			HX_VARI_NAME( Float,p3x1,"p3x") = vertices->__get(p3);
HXLINE( 530)			HX_VARI_NAME( Float,p3y1,"p3y") = vertices->__get((p3 + (int)1));
HXLINE( 532)			HX_VARI_NAME( Int,i4,"i") = ( (Int)(get_next_index(next_index)) );
HXLINE( 533)			while((i4 != previous_index)){
HXLINE( 534)				Bool _hx_tmp12 = (vertex_types->__get(i4) != (int)1);
HXDLIN( 534)				if (_hx_tmp12) {
HXLINE( 535)					HX_VARI( Int,v) = (indices->__get(i4) * (int)2);
HXLINE( 536)					HX_VARI( Float,vx) = vertices->__get(v);
HXLINE( 537)					HX_VARI( Float,vy) = vertices->__get((v + (int)1));
HXLINE( 538)					Bool _hx_tmp13;
HXDLIN( 538)					Bool _hx_tmp14;
HXDLIN( 538)					Int _hx_tmp15 = ( (Int)(compute_spanned_area_sign(p3x1,p3y1,p1x2,p1y2,vx,vy)) );
HXDLIN( 538)					if ((_hx_tmp15 >= (int)0)) {
HXLINE( 539)						Int _hx_tmp16 = ( (Int)(compute_spanned_area_sign(p1x2,p1y2,p2x2,p2y2,vx,vy)) );
HXLINE( 538)						_hx_tmp14 = (_hx_tmp16 >= (int)0);
            					}
            					else {
HXLINE( 538)						_hx_tmp14 = false;
            					}
HXDLIN( 538)					if (_hx_tmp14) {
HXLINE( 540)						Int _hx_tmp17 = ( (Int)(compute_spanned_area_sign(p2x2,p2y2,p3x1,p3y1,vx,vy)) );
HXLINE( 538)						_hx_tmp13 = (_hx_tmp17 >= (int)0);
            					}
            					else {
HXLINE( 538)						_hx_tmp13 = false;
            					}
HXDLIN( 538)					if (_hx_tmp13) {
HXLINE( 542)						return false;
            					}
            				}
HXLINE( 545)				i4 = ( (Int)(get_next_index(i4)) );
            			}
HXLINE( 547)			return true;
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACK_FRAME("haxegon.MathExtensions","triangulate",0xf9606ea8,"haxegon.MathExtensions.triangulate","haxegon/MathExtensions.hx",451,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(vertices,"vertices")
HXLINE( 452)		Float _hx_tmp = ((Float)vertices->length / (Float)(int)2);
HXDLIN( 452)		Int _hx_tmp1 = ::Std_obj::_hx_int(_hx_tmp);
HXDLIN( 452)		HX_VARI( ::Array< Int >,vertex_count) = ::Array_obj< Int >::__new(1)->init(0,_hx_tmp1);
HXLINE( 454)		HX_VAR( Bool,vertices_are_clockwise);
HXLINE( 455)		if ((vertices->length <= (int)4)) {
HXLINE( 454)			vertices_are_clockwise = false;
            		}
            		else {
HXLINE( 458)			HX_VARI( Float,area) = ((Float)0.0);
HXLINE( 459)			HX_VAR( Float,p1x);
HXLINE( 460)			HX_VAR( Float,p1y);
HXLINE( 461)			HX_VAR( Float,p2x);
HXLINE( 462)			HX_VAR( Float,p2y);
HXLINE( 463)			HX_VARI( Int,i) = (int)0;
HXLINE( 464)			while((i < ((vertices->length - (int)1) - (int)2))){
HXLINE( 465)				p1x = vertices->__get(i);
HXLINE( 466)				p1y = vertices->__get((i + (int)1));
HXLINE( 467)				p2x = vertices->__get((i + (int)2));
HXLINE( 468)				p2y = vertices->__get((i + (int)3));
HXLINE( 469)				hx::AddEq(area,((p1x * p2y) - (p2x * p1y)));
HXLINE( 470)				hx::AddEq(i,(int)2);
            			}
HXLINE( 472)			p1x = vertices->__get((vertices->length - (int)2));
HXLINE( 473)			p1y = vertices->__get((vertices->length - (int)1));
HXLINE( 474)			p2x = vertices->__get((int)0);
HXLINE( 475)			p2y = vertices->__get((int)1);
HXLINE( 476)			hx::AddEq(area,((p1x * p2y) - (p2x * p1y)));
HXLINE( 454)			vertices_are_clockwise = (area < (int)0);
            		}
HXLINE( 480)		HX_VAR( ::Array< Int >,indices);
HXLINE( 481)		if (vertices_are_clockwise) {
HXLINE( 482)			HX_VARI( ::Array< Int >,_g) = ::Array_obj< Int >::__new(0);
HXDLIN( 482)			{
HXLINE( 482)				HX_VARI( Int,_g2) = (int)0;
HXDLIN( 482)				HX_VARI( Int,_g1) = vertex_count->__get((int)0);
HXDLIN( 482)				while((_g2 < _g1)){
HXLINE( 482)					HX_VARI_NAME( Int,i1,"i") = _g2++;
HXDLIN( 482)					_g->push(i1);
            				}
            			}
HXDLIN( 482)			indices = _g;
            		}
            		else {
HXLINE( 484)			HX_VARI_NAME( ::Array< Int >,_g3,"_g") = ::Array_obj< Int >::__new(0);
HXDLIN( 484)			{
HXLINE( 484)				HX_VARI_NAME( Int,_g21,"_g2") = (int)0;
HXDLIN( 484)				HX_VARI_NAME( Int,_g11,"_g1") = vertex_count->__get((int)0);
HXDLIN( 484)				while((_g21 < _g11)){
HXLINE( 484)					HX_VARI_NAME( Int,i2,"i") = _g21++;
HXDLIN( 484)					Int _hx_tmp2 = (vertex_count->__get((int)0) - (int)1);
HXDLIN( 484)					_g3->push((_hx_tmp2 - i2));
            				}
            			}
HXDLIN( 484)			indices = _g3;
            		}
HXLINE( 487)		HX_VARI(  ::Dynamic,get_previous_index) =  ::Dynamic(new _hx_Closure_0(vertex_count));
HXLINE( 494)		HX_VARI(  ::Dynamic,get_next_index) =  ::Dynamic(new _hx_Closure_1(vertex_count));
HXLINE( 497)		HX_VARI(  ::Dynamic,compute_spanned_area_sign) =  ::Dynamic(new _hx_Closure_2());
HXLINE( 501)		HX_VARI(  ::Dynamic,get_vertex_type) =  ::Dynamic(new _hx_Closure_3(vertices,compute_spanned_area_sign,get_next_index,indices,get_previous_index));
HXLINE( 511)		HX_VARI_NAME( ::Array< Int >,_g4,"_g") = ::Array_obj< Int >::__new(0);
HXDLIN( 511)		{
HXLINE( 511)			HX_VARI_NAME( Int,_g22,"_g2") = (int)0;
HXDLIN( 511)			HX_VARI_NAME( Int,_g12,"_g1") = vertex_count->__get((int)0);
HXDLIN( 511)			while((_g22 < _g12)){
HXLINE( 511)				HX_VARI_NAME( Int,i3,"i") = _g22++;
HXDLIN( 511)				Int _hx_tmp11 = ( (Int)(get_vertex_type(i3)) );
HXDLIN( 511)				_g4->push(_hx_tmp11);
            			}
            		}
HXDLIN( 511)		HX_VARI( ::Array< Int >,vertex_types) = _g4;
HXLINE( 512)		HX_VARI( ::Array< Int >,triangles) = ::Array_obj< Int >::__new();
HXLINE( 515)		HX_VARI(  ::Dynamic,is_ear_tip) =  ::Dynamic(new _hx_Closure_4(vertex_types,vertices,compute_spanned_area_sign,indices,get_next_index,get_previous_index));
HXLINE( 550)		while((vertex_count->__get((int)0) > (int)3)){
            			HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_5,::Array< Int >,vertex_types,::Array< Int >,vertex_count, ::Dynamic,is_ear_tip) HXARGC(0)
            			Int _hx_run(){
            				HX_STACK_FRAME("haxegon.MathExtensions","triangulate",0xf9606ea8,"haxegon.MathExtensions.triangulate","haxegon/MathExtensions.hx",552,0xa3985ff3)
HXLINE( 553)				{
HXLINE( 553)					HX_VARI_NAME( Int,_g23,"_g2") = (int)0;
HXDLIN( 553)					HX_VARI_NAME( Int,_g13,"_g1") = vertex_count->__get((int)0);
HXDLIN( 553)					while((_g23 < _g13)){
HXLINE( 553)						HX_VARI_NAME( Int,i5,"i") = _g23++;
HXLINE( 554)						Bool _hx_tmp18 = ( (Bool)(is_ear_tip(i5)) );
HXDLIN( 554)						if (_hx_tmp18) {
HXLINE( 555)							return i5;
            						}
            					}
            				}
HXLINE( 558)				{
HXLINE( 558)					HX_VARI_NAME( Int,_g24,"_g2") = (int)0;
HXDLIN( 558)					HX_VARI_NAME( Int,_g14,"_g1") = vertex_count->__get((int)0);
HXDLIN( 558)					while((_g24 < _g14)){
HXLINE( 558)						HX_VARI_NAME( Int,i6,"i") = _g24++;
HXLINE( 559)						if ((vertex_types->__get(i6) != (int)-1)) {
HXLINE( 560)							return i6;
            						}
            					}
            				}
HXLINE( 563)				return (int)0;
            			}
            			HX_END_LOCAL_FUNC0(return)

HXLINE( 552)			HX_VARI( Int,ear_tip_index) = ( (Int)( ::Dynamic(new _hx_Closure_5(vertex_types,vertex_count,is_ear_tip))()) );
HXLINE( 566)			Int _hx_tmp19 = ( (Int)(get_previous_index(ear_tip_index)) );
HXDLIN( 566)			Int _hx_tmp20 = indices->__get(_hx_tmp19);
HXDLIN( 566)			triangles->push(_hx_tmp20);
HXLINE( 567)			Int _hx_tmp21 = indices->__get(ear_tip_index);
HXDLIN( 567)			triangles->push(_hx_tmp21);
HXLINE( 568)			Int _hx_tmp22 = ( (Int)(get_next_index(ear_tip_index)) );
HXDLIN( 568)			Int _hx_tmp23 = indices->__get(_hx_tmp22);
HXDLIN( 568)			triangles->push(_hx_tmp23);
HXLINE( 570)			indices->removeRange(ear_tip_index,(int)1);
HXLINE( 571)			vertex_types->removeRange(ear_tip_index,(int)1);
HXLINE( 573)			vertex_count[(int)0]--;
HXLINE( 575)			HX_VARI_NAME( Int,previous_index1,"previous_index") = ( (Int)(get_previous_index(ear_tip_index)) );
HXLINE( 576)			HX_VAR_NAME( Int,next_index1,"next_index");
HXLINE( 577)			if ((ear_tip_index == vertex_count->__get((int)0))) {
HXLINE( 578)				next_index1 = (int)0;
            			}
            			else {
HXLINE( 580)				next_index1 = ear_tip_index;
            			}
HXLINE( 582)			Int _hx_tmp24 = ( (Int)(get_vertex_type(previous_index1)) );
HXDLIN( 582)			vertex_types[previous_index1] = _hx_tmp24;
HXLINE( 583)			Int _hx_tmp25 = ( (Int)(get_vertex_type(next_index1)) );
HXDLIN( 583)			vertex_types[next_index1] = _hx_tmp25;
            		}
HXLINE( 586)		Bool _hx_tmp26 = (vertex_count->__get((int)0) == (int)3);
HXDLIN( 586)		if (_hx_tmp26) {
HXLINE( 587)			Int _hx_tmp27 = indices->__get((int)0);
HXDLIN( 587)			triangles->push(_hx_tmp27);
HXLINE( 588)			Int _hx_tmp28 = indices->__get((int)1);
HXDLIN( 588)			triangles->push(_hx_tmp28);
HXLINE( 589)			Int _hx_tmp29 = indices->__get((int)2);
HXDLIN( 589)			triangles->push(_hx_tmp29);
            		}
HXLINE( 592)		return triangles;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(MathExtensions_obj,triangulate,return )

::Array< ::Dynamic> MathExtensions_obj::indices_to_vertices(hx::Class math,::Array< Float > polygon,::Array< Int > indices){
            	HX_STACK_FRAME("haxegon.MathExtensions","indices_to_vertices",0x25a0c3a1,"haxegon.MathExtensions.indices_to_vertices","haxegon/MathExtensions.hx",595,0xa3985ff3)
            	HX_STACK_ARG(math,"math")
            	HX_STACK_ARG(polygon,"polygon")
            	HX_STACK_ARG(indices,"indices")
HXLINE( 596)		HX_VARI( ::Array< ::Dynamic>,_g) = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN( 596)		{
HXLINE( 596)			HX_VARI( Int,_g2) = (int)0;
HXDLIN( 596)			Float _hx_tmp = ((Float)indices->length / (Float)(int)3);
HXDLIN( 596)			HX_VARI( Int,_g1) = ::Std_obj::_hx_int(_hx_tmp);
HXDLIN( 596)			while((_g2 < _g1)){
HXLINE( 596)				HX_VARI( Int,i) = _g2++;
HXLINE( 598)				Float _hx_tmp1 = polygon->__get((indices->__get((i * (int)3)) * (int)2));
HXDLIN( 598)				Float _hx_tmp2 = polygon->__get(((indices->__get((i * (int)3)) * (int)2) + (int)1));
HXLINE( 599)				Float _hx_tmp3 = polygon->__get((indices->__get(((i * (int)3) + (int)1)) * (int)2));
HXDLIN( 599)				Float _hx_tmp4 = polygon->__get(((indices->__get(((i * (int)3) + (int)1)) * (int)2) + (int)1));
HXLINE( 600)				Float _hx_tmp5 = polygon->__get((indices->__get(((i * (int)3) + (int)2)) * (int)2));
HXDLIN( 600)				Float _hx_tmp6 = polygon->__get(((indices->__get(((i * (int)3) + (int)2)) * (int)2) + (int)1));
HXLINE( 597)				_g->push(::Array_obj< Float >::__new(6)->init(0,_hx_tmp1)->init(1,_hx_tmp2)->init(2,_hx_tmp3)->init(3,_hx_tmp4)->init(4,_hx_tmp5)->init(5,_hx_tmp6));
            			}
            		}
HXLINE( 603)		return _g;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(MathExtensions_obj,indices_to_vertices,return )


MathExtensions_obj::MathExtensions_obj()
{
}

bool MathExtensions_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"dot") ) { outValue = dot_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dst") ) { outValue = dst_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"max3") ) { outValue = max3_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"max4") ) { outValue = max4_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"min3") ) { outValue = min3_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"min4") ) { outValue = min4_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"dst2") ) { outValue = dst2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sign") ) { outValue = sign_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"lerp") ) { outValue = lerp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"mean") ) { outValue = mean_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dst3d") ) { outValue = dst3d_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"dst3d2") ) { outValue = dst3d2_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"project") ) { outValue = project_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"std_dev") ) { outValue = std_dev_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"mat_add") ) { outValue = mat_add_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"mat_dot") ) { outValue = mat_dot_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"normalize") ) { outValue = normalize_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"rad_to_deg") ) { outValue = rad_to_deg_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"deg_to_rad") ) { outValue = deg_to_rad_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"fixed_float") ) { outValue = fixed_float_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"triangulate") ) { outValue = triangulate_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"collision_1d") ) { outValue = collision_1d_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"rotate_vector") ) { outValue = rotate_vector_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"poly_centroid") ) { outValue = poly_centroid_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"inner_product") ) { outValue = inner_product_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"outer_product") ) { outValue = outer_product_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"mat_transpose") ) { outValue = mat_transpose_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"project_circle") ) { outValue = project_circle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"scale_vertices") ) { outValue = scale_vertices_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"point_line_dst") ) { outValue = point_line_dst_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"rotate_vertices") ) { outValue = rotate_vertices_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"line_point_sign") ) { outValue = line_point_sign_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"point_line_dst2") ) { outValue = point_line_dst2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"mat_scalar_mult") ) { outValue = mat_scalar_mult_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"project_triangle") ) { outValue = project_triangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"hadamard_product") ) { outValue = hadamard_product_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"project_rectangle") ) { outValue = project_rectangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"box_box_intersect") ) { outValue = box_box_intersect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"point_line_dst_3d") ) { outValue = point_line_dst_3d_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"kronecker_product") ) { outValue = kronecker_product_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"translate_vertices") ) { outValue = translate_vertices_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"line_line_intersect") ) { outValue = line_line_intersect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"point_box_intersect") ) { outValue = point_box_intersect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"indices_to_vertices") ) { outValue = indices_to_vertices_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"circle_tri_intersect") ) { outValue = circle_tri_intersect_dyn(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"circle_line_intersect") ) { outValue = circle_line_intersect_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"mat_concat_horizontal") ) { outValue = mat_concat_horizontal_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"circle_point_intersect") ) { outValue = circle_point_intersect_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"circle_circle_intersect") ) { outValue = circle_circle_intersect_dyn(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"circle_polygon_intersect") ) { outValue = circle_polygon_intersect_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *MathExtensions_obj_sMemberStorageInfo = 0;
static hx::StaticInfo MathExtensions_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &MathExtensions_obj::CONCAVE,HX_HCSTRING("CONCAVE","\x6f","\xbe","\x0b","\x8e")},
	{hx::fsInt,(void *) &MathExtensions_obj::TANGENTIAL,HX_HCSTRING("TANGENTIAL","\xef","\x61","\x2c","\x55")},
	{hx::fsInt,(void *) &MathExtensions_obj::CONVEX,HX_HCSTRING("CONVEX","\x67","\x23","\x61","\x7a")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void MathExtensions_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(MathExtensions_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(MathExtensions_obj::CONCAVE,"CONCAVE");
	HX_MARK_MEMBER_NAME(MathExtensions_obj::TANGENTIAL,"TANGENTIAL");
	HX_MARK_MEMBER_NAME(MathExtensions_obj::CONVEX,"CONVEX");
};

#ifdef HXCPP_VISIT_ALLOCS
static void MathExtensions_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(MathExtensions_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(MathExtensions_obj::CONCAVE,"CONCAVE");
	HX_VISIT_MEMBER_NAME(MathExtensions_obj::TANGENTIAL,"TANGENTIAL");
	HX_VISIT_MEMBER_NAME(MathExtensions_obj::CONVEX,"CONVEX");
};

#endif

hx::Class MathExtensions_obj::__mClass;

static ::String MathExtensions_obj_sStaticFields[] = {
	HX_HCSTRING("project_circle","\xf6","\x6d","\xc2","\x39"),
	HX_HCSTRING("project_triangle","\x2e","\x00","\x9e","\x85"),
	HX_HCSTRING("project_rectangle","\x09","\xcc","\xdd","\xfe"),
	HX_HCSTRING("fixed_float","\x51","\x95","\x1a","\xe6"),
	HX_HCSTRING("collision_1d","\x00","\xec","\x80","\xbc"),
	HX_HCSTRING("max3","\x0f","\x45","\x56","\x48"),
	HX_HCSTRING("max4","\x10","\x45","\x56","\x48"),
	HX_HCSTRING("min3","\x61","\x4e","\x5c","\x48"),
	HX_HCSTRING("min4","\x62","\x4e","\x5c","\x48"),
	HX_HCSTRING("scale_vertices","\x8e","\xc7","\xb7","\x43"),
	HX_HCSTRING("translate_vertices","\x4a","\x86","\xa9","\xe1"),
	HX_HCSTRING("rotate_vertices","\x9d","\x4d","\xcb","\x39"),
	HX_HCSTRING("rotate_vector","\x67","\xcd","\xd7","\xfe"),
	HX_HCSTRING("dot","\x89","\x42","\x4c","\x00"),
	HX_HCSTRING("normalize","\x8d","\x37","\xa1","\xab"),
	HX_HCSTRING("project","\xd9","\x12","\xeb","\xf5"),
	HX_HCSTRING("line_point_sign","\x77","\xe7","\xf9","\xba"),
	HX_HCSTRING("poly_centroid","\xd3","\x2f","\xbb","\x26"),
	HX_HCSTRING("line_line_intersect","\xbf","\xd0","\xd1","\x43"),
	HX_HCSTRING("point_box_intersect","\xfc","\xe6","\x20","\x78"),
	HX_HCSTRING("box_box_intersect","\xf7","\x61","\x87","\xcf"),
	HX_HCSTRING("circle_circle_intersect","\xff","\x4c","\x7a","\x4a"),
	HX_HCSTRING("circle_polygon_intersect","\x6b","\xf6","\xf6","\xea"),
	HX_HCSTRING("circle_tri_intersect","\xdc","\x07","\xc6","\xe9"),
	HX_HCSTRING("circle_line_intersect","\x23","\x36","\x71","\x22"),
	HX_HCSTRING("circle_point_intersect","\x81","\x89","\xff","\x23"),
	HX_HCSTRING("point_line_dst2","\x09","\x62","\x2c","\xdd"),
	HX_HCSTRING("point_line_dst","\x09","\xe6","\x1c","\xbc"),
	HX_HCSTRING("point_line_dst_3d","\x87","\x08","\xb2","\xca"),
	HX_HCSTRING("dst","\x05","\x46","\x4c","\x00"),
	HX_HCSTRING("dst2","\x8d","\xfe","\x70","\x42"),
	HX_HCSTRING("dst3d","\x16","\xbe","\x6d","\xe0"),
	HX_HCSTRING("dst3d2","\x5c","\x95","\x98","\x7f"),
	HX_HCSTRING("rad_to_deg","\x2c","\x8e","\xc5","\xde"),
	HX_HCSTRING("deg_to_rad","\x6a","\x96","\x1a","\x52"),
	HX_HCSTRING("sign","\x3d","\x90","\x53","\x4c"),
	HX_HCSTRING("lerp","\x77","\x12","\xb0","\x47"),
	HX_HCSTRING("mean","\x45","\x3a","\x59","\x48"),
	HX_HCSTRING("std_dev","\xf9","\xb4","\xb3","\xe2"),
	HX_HCSTRING("inner_product","\x46","\x00","\x61","\x34"),
	HX_HCSTRING("outer_product","\x2b","\x74","\x56","\xa8"),
	HX_HCSTRING("mat_transpose","\xda","\x5e","\x18","\xa9"),
	HX_HCSTRING("mat_add","\xc2","\x11","\xd2","\x86"),
	HX_HCSTRING("mat_dot","\x2a","\x62","\xd4","\x86"),
	HX_HCSTRING("mat_scalar_mult","\xc4","\x45","\x51","\xd5"),
	HX_HCSTRING("hadamard_product","\x6c","\x5a","\x83","\xde"),
	HX_HCSTRING("kronecker_product","\x64","\x40","\x79","\x76"),
	HX_HCSTRING("mat_concat_horizontal","\xd0","\xc8","\x6c","\x7f"),
	HX_HCSTRING("CONCAVE","\x6f","\xbe","\x0b","\x8e"),
	HX_HCSTRING("TANGENTIAL","\xef","\x61","\x2c","\x55"),
	HX_HCSTRING("CONVEX","\x67","\x23","\x61","\x7a"),
	HX_HCSTRING("triangulate","\x2c","\x65","\x9d","\xe9"),
	HX_HCSTRING("indices_to_vertices","\x25","\xde","\x3d","\x71"),
	::String(null())
};

void MathExtensions_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxegon.MathExtensions","\xea","\x1f","\x38","\xba");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &MathExtensions_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = MathExtensions_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(MathExtensions_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< MathExtensions_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = MathExtensions_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MathExtensions_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MathExtensions_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void MathExtensions_obj::__boot()
{
{
            	HX_STACK_FRAME("haxegon.MathExtensions","boot",0x98042336,"haxegon.MathExtensions.boot","haxegon/MathExtensions.hx",448,0xa3985ff3)
HXLINE( 448)		CONCAVE = (int)-1;
            	}
{
            	HX_STACK_FRAME("haxegon.MathExtensions","boot",0x98042336,"haxegon.MathExtensions.boot","haxegon/MathExtensions.hx",449,0xa3985ff3)
HXLINE( 449)		TANGENTIAL = (int)0;
            	}
{
            	HX_STACK_FRAME("haxegon.MathExtensions","boot",0x98042336,"haxegon.MathExtensions.boot","haxegon/MathExtensions.hx",450,0xa3985ff3)
HXLINE( 450)		CONVEX = (int)1;
            	}
}

} // end namespace haxegon
