// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo_Cairo
#include <lime/graphics/cairo/Cairo.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoFTFontFace_CairoFTFontFace_Impl_
#include <lime/graphics/cairo/_CairoFTFontFace/CairoFTFontFace_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoFontOptions_CairoFontOptions_Impl_
#include <lime/graphics/cairo/_CairoFontOptions/CairoFontOptions_Impl_.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo__CairoImageSurface_CairoImageSurface_Impl_
#include <lime/graphics/cairo/_CairoImageSurface/CairoImageSurface_Impl_.h>
#endif
#ifndef INCLUDED_lime_math_Matrix3
#include <lime/math/Matrix3.h>
#endif
#ifndef INCLUDED_lime_text_Font
#include <lime/text/Font.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_RenderSession
#include <openfl/_internal/renderer/RenderSession.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_cairo_CairoTextField
#include <openfl/_internal/renderer/cairo/CairoTextField.h>
#endif
#ifndef INCLUDED_openfl__internal_text_TextEngine
#include <openfl/_internal/text/TextEngine.h>
#endif
#ifndef INCLUDED_openfl__internal_text_TextLayoutGroup
#include <openfl/_internal/text/TextLayoutGroup.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_text_Font
#include <openfl/text/Font.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif
#ifndef INCLUDED_openfl_text_TextFormat
#include <openfl/text/TextFormat.h>
#endif

namespace openfl{
namespace _internal{
namespace renderer{
namespace cairo{

void CairoTextField_obj::__construct() { }

Dynamic CairoTextField_obj::__CreateEmpty() { return new CairoTextField_obj; }

hx::ObjectPtr< CairoTextField_obj > CairoTextField_obj::__new()
{
	hx::ObjectPtr< CairoTextField_obj > _hx_result = new CairoTextField_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic CairoTextField_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< CairoTextField_obj > _hx_result = new CairoTextField_obj();
	_hx_result->__construct();
	return _hx_result;
}

void CairoTextField_obj::render( ::openfl::text::TextField textField, ::openfl::_internal::renderer::RenderSession renderSession, ::openfl::geom::Matrix transform){
            	HX_STACK_FRAME("openfl._internal.renderer.cairo.CairoTextField","render",0xabb9797e,"openfl._internal.renderer.cairo.CairoTextField.render","openfl/_internal/renderer/cairo/CairoTextField.hx",29,0xfadfb778)
            	HX_STACK_ARG(textField,"textField")
            	HX_STACK_ARG(renderSession,"renderSession")
            	HX_STACK_ARG(transform,"transform")
HXLINE(  33)		HX_VARI(  ::openfl::_internal::text::TextEngine,textEngine) = textField->_hx___textEngine;
HXLINE(  34)		HX_VARI(  ::openfl::geom::Rectangle,bounds) = textEngine->bounds;
HXLINE(  35)		HX_VARI(  ::openfl::display::Graphics,graphics) = textField->_hx___graphics;
HXLINE(  36)		HX_VARI(  ::lime::graphics::cairo::Cairo,cairo) = graphics->_hx___cairo;
HXLINE(  38)		Bool _hx_tmp = textField->_hx___dirty;
HXDLIN(  38)		if (_hx_tmp) {
HXLINE(  40)			textField->_hx___updateLayout();
HXLINE(  42)			Bool _hx_tmp1 = hx::IsNull( graphics->_hx___bounds );
HXDLIN(  42)			if (_hx_tmp1) {
HXLINE(  44)				graphics->_hx___bounds =  ::openfl::geom::Rectangle_obj::__new(null(),null(),null(),null());
            			}
HXLINE(  48)			graphics->_hx___bounds->copyFrom(bounds);
            		}
HXLINE(  52)		graphics->_hx___update();
HXLINE(  54)		HX_VARI( Int,width) = graphics->_hx___width;
HXLINE(  55)		HX_VARI( Int,height) = graphics->_hx___height;
HXLINE(  57)		Bool _hx_tmp2 = hx::IsNotNull( cairo );
HXDLIN(  57)		if (_hx_tmp2) {
HXLINE(  59)			HX_VARI(  ::Dynamic,surface) = cairo->get_target();
HXLINE(  61)			Bool _hx_tmp3;
HXDLIN(  61)			Int _hx_tmp4 = ::lime::graphics::cairo::_CairoImageSurface::CairoImageSurface_Impl__obj::get_width(surface);
HXDLIN(  61)			if ((width == _hx_tmp4)) {
HXLINE(  61)				Int _hx_tmp5 = ::lime::graphics::cairo::_CairoImageSurface::CairoImageSurface_Impl__obj::get_height(surface);
HXDLIN(  61)				_hx_tmp3 = (height != _hx_tmp5);
            			}
            			else {
HXLINE(  61)				_hx_tmp3 = true;
            			}
HXDLIN(  61)			if (_hx_tmp3) {
HXLINE(  63)				graphics->_hx___cairo = null();
HXLINE(  64)				graphics->_hx___visible = false;
HXLINE(  65)				cairo = null();
            			}
            		}
HXLINE(  71)		Bool _hx_tmp6;
HXDLIN(  71)		Bool _hx_tmp7;
HXDLIN(  71)		if ((width > (int)0)) {
HXLINE(  71)			_hx_tmp7 = (height <= (int)0);
            		}
            		else {
HXLINE(  71)			_hx_tmp7 = true;
            		}
HXDLIN(  71)		if (!(_hx_tmp7)) {
HXLINE(  71)			if (!(textField->_hx___dirty)) {
HXLINE(  71)				_hx_tmp6 = !(graphics->_hx___dirty);
            			}
            			else {
HXLINE(  71)				_hx_tmp6 = false;
            			}
            		}
            		else {
HXLINE(  71)			_hx_tmp6 = true;
            		}
HXDLIN(  71)		if (_hx_tmp6) {
HXLINE(  73)			textField->_hx___dirty = false;
HXLINE(  74)			return;
            		}
HXLINE(  78)		Bool _hx_tmp8 = hx::IsNull( cairo );
HXDLIN(  78)		if (_hx_tmp8) {
HXLINE(  80)			HX_VARI(  ::openfl::display::BitmapData,bitmap) =  ::openfl::display::BitmapData_obj::__new(width,height,true,(int)0);
HXLINE(  81)			HX_VARI_NAME(  ::Dynamic,surface1,"surface") = bitmap->getSurface();
HXLINE(  82)			graphics->_hx___cairo =  ::lime::graphics::cairo::Cairo_obj::__new(surface1);
HXLINE(  83)			graphics->_hx___visible = true;
HXLINE(  85)			graphics->_hx___bitmap = bitmap;
HXLINE(  87)			cairo = graphics->_hx___cairo;
HXLINE(  89)			HX_VARI(  ::Dynamic,options) = ::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::_new();
HXLINE(  91)			Bool _hx_tmp9;
HXDLIN(  91)			if (hx::IsEq( textEngine->antiAliasType,(int)0 )) {
HXLINE(  91)				_hx_tmp9 = (textEngine->sharpness == (int)400);
            			}
            			else {
HXLINE(  91)				_hx_tmp9 = false;
            			}
HXDLIN(  91)			if (_hx_tmp9) {
HXLINE(  93)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintStyle(options,(int)1);
HXLINE(  94)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintMetrics(options,(int)1);
HXLINE(  95)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_antialias(options,(int)1);
            			}
            			else {
HXLINE(  99)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintStyle(options,(int)0);
HXLINE( 100)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_hintMetrics(options,(int)1);
HXLINE( 101)				::lime::graphics::cairo::_CairoFontOptions::CairoFontOptions_Impl__obj::set_antialias(options,(int)5);
            			}
HXLINE( 105)			cairo->set_fontOptions(options);
            		}
HXLINE( 109)		Bool _hx_tmp10 = renderSession->roundPixels;
HXDLIN( 109)		if (_hx_tmp10) {
HXLINE( 111)			HX_VARI(  ::lime::math::Matrix3,matrix) = graphics->_hx___renderTransform->_hx___toMatrix3();
HXLINE( 112)			matrix->tx = ::Math_obj::round(matrix->tx);
HXLINE( 113)			matrix->ty = ::Math_obj::round(matrix->ty);
HXLINE( 114)			cairo->set_matrix(matrix);
            		}
            		else {
HXLINE( 118)			 ::lime::math::Matrix3 _hx_tmp11 = graphics->_hx___renderTransform->_hx___toMatrix3();
HXDLIN( 118)			cairo->set_matrix(_hx_tmp11);
            		}
HXLINE( 122)		Bool _hx_tmp12 = textEngine->border;
HXDLIN( 122)		if (_hx_tmp12) {
HXLINE( 124)			Float _hx_tmp13 = (bounds->width - (int)1);
HXDLIN( 124)			Int _hx_tmp14 = ::Std_obj::_hx_int(_hx_tmp13);
HXDLIN( 124)			Float _hx_tmp15 = (bounds->height - (int)1);
HXDLIN( 124)			Int _hx_tmp16 = ::Std_obj::_hx_int(_hx_tmp15);
HXDLIN( 124)			cairo->rectangle(((Float)0.5),((Float)0.5),_hx_tmp14,_hx_tmp16);
            		}
            		else {
HXLINE( 128)			cairo->rectangle((int)0,(int)0,bounds->width,bounds->height);
            		}
HXLINE( 132)		Bool _hx_tmp17 = !(textEngine->background);
HXDLIN( 132)		if (_hx_tmp17) {
HXLINE( 134)			cairo->set_operator((int)0);
HXLINE( 135)			cairo->paint();
HXLINE( 136)			cairo->set_operator((int)2);
            		}
            		else {
HXLINE( 140)			HX_VARI( Int,color) = textEngine->backgroundColor;
HXLINE( 145)			cairo->setSourceRGB(((Float)hx::UShr(((int)color & (int)(int)16711680),(int)16) / (Float)(int)255),((Float)hx::UShr(((int)color & (int)(int)65280),(int)8) / (Float)(int)255),((Float)((int)color & (int)(int)255) / (Float)(int)255));
HXLINE( 146)			cairo->fillPreserve();
            		}
HXLINE( 150)		Bool _hx_tmp18 = textEngine->border;
HXDLIN( 150)		if (_hx_tmp18) {
HXLINE( 152)			HX_VARI_NAME( Int,color1,"color") = textEngine->borderColor;
HXLINE( 157)			cairo->setSourceRGB(((Float)hx::UShr(((int)color1 & (int)(int)16711680),(int)16) / (Float)(int)255),((Float)hx::UShr(((int)color1 & (int)(int)65280),(int)8) / (Float)(int)255),((Float)((int)color1 & (int)(int)255) / (Float)(int)255));
HXLINE( 158)			cairo->set_lineWidth((int)1);
HXLINE( 159)			cairo->stroke();
            		}
HXLINE( 163)		Bool _hx_tmp19;
HXDLIN( 163)		Bool _hx_tmp20 = hx::IsNotNull( textEngine->text );
HXDLIN( 163)		if (_hx_tmp20) {
HXLINE( 163)			_hx_tmp19 = (textEngine->text != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 163)			_hx_tmp19 = false;
            		}
HXDLIN( 163)		if (_hx_tmp19) {
HXLINE( 165)			Int _hx_tmp21;
HXDLIN( 165)			Bool _hx_tmp22 = textField->get_border();
HXDLIN( 165)			if (_hx_tmp22) {
HXLINE( 165)				_hx_tmp21 = (int)1;
            			}
            			else {
HXLINE( 165)				_hx_tmp21 = (int)0;
            			}
HXDLIN( 165)			Float _hx_tmp23 = (bounds->width - _hx_tmp21);
HXDLIN( 165)			Int _hx_tmp24;
HXDLIN( 165)			Bool _hx_tmp25 = textField->get_border();
HXDLIN( 165)			if (_hx_tmp25) {
HXLINE( 165)				_hx_tmp24 = (int)1;
            			}
            			else {
HXLINE( 165)				_hx_tmp24 = (int)0;
            			}
HXDLIN( 165)			Float _hx_tmp26 = (bounds->height - _hx_tmp24);
HXDLIN( 165)			cairo->rectangle((int)0,(int)0,_hx_tmp23,_hx_tmp26);
HXLINE( 166)			cairo->clip();
HXLINE( 168)			HX_VARI( ::String,text) = textEngine->text;
HXLINE( 185)			HX_VARI( Int,scrollX) = -(textField->get_scrollH());
HXLINE( 186)			HX_VARI( Float,scrollY) = ((Float)0.0);
HXLINE( 188)			{
HXLINE( 188)				HX_VARI( Int,_g1) = (int)0;
HXDLIN( 188)				Int _hx_tmp27 = textField->get_scrollV();
HXDLIN( 188)				HX_VARI( Int,_g) = (_hx_tmp27 - (int)1);
HXDLIN( 188)				while((_g1 < _g)){
HXLINE( 188)					HX_VARI( Int,i) = _g1++;
HXLINE( 190)					hx::SubEq(scrollY,textEngine->lineHeights->__get(i));
            				}
            			}
HXLINE( 194)			HX_VAR_NAME(  ::Dynamic,color2,"color");
HXDLIN( 194)			HX_VAR( Float,r);
HXDLIN( 194)			HX_VAR( Float,g);
HXDLIN( 194)			HX_VAR( Float,b);
HXDLIN( 194)			HX_VAR(  ::openfl::text::Font,font);
HXDLIN( 194)			HX_VAR( Int,size);
HXDLIN( 194)			HX_VAR( Float,advance);
HXLINE( 196)			{
HXLINE( 196)				HX_VARI_NAME( Int,_g2,"_g") = (int)0;
HXDLIN( 196)				HX_VARI_NAME( ::Array< ::Dynamic>,_g11,"_g1") = textEngine->layoutGroups;
HXDLIN( 196)				while((_g2 < _g11->length)){
HXLINE( 196)					HX_VARI(  ::openfl::_internal::text::TextLayoutGroup,group) = _g11->__get(_g2).StaticCast<  ::openfl::_internal::text::TextLayoutGroup >();
HXDLIN( 196)					++_g2;
HXLINE( 198)					Int _hx_tmp28 = group->lineIndex;
HXDLIN( 198)					Int _hx_tmp29 = textField->get_scrollV();
HXDLIN( 198)					if ((_hx_tmp28 < (_hx_tmp29 - (int)1))) {
HXLINE( 198)						continue;
            					}
HXLINE( 199)					Int _hx_tmp30 = group->lineIndex;
HXDLIN( 199)					Int _hx_tmp31 = textField->get_scrollV();
HXDLIN( 199)					if ((_hx_tmp30 > ((_hx_tmp31 + textEngine->bottomScrollV) - (int)2))) {
HXLINE( 199)						goto _hx_goto_1;
            					}
HXLINE( 201)					color2 = group->format->color;
HXLINE( 202)					r = ((Float)hx::UShr(((int)color2 & (int)(int)16711680),(int)16) / (Float)(int)255);
HXLINE( 203)					g = ((Float)hx::UShr(((int)color2 & (int)(int)65280),(int)8) / (Float)(int)255);
HXLINE( 204)					b = ((Float)((int)color2 & (int)(int)255) / (Float)(int)255);
HXLINE( 206)					cairo->setSourceRGB(r,g,b);
HXLINE( 208)					font = ::openfl::_internal::text::TextEngine_obj::getFontInstance(group->format);
HXLINE( 210)					Bool _hx_tmp32;
HXDLIN( 210)					Bool _hx_tmp33 = hx::IsNotNull( font );
HXDLIN( 210)					if (_hx_tmp33) {
HXLINE( 210)						_hx_tmp32 = hx::IsNotNull( group->format->size );
            					}
            					else {
HXLINE( 210)						_hx_tmp32 = false;
            					}
HXDLIN( 210)					if (_hx_tmp32) {
HXLINE( 212)						Bool _hx_tmp34 = hx::IsNotNull( textEngine->_hx___cairoFont );
HXDLIN( 212)						if (_hx_tmp34) {
HXLINE( 214)							if (hx::IsNotEq( textEngine->_hx___font,font )) {
HXLINE( 216)								textEngine->_hx___cairoFont = null();
            							}
            						}
HXLINE( 222)						Bool _hx_tmp35 = hx::IsNull( textEngine->_hx___cairoFont );
HXDLIN( 222)						if (_hx_tmp35) {
HXLINE( 224)							textEngine->_hx___font = font;
HXLINE( 225)							textEngine->_hx___cairoFont = ::lime::graphics::cairo::_CairoFTFontFace::CairoFTFontFace_Impl__obj::create(font,(int)0);
            						}
HXLINE( 229)						cairo->set_fontFace(textEngine->_hx___cairoFont);
HXLINE( 231)						size = ::Std_obj::_hx_int(group->format->size);
HXLINE( 232)						cairo->setFontSize(size);
HXLINE( 234)						Float _hx_tmp36 = (group->offsetX + scrollX);
HXDLIN( 234)						Float _hx_tmp37 = ((group->offsetY + group->ascent) + scrollY);
HXDLIN( 234)						cairo->moveTo(_hx_tmp36,_hx_tmp37);
HXLINE( 255)						::String _hx_tmp38 = text.substring(group->startIndex,group->endIndex);
HXDLIN( 255)						cairo->showText(_hx_tmp38);
HXLINE( 257)						Bool _hx_tmp39;
HXDLIN( 257)						if ((textField->_hx___caretIndex > (int)-1)) {
HXLINE( 257)							_hx_tmp39 = textEngine->selectable;
            						}
            						else {
HXLINE( 257)							_hx_tmp39 = false;
            						}
HXDLIN( 257)						if (_hx_tmp39) {
HXLINE( 259)							Bool _hx_tmp40 = (textField->_hx___selectionIndex == textField->_hx___caretIndex);
HXDLIN( 259)							if (_hx_tmp40) {
HXLINE( 261)								Bool _hx_tmp41;
HXDLIN( 261)								Bool _hx_tmp42;
HXDLIN( 261)								if (textField->_hx___showCursor) {
HXLINE( 261)									_hx_tmp42 = (group->startIndex <= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 261)									_hx_tmp42 = false;
            								}
HXDLIN( 261)								if (_hx_tmp42) {
HXLINE( 261)									_hx_tmp41 = (group->endIndex >= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 261)									_hx_tmp41 = false;
            								}
HXDLIN( 261)								if (_hx_tmp41) {
HXLINE( 263)									advance = ((Float)0.0);
HXLINE( 265)									{
HXLINE( 265)										HX_VARI( Int,_g3) = (int)0;
HXDLIN( 265)										HX_VARI_NAME( Int,_g21,"_g2") = (textField->_hx___caretIndex - group->startIndex);
HXDLIN( 265)										while((_g3 < _g21)){
HXLINE( 265)											HX_VARI_NAME( Int,i1,"i") = _g3++;
HXLINE( 267)											if ((group->advances->length <= i1)) {
HXLINE( 267)												goto _hx_goto_2;
            											}
HXLINE( 268)											hx::AddEq(advance,group->advances->__get(i1));
            										}
            										_hx_goto_2:;
            									}
HXLINE( 272)									Float _hx_tmp43 = (group->offsetX + advance);
HXDLIN( 272)									Int _hx_tmp44 = ::Math_obj::floor(_hx_tmp43);
HXDLIN( 272)									Float _hx_tmp45 = (_hx_tmp44 + ((Float)0.5));
HXDLIN( 272)									Float _hx_tmp46 = (group->offsetY + ((Float)0.5));
HXDLIN( 272)									cairo->moveTo(_hx_tmp45,_hx_tmp46);
HXLINE( 273)									cairo->set_lineWidth((int)1);
HXLINE( 274)									Float _hx_tmp47 = (group->offsetX + advance);
HXDLIN( 274)									Int _hx_tmp48 = ::Math_obj::floor(_hx_tmp47);
HXDLIN( 274)									Float _hx_tmp49 = (_hx_tmp48 + ((Float)0.5));
HXDLIN( 274)									Float _hx_tmp50 = ((group->offsetY + group->height) - (int)1);
HXDLIN( 274)									cairo->lineTo(_hx_tmp49,_hx_tmp50);
HXLINE( 275)									cairo->stroke();
            								}
            							}
            							else {
HXLINE( 279)								Bool _hx_tmp51;
HXDLIN( 279)								Bool _hx_tmp52;
HXDLIN( 279)								if ((group->startIndex <= textField->_hx___caretIndex)) {
HXLINE( 279)									_hx_tmp52 = (group->endIndex >= textField->_hx___caretIndex);
            								}
            								else {
HXLINE( 279)									_hx_tmp52 = false;
            								}
HXDLIN( 279)								if (!(_hx_tmp52)) {
HXLINE( 279)									if ((group->startIndex <= textField->_hx___selectionIndex)) {
HXLINE( 279)										_hx_tmp51 = (group->endIndex >= textField->_hx___selectionIndex);
            									}
            									else {
HXLINE( 279)										_hx_tmp51 = false;
            									}
            								}
            								else {
HXLINE( 279)									_hx_tmp51 = true;
            								}
HXDLIN( 279)								if (_hx_tmp51) {
HXLINE( 281)									Float _hx_tmp53 = ::Math_obj::min(textField->_hx___selectionIndex,textField->_hx___caretIndex);
HXDLIN( 281)									HX_VARI( Int,selectionStart) = ::Std_obj::_hx_int(_hx_tmp53);
HXLINE( 282)									Float _hx_tmp54 = ::Math_obj::max(textField->_hx___selectionIndex,textField->_hx___caretIndex);
HXDLIN( 282)									HX_VARI( Int,selectionEnd) = ::Std_obj::_hx_int(_hx_tmp54);
HXLINE( 284)									Bool _hx_tmp55 = (group->startIndex > selectionStart);
HXDLIN( 284)									if (_hx_tmp55) {
HXLINE( 286)										selectionStart = group->startIndex;
            									}
HXLINE( 290)									Bool _hx_tmp56 = (group->endIndex < selectionEnd);
HXDLIN( 290)									if (_hx_tmp56) {
HXLINE( 292)										selectionEnd = group->endIndex;
            									}
HXLINE( 296)									HX_VAR(  ::openfl::geom::Rectangle,start);
HXDLIN( 296)									HX_VAR(  ::openfl::geom::Rectangle,end);
HXLINE( 298)									start = textField->getCharBoundaries(selectionStart);
HXLINE( 300)									Bool _hx_tmp57 = (selectionEnd >= textEngine->text.length);
HXDLIN( 300)									if (_hx_tmp57) {
HXLINE( 302)										Int _hx_tmp58 = (textEngine->text.length - (int)1);
HXDLIN( 302)										end = textField->getCharBoundaries(_hx_tmp58);
HXLINE( 303)										hx::AddEq(end->x,(end->width + (int)2));
            									}
            									else {
HXLINE( 307)										end = textField->getCharBoundaries(selectionEnd);
            									}
HXLINE( 311)									Bool _hx_tmp59;
HXDLIN( 311)									Bool _hx_tmp60 = hx::IsNotNull( start );
HXDLIN( 311)									if (_hx_tmp60) {
HXLINE( 311)										_hx_tmp59 = hx::IsNotNull( end );
            									}
            									else {
HXLINE( 311)										_hx_tmp59 = false;
            									}
HXDLIN( 311)									if (_hx_tmp59) {
HXLINE( 313)										cairo->setSourceRGB((int)0,(int)0,(int)0);
HXLINE( 314)										Float _hx_tmp61 = start->x;
HXDLIN( 314)										Float _hx_tmp62 = start->y;
HXDLIN( 314)										Float _hx_tmp63 = (end->x - start->x);
HXDLIN( 314)										cairo->rectangle(_hx_tmp61,_hx_tmp62,_hx_tmp63,group->height);
HXLINE( 315)										cairo->fill();
HXLINE( 316)										cairo->setSourceRGB((int)1,(int)1,(int)1);
HXLINE( 320)										Float _hx_tmp64 = (scrollX + start->x);
HXDLIN( 320)										Float _hx_tmp65 = ((group->offsetY + group->ascent) + scrollY);
HXDLIN( 320)										cairo->moveTo(_hx_tmp64,_hx_tmp65);
HXLINE( 321)										::String _hx_tmp66 = text.substring(selectionStart,selectionEnd);
HXDLIN( 321)										cairo->showText(_hx_tmp66);
            									}
            								}
            							}
            						}
            					}
            				}
            				_hx_goto_1:;
            			}
            		}
HXLINE( 335)		graphics->_hx___bitmap->image->dirty = true;
HXLINE( 336)		graphics->_hx___bitmap->image->version++;
HXLINE( 337)		textField->_hx___dirty = false;
HXLINE( 338)		graphics->set___dirty(false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(CairoTextField_obj,render,(void))


CairoTextField_obj::CairoTextField_obj()
{
}

bool CairoTextField_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *CairoTextField_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *CairoTextField_obj_sStaticStorageInfo = 0;
#endif

static void CairoTextField_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(CairoTextField_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void CairoTextField_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(CairoTextField_obj::__mClass,"__mClass");
};

#endif

hx::Class CairoTextField_obj::__mClass;

static ::String CairoTextField_obj_sStaticFields[] = {
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	::String(null())
};

void CairoTextField_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.cairo.CairoTextField","\x46","\x1d","\x84","\xa5");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &CairoTextField_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = CairoTextField_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(CairoTextField_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< CairoTextField_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = CairoTextField_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CairoTextField_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CairoTextField_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace cairo
