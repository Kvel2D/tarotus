// Generated by Haxe 3.3.0
#ifndef INCLUDED_haxegon_MathExtensions
#define INCLUDED_haxegon_MathExtensions

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_CLASS1(haxegon,MathExtensions)

namespace haxegon{


class HXCPP_CLASS_ATTRIBUTES MathExtensions_obj : public hx::Object
{
	public:
		typedef hx::Object super;
		typedef MathExtensions_obj OBJ_;
		MathExtensions_obj();

	public:
		void __construct();
		inline void *operator new(size_t inSize, bool inContainer=false,const char *inName="haxegon.MathExtensions")
			{ return hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return hx::Object::operator new(inSize+extra,false,"haxegon.MathExtensions"); }
		static hx::ObjectPtr< MathExtensions_obj > __new();
		static Dynamic __CreateEmpty();
		static Dynamic __Create(hx::DynamicArray inArgs);
		//~MathExtensions_obj();

		HX_DO_RTTI_ALL;
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, hx::PropertyAccess inCallProp);
		static void __register();
		::String __ToString() const { return HX_HCSTRING("MathExtensions","\x1c","\x60","\x4c","\xa1"); }

		static void __boot();
		static  ::Dynamic project_circle(hx::Class math,Float x,Float y,Float r, ::Dynamic axis);
		static ::Dynamic project_circle_dyn();

		static  ::Dynamic project_triangle(hx::Class math,::Array< Float > tri, ::Dynamic axis);
		static ::Dynamic project_triangle_dyn();

		static  ::Dynamic project_rectangle(hx::Class math,Float x,Float y,Float width,Float height, ::Dynamic axis);
		static ::Dynamic project_rectangle_dyn();

		static ::String fixed_float(hx::Class math,Float x,Int precision);
		static ::Dynamic fixed_float_dyn();

		static Float collision_1d(hx::Class math,Float a1,Float a2,Float b1,Float b2);
		static ::Dynamic collision_1d_dyn();

		static Float max3(hx::Class math,Float x1,Float x2,Float x3);
		static ::Dynamic max3_dyn();

		static Float max4(hx::Class math,Float x1,Float x2,Float x3,Float x4);
		static ::Dynamic max4_dyn();

		static Float min3(hx::Class math,Float x1,Float x2,Float x3);
		static ::Dynamic min3_dyn();

		static Float min4(hx::Class math,Float x1,Float x2,Float x3,Float x4);
		static ::Dynamic min4_dyn();

		static void scale_vertices(hx::Class math,::Array< Float > vertices,Float scale, ::Dynamic x, ::Dynamic y);
		static ::Dynamic scale_vertices_dyn();

		static void translate_vertices(hx::Class math,::Array< Float > vertices,Float dx,Float dy);
		static ::Dynamic translate_vertices_dyn();

		static ::Array< Float > rotate_vertices(hx::Class math,::Array< Float > vertices,Float origin_x,Float origin_y,Float angle);
		static ::Dynamic rotate_vertices_dyn();

		static void rotate_vector(hx::Class math, ::Dynamic point,Float origin_x,Float origin_y,Float angle);
		static ::Dynamic rotate_vector_dyn();

		static Float dot(hx::Class math,Float ux,Float uy,Float vx,Float vy);
		static ::Dynamic dot_dyn();

		static  ::Dynamic normalize(hx::Class math, ::Dynamic v);
		static ::Dynamic normalize_dyn();

		static  ::Dynamic project(hx::Class math,Float ux,Float uy,Float vx,Float vy);
		static ::Dynamic project_dyn();

		static Float line_point_sign(hx::Class math,Float px,Float py,Float lx1,Float ly1,Float lx2,Float ly2);
		static ::Dynamic line_point_sign_dyn();

		static  ::Dynamic poly_centroid(hx::Class math,::Array< Float > poly);
		static ::Dynamic poly_centroid_dyn();

		static Bool line_line_intersect(hx::Class math,Float p0_x,Float p0_y,Float p1_x,Float p1_y,Float p2_x,Float p2_y,Float p3_x,Float p3_y, ::Dynamic intersection);
		static ::Dynamic line_line_intersect_dyn();

		static Bool point_box_intersect(hx::Class math,Float point_x,Float point_y,Float box_x,Float box_y,Float box_width,Float box_height);
		static ::Dynamic point_box_intersect_dyn();

		static Bool box_box_intersect(hx::Class math,Float x1,Float y1,Float width1,Float height1,Float x2,Float y2,Float width2,Float height2);
		static ::Dynamic box_box_intersect_dyn();

		static Bool circle_circle_intersect(hx::Class math,Float x1,Float y1,Float r1,Float x2,Float y2,Float r2);
		static ::Dynamic circle_circle_intersect_dyn();

		static Bool circle_polygon_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,::Array< Float > polygon);
		static ::Dynamic circle_polygon_intersect_dyn();

		static Bool circle_tri_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,::Array< Float > tri);
		static ::Dynamic circle_tri_intersect_dyn();

		static Bool circle_line_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,Float line_x1,Float line_y1,Float line_x2,Float line_y2);
		static ::Dynamic circle_line_intersect_dyn();

		static Bool circle_point_intersect(hx::Class math,Float circle_x,Float circle_y,Float circle_radius,Float point_x,Float point_y);
		static ::Dynamic circle_point_intersect_dyn();

		static Float point_line_dst2(hx::Class math,Float point_x,Float point_y,Float line_x1,Float line_y1,Float line_x2,Float line_y2);
		static ::Dynamic point_line_dst2_dyn();

		static Float point_line_dst(hx::Class math,Float point_x,Float point_y,Float line_x1,Float line_y1,Float line_x2,Float line_y2);
		static ::Dynamic point_line_dst_dyn();

		static Float point_line_dst_3d(hx::Class math,Float point_x,Float point_y,Float point_z,Float line_x1,Float line_y1,Float line_z1,Float line_x2,Float line_y2,Float line_z2);
		static ::Dynamic point_line_dst_3d_dyn();

		static Float dst(hx::Class math,Float x1,Float y1,Float x2,Float y2);
		static ::Dynamic dst_dyn();

		static Float dst2(hx::Class math,Float x1,Float y1,Float x2,Float y2);
		static ::Dynamic dst2_dyn();

		static Float dst3d(hx::Class math,Float x1,Float y1,Float z1,Float x2,Float y2,Float z2);
		static ::Dynamic dst3d_dyn();

		static Float dst3d2(hx::Class math,Float x1,Float y1,Float z1,Float x2,Float y2,Float z2);
		static ::Dynamic dst3d2_dyn();

		static Float rad_to_deg(hx::Class math,Float angle);
		static ::Dynamic rad_to_deg_dyn();

		static Float deg_to_rad(hx::Class math,Float angle);
		static ::Dynamic deg_to_rad_dyn();

		static Int sign(hx::Class math,Float x);
		static ::Dynamic sign_dyn();

		static Float lerp(hx::Class math,Float x1,Float x2,Float a);
		static ::Dynamic lerp_dyn();

		static Float mean(hx::Class math,::Array< Float > v);
		static ::Dynamic mean_dyn();

		static Float std_dev(hx::Class math,::Array< Float > v);
		static ::Dynamic std_dev_dyn();

		static Float inner_product(hx::Class math,::Array< Float > m1,::Array< Float > m2);
		static ::Dynamic inner_product_dyn();

		static ::Array< ::Dynamic> outer_product(hx::Class math,::Array< Float > v1,::Array< Float > v2,::Array< ::Dynamic> out);
		static ::Dynamic outer_product_dyn();

		static ::Array< ::Dynamic> mat_transpose(hx::Class math,::Array< ::Dynamic> m,::Array< ::Dynamic> out);
		static ::Dynamic mat_transpose_dyn();

		static ::Array< ::Dynamic> mat_add(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out);
		static ::Dynamic mat_add_dyn();

		static ::Array< ::Dynamic> mat_dot(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out);
		static ::Dynamic mat_dot_dyn();

		static ::Array< ::Dynamic> mat_scalar_mult(hx::Class math,::Array< ::Dynamic> m,Float s,::Array< ::Dynamic> out);
		static ::Dynamic mat_scalar_mult_dyn();

		static ::Array< ::Dynamic> hadamard_product(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out);
		static ::Dynamic hadamard_product_dyn();

		static ::Array< ::Dynamic> kronecker_product(hx::Class math,::Array< Float > v1,::Array< Float > v2,::Array< ::Dynamic> out);
		static ::Dynamic kronecker_product_dyn();

		static ::Array< ::Dynamic> mat_concat_horizontal(hx::Class math,::Array< ::Dynamic> m1,::Array< ::Dynamic> m2,::Array< ::Dynamic> out);
		static ::Dynamic mat_concat_horizontal_dyn();

		static Int CONCAVE;
		static Int TANGENTIAL;
		static Int CONVEX;
		static ::Array< Int > triangulate(hx::Class math,::Array< Float > vertices);
		static ::Dynamic triangulate_dyn();

		static ::Array< ::Dynamic> indices_to_vertices(hx::Class math,::Array< Float > polygon,::Array< Int > indices);
		static ::Dynamic indices_to_vertices_dyn();

};

} // end namespace haxegon

#endif /* INCLUDED_haxegon_MathExtensions */ 
